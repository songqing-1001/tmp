<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>LLVM: lib/Target/X86/TargetInfo/X86TargetInfo.cpp Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">LLVM
   &#160;<span id="projectnumber">17.0.0git</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_97aefd0d527b934f1d99a682da8fe6a9.html">lib</a></li><li class="navelem"><a class="el" href="dir_794e483eb1cc7921d35fd149d9cc325b.html">Target</a></li><li class="navelem"><a class="el" href="dir_558b7c0c66e2ff4834e628dd4b3edd32.html">X86</a></li><li class="navelem"><a class="el" href="dir_32d3208121019942dc9cbaa52385dba7.html">TargetInfo</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">X86TargetInfo.cpp</div>  </div>
</div><!--header-->
<div class="contents">
<a href="X86TargetInfo_8cpp.html">Go to the documentation of this file.</a><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;<span class="comment">//===-- X86TargetInfo.cpp - X86 Target Implementation ---------------------===//</span></div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;<span class="comment">//</span></div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;<span class="comment">// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.</span></div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;<span class="comment">// See https://llvm.org/LICENSE.txt for license information.</span></div>
<div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;<span class="comment">// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception</span></div>
<div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;<span class="comment">//</span></div>
<div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;<span class="comment">//===----------------------------------------------------------------------===//</span></div>
<div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160; </div>
<div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;<span class="preprocessor">#include &quot;<a class="code" href="X86TargetInfo_8h.html">TargetInfo/X86TargetInfo.h</a>&quot;</span></div>
<div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;<span class="preprocessor">#include &quot;<a class="code" href="TargetRegistry_8h.html">llvm/MC/TargetRegistry.h</a>&quot;</span></div>
<div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;<span class="keyword">using namespace </span><a class="code" href="namespacellvm.html">llvm</a>;</div>
<div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160; </div>
<div class="line"><a name="l00013"></a><span class="lineno"><a class="line" href="namespacellvm.html#a35832c1b6a34093b01da33c2501a22ed">   13</a></span>&#160;<a class="code" href="classllvm_1_1Target.html">Target</a> &amp;<a class="code" href="namespacellvm.html#a35832c1b6a34093b01da33c2501a22ed">llvm::getTheX86_32Target</a>() {</div>
<div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;  <span class="keyword">static</span> <a class="code" href="classllvm_1_1Target.html">Target</a> TheX86_32Target;</div>
<div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;  <span class="keywordflow">return</span> TheX86_32Target;</div>
<div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160;}</div>
<div class="line"><a name="l00017"></a><span class="lineno"><a class="line" href="namespacellvm.html#ae6431492d4966df0bafe4680216f76b7">   17</a></span>&#160;<a class="code" href="classllvm_1_1Target.html">Target</a> &amp;<a class="code" href="namespacellvm.html#ae6431492d4966df0bafe4680216f76b7">llvm::getTheX86_64Target</a>() {</div>
<div class="line"><a name="l00018"></a><span class="lineno">   18</span>&#160;  <span class="keyword">static</span> <a class="code" href="classllvm_1_1Target.html">Target</a> TheX86_64Target;</div>
<div class="line"><a name="l00019"></a><span class="lineno">   19</span>&#160;  <span class="keywordflow">return</span> TheX86_64Target;</div>
<div class="line"><a name="l00020"></a><span class="lineno">   20</span>&#160;}</div>
<div class="line"><a name="l00021"></a><span class="lineno">   21</span>&#160; </div>
<div class="line"><a name="l00022"></a><span class="lineno"><a class="line" href="X86TargetInfo_8cpp.html#a322daa16581038024ce0d2d04e5091d1">   22</a></span>&#160;<span class="keyword">extern</span> <span class="stringliteral">&quot;C&quot;</span> <a class="code" href="Compiler_8h.html#adeb6f14d9f377993d79fae2efb34ecac">LLVM_EXTERNAL_VISIBILITY</a> <span class="keywordtype">void</span> <a class="code" href="X86TargetInfo_8cpp.html#a322daa16581038024ce0d2d04e5091d1">LLVMInitializeX86TargetInfo</a>() {</div>
<div class="line"><a name="l00023"></a><span class="lineno">   23</span>&#160;  <a class="code" href="structllvm_1_1RegisterTarget.html">RegisterTarget</a>&lt;<a class="code" href="classllvm_1_1Triple.html#a547abd13f7a3c063aa72c8192a868154a0eefa3e53db25b90828e42c64b138648">Triple::x86</a>, <span class="comment">/*HasJIT=*/</span><span class="keyword">true</span>&gt; <a class="code" href="ErlangGCPrinter_8cpp.html#a74b474c0616ab55c1d9487f11fd31d26">X</a>(</div>
<div class="line"><a name="l00024"></a><span class="lineno">   24</span>&#160;      <a class="code" href="namespacellvm.html#a35832c1b6a34093b01da33c2501a22ed">getTheX86_32Target</a>(), <span class="stringliteral">&quot;x86&quot;</span>, <span class="stringliteral">&quot;32-bit X86: Pentium-Pro and above&quot;</span>, <span class="stringliteral">&quot;X86&quot;</span>);</div>
<div class="line"><a name="l00025"></a><span class="lineno">   25</span>&#160; </div>
<div class="line"><a name="l00026"></a><span class="lineno">   26</span>&#160;  <a class="code" href="structllvm_1_1RegisterTarget.html">RegisterTarget</a>&lt;<a class="code" href="classllvm_1_1Triple.html#a547abd13f7a3c063aa72c8192a868154a13d8ce5e71051718a537277c6a594062">Triple::x86_64</a>, <span class="comment">/*HasJIT=*/</span><span class="keyword">true</span>&gt; <a class="code" href="OcamlGCPrinter_8cpp.html#afcf2f797ed287a723263583c9b1c1bce">Y</a>(</div>
<div class="line"><a name="l00027"></a><span class="lineno">   27</span>&#160;      <a class="code" href="namespacellvm.html#ae6431492d4966df0bafe4680216f76b7">getTheX86_64Target</a>(), <span class="stringliteral">&quot;x86-64&quot;</span>, <span class="stringliteral">&quot;64-bit X86: EM64T and AMD64&quot;</span>, <span class="stringliteral">&quot;X86&quot;</span>);</div>
<div class="line"><a name="l00028"></a><span class="lineno">   28</span>&#160;}</div>
</div><!-- fragment --></div><!-- contents -->
<div class="ttc" id="alib_2Target_2PowerPC_2README_8txt_html_acac11578b87ac8c909bd20b9b44bf833"><div class="ttname"><a href="lib_2Target_2PowerPC_2README_8txt.html#acac11578b87ac8c909bd20b9b44bf833">z</a></div><div class="ttdeci">return z</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2PowerPC_2README_8txt_source.html#l00014">README.txt:14</a></div></div>
<div class="ttc" id="alib_2Target_2README_8txt_html_acb559820d9ca11295b4500f179ef6392"><div class="ttname"><a href="lib_2Target_2README_8txt.html#acb559820d9ca11295b4500f179ef6392">i</a></div><div class="ttdeci">i</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2README_8txt_source.html#l00029">README.txt:29</a></div></div>
<div class="ttc" id="aLocalizer_8cpp_html_a428090a453f41a199ef67fc3f2179fbc"><div class="ttname"><a href="Localizer_8cpp.html#a428090a453f41a199ef67fc3f2179fbc">use</a></div><div class="ttdeci">Move duplicate certain instructions close to their use</div><div class="ttdef"><b>Definition:</b> <a href="Localizer_8cpp_source.html#l00032">Localizer.cpp:32</a></div></div>
<div class="ttc" id="aREADME-SSE_8txt_html_af42a88ebe3906566f3345b01d932af94"><div class="ttname"><a href="README-SSE_8txt.html#af42a88ebe3906566f3345b01d932af94">movaps</a></div><div class="ttdeci">This might compile to this xmm1 xorps xmm0 movss xmm0 ret Now consider if the code caused xmm1 to get spilled This might produce this xmm1 movaps xmm0 movaps xmm1 movss xmm0 ret since the reload is only used by these we could fold it into the producing something like xmm1 movaps xmm0 ret saving two instructions The basic idea is that a reload from a spill if only one byte chunk is bring in zeros the one element instead of elements This can be used to simplify a variety of shuffle where the elements are fixed zeros This code generates ugly probably due to costs being off or&lt; 4 x float &gt; eax movaps(%eax)</div></div>
<div class="ttc" id="aREADME-SSE_8txt_html_a3dd9d292ac64e68f4334c22a25cc4332"><div class="ttname"><a href="README-SSE_8txt.html#a3dd9d292ac64e68f4334c22a25cc4332">x</a></div><div class="ttdeci">void x(unsigned short n)</div><div class="ttdef"><b>Definition:</b> <a href="README-SSE_8txt_source.html#l00355">README-SSE.txt:355</a></div></div>
<div class="ttc" id="alib_2Target_2X86_2README_8txt_html_a9a315d042512705500b545a6c6acb2bd"><div class="ttname"><a href="lib_2Target_2X86_2README_8txt.html#a9a315d042512705500b545a6c6acb2bd">set</a></div><div class="ttdeci">We currently generate a but we really shouldn eax ecx xorl edx divl ecx eax divl ecx movl eax ret A similar code sequence works for division We currently compile i32 v2 eax eax jo LBB1_2 atomic and others It is also currently not done for read modify write instructions It is also current not done if the OF or CF flags are needed The shift operators have the complication that when the shift count is EFLAGS is not set</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2X86_2README_8txt_source.html#l01277">README.txt:1277</a></div></div>
<div class="ttc" id="aAMDGPUPropagateAttributes_8cpp_html_a89aee22a588785ca0c0755b95871b79e"><div class="ttname"><a href="AMDGPUPropagateAttributes_8cpp.html#a89aee22a588785ca0c0755b95871b79e">functions</a></div><div class="ttdeci">amdgpu propagate attributes Late propagate attributes from kernels to functions</div><div class="ttdef"><b>Definition:</b> <a href="AMDGPUPropagateAttributes_8cpp_source.html#l00196">AMDGPUPropagateAttributes.cpp:196</a></div></div>
<div class="ttc" id="aCOFFEmitter_8cpp_html_a22d45f704c4ada710d51c88aeb831ef5"><div class="ttname"><a href="COFFEmitter_8cpp.html#a22d45f704c4ada710d51c88aeb831ef5">zeros</a></div><div class="ttdeci">zeros_impl&lt; sizeof(T)&gt; zeros(const T &amp;)</div><div class="ttdef"><b>Definition:</b> <a href="COFFEmitter_8cpp_source.html#l00340">COFFEmitter.cpp:340</a></div></div>
<div class="ttc" id="aRelocation_8txt_html_a7d6a42b5e611ba278973ae2d22527175"><div class="ttname"><a href="Relocation_8txt.html#a7d6a42b5e611ba278973ae2d22527175">ABI</a></div><div class="ttdeci">Generic address nodes are lowered to some combination of target independent and machine specific ABI</div><div class="ttdef"><b>Definition:</b> <a href="Relocation_8txt_source.html#l00034">Relocation.txt:34</a></div></div>
<div class="ttc" id="alib_2Target_2ARM_2README_8txt_html_aa660bb6aec19f6cb361a36080a776dfb"><div class="ttname"><a href="lib_2Target_2ARM_2README_8txt.html#aa660bb6aec19f6cb361a36080a776dfb">is</a></div><div class="ttdeci">should just be implemented with a CLZ instruction Since there are other e that share this it would be best to implement this in a target independent as zero is the default value for the binary encoder e add r0 add r5 Register operands should be distinct That is</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2ARM_2README_8txt_source.html#l00725">README.txt:725</a></div></div>
<div class="ttc" id="alib_2Target_2README_8txt_html_a86a8d7c35fb9eeb53412ca9bca388e99"><div class="ttname"><a href="lib_2Target_2README_8txt.html#a86a8d7c35fb9eeb53412ca9bca388e99">as</a></div><div class="ttdeci">compiles conv shl5 shl ret i32 or10 it would be better as</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2README_8txt_source.html#l00615">README.txt:615</a></div></div>
<div class="ttc" id="alib_2Target_2X86_2README_8txt_html_adedeae97594f529f238e0b07c49d5446"><div class="ttname"><a href="lib_2Target_2X86_2README_8txt.html#adedeae97594f529f238e0b07c49d5446">ecx</a></div><div class="ttdeci">Instead of the following for memset char edx edx edx It might be better to generate eax movl edx movl edx movw edx when we can spare a register It reduces code size Evaluate what the best way to codegen sdiv C is For we currently get ret i32 Y eax movl ecx ecx ecx addl ecx</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2X86_2README_8txt_source.html#l00147">README.txt:147</a></div></div>
<div class="ttc" id="alib_2Target_2README_8txt_html_ab3a565d6137879762c72e84859593753"><div class="ttname"><a href="lib_2Target_2README_8txt.html#ab3a565d6137879762c72e84859593753">then</a></div><div class="ttdeci">RUN&lt; i32 &gt;&lt; i1 &gt; br i1 label then</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2README_8txt_source.html#l00338">README.txt:338</a></div></div>
<div class="ttc" id="alib_2Target_2ARM_2README_8txt_html_a04f7235e9b275db7f5f4dc933e52aac1"><div class="ttname"><a href="lib_2Target_2ARM_2README_8txt.html#a04f7235e9b275db7f5f4dc933e52aac1">targets</a></div><div class="ttdeci">should just be implemented with a CLZ instruction Since there are other targets</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2ARM_2README_8txt_source.html#l00709">README.txt:709</a></div></div>
<div class="ttc" id="aREADME-SSE_8txt_html_afe62d3b93da0f864d7f9b2e0c3bfd820"><div class="ttname"><a href="README-SSE_8txt.html#afe62d3b93da0f864d7f9b2e0c3bfd820">right</a></div><div class="ttdeci">the custom lowered code happens to be right</div><div class="ttdef"><b>Definition:</b> <a href="README-SSE_8txt_source.html#l00480">README-SSE.txt:480</a></div></div>
<div class="ttc" id="aREADME-SSE_8txt_html_ad525ee20da27af5b492be13ed4a3c944"><div class="ttname"><a href="README-SSE_8txt.html#ad525ee20da27af5b492be13ed4a3c944">load</a></div><div class="ttdeci">into xmm2 addss xmm2 xmm1 xmm3 addss xmm3 movaps xmm0 unpcklps xmm0 ret seems silly when it could just be one addps Expand libm rounding functions main should enable SSE DAZ mode and other fast SSE modes Think about doing i64 math in SSE regs on x86 This testcase should have no SSE instructions in and only one load from a constant double ret double C the select is being which prevents the dag combiner from turning load CPI2 load(select CPI1, CPI2)' The pattern isel got this one right. Lower memcpy/memset to a series of SSE 128 bit move instructions when it 's feasible. Codegen</div><div class="ttdef"><b>Definition:</b> <a href="README-SSE_8txt_source.html#l00090">README-SSE.txt:90</a></div></div>
<div class="ttc" id="aREADME-SSE_8txt_html_ad9151cca504a1763bb806798df6aefaf"><div class="ttname"><a href="README-SSE_8txt.html#ad9151cca504a1763bb806798df6aefaf">generate</a></div><div class="ttdeci">This might compile to this xmm1 xorps xmm0 movss xmm0 ret Now consider if the code caused xmm1 to get spilled This might produce this xmm1 movaps xmm0 movaps xmm1 movss xmm0 ret since the reload is only used by these we could fold it into the producing something like xmm1 movaps xmm0 ret saving two instructions The basic idea is that a reload from a spill if only one byte chunk is bring in zeros the one element instead of elements This can be used to simplify a variety of shuffle where the elements are fixed zeros This code generates ugly probably due to costs being off or&lt; 4 x float &gt; eax xmm0 pxor xmm1 movaps xmm2 xmm2 xmm0 movaps eax ret Would it be better to generate</div><div class="ttdef"><b>Definition:</b> <a href="README-SSE_8txt_source.html#l00301">README-SSE.txt:301</a></div></div>
<div class="ttc" id="alib_2Target_2WebAssembly_2README_8txt_html_a2ff42d8940320394fe7c9ebefd235621"><div class="ttname"><a href="lib_2Target_2WebAssembly_2README_8txt.html#a2ff42d8940320394fe7c9ebefd235621">constant</a></div><div class="ttdeci">we should consider alternate ways to model stack dependencies Lots of things could be done in WebAssemblyTargetTransformInfo cpp there are numerous optimization related hooks that can be overridden in WebAssemblyTargetLowering Instead of the OptimizeReturned which should consider preserving the returned attribute through to MachineInstrs and extending the MemIntrinsicResults pass to do this optimization on calls too That would also let the WebAssemblyPeephole pass clean up dead defs for such as it does for stores Consider implementing and or getMachineCombinerPatterns Find a clean way to fix the problem which leads to the Shrink Wrapping pass being run after the WebAssembly PEI pass When setting multiple variables to the same constant</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2WebAssembly_2README_8txt_source.html#l00091">README.txt:91</a></div></div>
<div class="ttc" id="aREADME-SSE_8txt_html_a50c8e2b4c2b4b443dd0149c808a1f812"><div class="ttname"><a href="README-SSE_8txt.html#a50c8e2b4c2b4b443dd0149c808a1f812">into</a></div><div class="ttdeci">This compiles into</div><div class="ttdef"><b>Definition:</b> <a href="README-SSE_8txt_source.html#l00215">README-SSE.txt:215</a></div></div>
<div class="ttc" id="anamespacellvm_html"><div class="ttname"><a href="namespacellvm.html">llvm</a></div><div class="ttdoc">This is an optimization pass for GlobalISel generic memory operations.</div><div class="ttdef"><b>Definition:</b> <a href="AddressRanges_8h_source.html#l00018">AddressRanges.h:18</a></div></div>
<div class="ttc" id="alib_2Target_2README_8txt_html_a7883a95866b9432ce4d83316aa287800"><div class="ttname"><a href="lib_2Target_2README_8txt.html#a7883a95866b9432ce4d83316aa287800">eax</a></div><div class="ttdeci">Add support for conditional and other related patterns Instead eax eax je LBB16_2 eax edi eax movl eax</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2README_8txt_source.html#l00145">README.txt:145</a></div></div>
<div class="ttc" id="aREADME-SSE_8txt_html_a9ac32a0342c0b841550ee0c2412a245e"><div class="ttname"><a href="README-SSE_8txt.html#a9ac32a0342c0b841550ee0c2412a245e">c2</a></div><div class="ttdeci">This might compile to this xmm1 xorps xmm0 movss xmm0 ret Now consider if the code caused xmm1 to get spilled This might produce this xmm1 movaps c2(%esp) ... xorps %xmm0</div></div>
<div class="ttc" id="aREADME-SSE_8txt_html_abb4ce3bc3096a12d4b93460bf78bcf95"><div class="ttname"><a href="README-SSE_8txt.html#abb4ce3bc3096a12d4b93460bf78bcf95">it</a></div><div class="ttdeci">into xmm2 addss xmm2 xmm1 xmm3 addss xmm3 movaps xmm0 unpcklps xmm0 ret seems silly when it could just be one addps Expand libm rounding functions main should enable SSE DAZ mode and other fast SSE modes Think about doing i64 math in SSE regs on x86 This testcase should have no SSE instructions in it</div><div class="ttdef"><b>Definition:</b> <a href="README-SSE_8txt_source.html#l00081">README-SSE.txt:81</a></div></div>
<div class="ttc" id="alib_2Target_2X86_2README_8txt_html_ac88244f8b6df536108ccf9289bfef611"><div class="ttname"><a href="lib_2Target_2X86_2README_8txt.html#ac88244f8b6df536108ccf9289bfef611">subl</a></div><div class="ttdeci">subl</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2X86_2README_8txt_source.html#l00297">README.txt:297</a></div></div>
<div class="ttc" id="anamespacellvm_1_1sys_1_1path_html_ad7c38f73fbf2f1a4ed9578621c6bfe8b"><div class="ttname"><a href="namespacellvm_1_1sys_1_1path.html#ad7c38f73fbf2f1a4ed9578621c6bfe8b">llvm::sys::path::extension</a></div><div class="ttdeci">StringRef extension(StringRef path, Style style=Style::native)</div><div class="ttdoc">Get extension.</div><div class="ttdef"><b>Definition:</b> <a href="Path_8cpp_source.html#l00590">Path.cpp:590</a></div></div>
<div class="ttc" id="aREADME-SSE_8txt_html_a78ffec8b6e5234ae6d90bf26f356f6ea"><div class="ttname"><a href="README-SSE_8txt.html#a78ffec8b6e5234ae6d90bf26f356f6ea">shrq</a></div><div class="ttdeci">&lt; float * &gt; store float float *tmp5 ret void Compiles rax shrq</div><div class="ttdef"><b>Definition:</b> <a href="README-SSE_8txt_source.html#l00803">README-SSE.txt:803</a></div></div>
<div class="ttc" id="alib_2Target_2README_8txt_html_a7bb3d0e0971fc7e33522732d133f421b"><div class="ttname"><a href="lib_2Target_2README_8txt.html#a7bb3d0e0971fc7e33522732d133f421b">cmpl</a></div><div class="ttdeci">Add support for conditional and other related patterns Instead eax cmpl</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2README_8txt_source.html#l00135">README.txt:135</a></div></div>
<div class="ttc" id="anamespacellvm_1_1AArch64PACKey_html_abf4394f452bde3f544999858d71e4b46"><div class="ttname"><a href="namespacellvm_1_1AArch64PACKey.html#abf4394f452bde3f544999858d71e4b46">llvm::AArch64PACKey::ID</a></div><div class="ttdeci">ID</div><div class="ttdef"><b>Definition:</b> <a href="AArch64BaseInfo_8h_source.html#l00790">AArch64BaseInfo.h:790</a></div></div>
<div class="ttc" id="alib_2Target_2X86_2README_8txt_html_ac86babb598befe37e9063b005ccda6a0"><div class="ttname"><a href="lib_2Target_2X86_2README_8txt.html#ac86babb598befe37e9063b005ccda6a0">zero</a></div><div class="ttdeci">We currently generate a but we really shouldn eax ecx xorl edx divl ecx eax divl ecx movl eax ret A similar code sequence works for division We currently compile i32 v2 eax eax jo LBB1_2 atomic and others It is also currently not done for read modify write instructions It is also current not done if the OF or CF flags are needed The shift operators have the complication that when the shift count is zero</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2X86_2README_8txt_source.html#l01277">README.txt:1277</a></div></div>
<div class="ttc" id="aAMDGPURewriteUndefForPHI_8cpp_html_a2e83cb1bc3f5e8986cbd14575755a134"><div class="ttname"><a href="AMDGPURewriteUndefForPHI_8cpp.html#a2e83cb1bc3f5e8986cbd14575755a134">PHI</a></div><div class="ttdeci">Rewrite undef for PHI</div><div class="ttdef"><b>Definition:</b> <a href="AMDGPURewriteUndefForPHI_8cpp_source.html#l00101">AMDGPURewriteUndefForPHI.cpp:101</a></div></div>
<div class="ttc" id="aREADME-SSE_8txt_html_a5e41ff9746df3f66d97591dbf1bf2927"><div class="ttname"><a href="README-SSE_8txt.html#a5e41ff9746df3f66d97591dbf1bf2927">xmm0</a></div><div class="ttdeci">Instead we get xmm0</div><div class="ttdef"><b>Definition:</b> <a href="README-SSE_8txt_source.html#l00033">README-SSE.txt:33</a></div></div>
<div class="ttc" id="aHexagonBitSimplify_8cpp_html_aa56209f617200c772b32fea2947178a7"><div class="ttname"><a href="HexagonBitSimplify_8cpp.html#aa56209f617200c772b32fea2947178a7">simplify</a></div><div class="ttdeci">hexagon bit simplify</div><div class="ttdef"><b>Definition:</b> <a href="HexagonBitSimplify_8cpp_source.html#l00289">HexagonBitSimplify.cpp:289</a></div></div>
<div class="ttc" id="aREADME-FPStack_8txt_html_a9209b9930d4d7750a6b8b38b3b4ddd6a"><div class="ttname"><a href="README-FPStack_8txt.html#a9209b9930d4d7750a6b8b38b3b4ddd6a">ceil</a></div><div class="ttdeci">We have fiadd patterns now but the followings have the same cost and complexity We need a way to specify the later is more profitable def def The FP stackifier should handle simple permutates to reduce number of shuffle e g ceil</div><div class="ttdef"><b>Definition:</b> <a href="README-FPStack_8txt_source.html#l00054">README-FPStack.txt:54</a></div></div>
<div class="ttc" id="anamespacellvm_1_1LegacyLegalizeActions_html_ad25716c86372dafbf624b34891685078a77dcc0b01e20bc9215e0ce22d81aca98"><div class="ttname"><a href="namespacellvm_1_1LegacyLegalizeActions.html#ad25716c86372dafbf624b34891685078a77dcc0b01e20bc9215e0ce22d81aca98">llvm::LegacyLegalizeActions::Custom</a></div><div class="ttdeci">@ Custom</div><div class="ttdoc">The target wants to do something special with this combination of operand and type.</div><div class="ttdef"><b>Definition:</b> <a href="LegacyLegalizerInfo_8h_source.html#l00067">LegacyLegalizerInfo.h:67</a></div></div>
<div class="ttc" id="alib_2Target_2WebAssembly_2README_8txt_html_acd5f99f9e89410e51fc09950e8dbc7dd"><div class="ttname"><a href="lib_2Target_2WebAssembly_2README_8txt.html#acd5f99f9e89410e51fc09950e8dbc7dd">see</a></div><div class="ttdeci">The object format emitted by the WebAssembly backed is documented see the home and packaging for producing WebAssembly applications that can run in browsers and other environments wasi sdk provides a more minimal C C SDK based on llvm and a libc based on for producing WebAssemmbly applictions that use the WASI ABI Rust provides WebAssembly support integrated into Cargo There are two main which provides a relatively minimal environment that has an emphasis on being native wasm32 unknown which uses Emscripten internally and provides standard C C filesystem GL and SDL bindings For more see</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2WebAssembly_2README_8txt_source.html#l00041">README.txt:41</a></div></div>
<div class="ttc" id="alib_2Target_2README_8txt_html_a1c73f662a0ce6b37b8203009d82287b1"><div class="ttname"><a href="lib_2Target_2README_8txt.html#a1c73f662a0ce6b37b8203009d82287b1">return</a></div><div class="ttdeci">return</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2README_8txt_source.html#l00242">README.txt:242</a></div></div>
<div class="ttc" id="aAMDGPUReplaceLDSUseWithPointer_8cpp_html_a9c3943160b95cc42ca8f6e04e6d4e9b6"><div class="ttname"><a href="AMDGPUReplaceLDSUseWithPointer_8cpp.html#a9c3943160b95cc42ca8f6e04e6d4e9b6">pointer</a></div><div class="ttdeci">Replace within non kernel function use of LDS with pointer</div><div class="ttdef"><b>Definition:</b> <a href="AMDGPUReplaceLDSUseWithPointer_8cpp_source.html#l00631">AMDGPUReplaceLDSUseWithPointer.cpp:631</a></div></div>
<div class="ttc" id="aREADME-SSE_8txt_html_a63d206a063eefcdf8c318ded97b65020"><div class="ttname"><a href="README-SSE_8txt.html#a63d206a063eefcdf8c318ded97b65020">P</a></div><div class="ttdeci">This currently compiles esp xmm0 movsd esp eax eax esp ret We should use not the dag combiner This is because dagcombine2 needs to be able to see through the X86ISD::Wrapper which DAGCombine can t really do The code for turning x load into a single vector load is target independent and should be moved to the dag combiner The code for turning x load into a vector load can only handle a direct load from a global or a direct load from the stack It should be generalized to handle any load from P</div><div class="ttdef"><b>Definition:</b> <a href="README-SSE_8txt_source.html#l00411">README-SSE.txt:411</a></div></div>
<div class="ttc" id="aSROA_8cpp_html_a6990f15b9f29df6e8497b3e53875ccab"><div class="ttname"><a href="SROA_8cpp.html#a6990f15b9f29df6e8497b3e53875ccab">sroa</a></div><div class="ttdeci">sroa</div><div class="ttdef"><b>Definition:</b> <a href="SROA_8cpp_source.html#l05126">SROA.cpp:5126</a></div></div>
<div class="ttc" id="aREADME-FPStack_8txt_html_a243272025b286ace1077ba4ec1d50d5f"><div class="ttname"><a href="README-FPStack_8txt.html#a243272025b286ace1077ba4ec1d50d5f">RFP</a></div><div class="ttdeci">We have fiadd patterns now but the followings have the same cost and complexity We need a way to specify the later is more profitable def RFP</div><div class="ttdef"><b>Definition:</b> <a href="README-FPStack_8txt_source.html#l00018">README-FPStack.txt:18</a></div></div>
<div class="ttc" id="anamespacellvm_html_ae6431492d4966df0bafe4680216f76b7"><div class="ttname"><a href="namespacellvm.html#ae6431492d4966df0bafe4680216f76b7">llvm::getTheX86_64Target</a></div><div class="ttdeci">Target &amp; getTheX86_64Target()</div><div class="ttdef"><b>Definition:</b> <a href="X86TargetInfo_8cpp_source.html#l00017">X86TargetInfo.cpp:17</a></div></div>
<div class="ttc" id="aclassllvm_1_1Triple_html_a547abd13f7a3c063aa72c8192a868154a0eefa3e53db25b90828e42c64b138648"><div class="ttname"><a href="classllvm_1_1Triple.html#a547abd13f7a3c063aa72c8192a868154a0eefa3e53db25b90828e42c64b138648">llvm::Triple::x86</a></div><div class="ttdeci">@ x86</div><div class="ttdef"><b>Definition:</b> <a href="Triple_8h_source.html#l00085">Triple.h:85</a></div></div>
<div class="ttc" id="alib_2Target_2ARM_2README_8txt_html_a06073fd284a21e842f0b772f63427475"><div class="ttname"><a href="lib_2Target_2ARM_2README_8txt.html#a06073fd284a21e842f0b772f63427475">stuff</a></div><div class="ttdeci">_bar mov r0 mov r1 fldd LCPI1_0 fmrrd d0 bl _foo fmdrr r5 fmsr r0 fsitod s2 faddd d0 fmrrd d0 ldmfd r0 mov r1 the copys to callee save registers and the fact they are only being used by the fmdrr instruction It would have been better had the fmdrr been scheduled before the call and place the result in a callee save DPR register The two mov ops would not have been necessary Calling convention related stuff</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2ARM_2README_8txt_source.html#l00181">README.txt:181</a></div></div>
<div class="ttc" id="aAArch64AdvSIMDScalarPass_8cpp_html_a1112b818386ec01ddfdf3a5d0024eb17"><div class="ttname"><a href="AArch64AdvSIMDScalarPass_8cpp.html#a1112b818386ec01ddfdf3a5d0024eb17">contains</a></div><div class="ttdeci">return AArch64::GPR64RegClass contains(Reg)</div></div>
<div class="ttc" id="aclassllvm_1_1Target_html"><div class="ttname"><a href="classllvm_1_1Target.html">llvm::Target</a></div><div class="ttdoc">Target - Wrapper for Target specific information.</div><div class="ttdef"><b>Definition:</b> <a href="TargetRegistry_8h_source.html#l00149">TargetRegistry.h:149</a></div></div>
<div class="ttc" id="aREADME-SSE_8txt_html_a698e4bd87a8adc0c042ae6b6e10ee6e1"><div class="ttname"><a href="README-SSE_8txt.html#a698e4bd87a8adc0c042ae6b6e10ee6e1">double</a></div><div class="ttdeci">into xmm2 addss xmm2 xmm1 xmm3 addss xmm3 movaps xmm0 unpcklps xmm0 ret seems silly when it could just be one addps Expand libm rounding functions main should enable SSE DAZ mode and other fast SSE modes Think about doing i64 math in SSE regs on x86 This testcase should have no SSE instructions in and only one load from a constant double</div><div class="ttdef"><b>Definition:</b> <a href="README-SSE_8txt_source.html#l00085">README-SSE.txt:85</a></div></div>
<div class="ttc" id="anamespacellvm_1_1lltok_html_af353621f14cb4b4b3af5ffaff84076b1a90341ec0034ef3ce30ba4c96acf92173"><div class="ttname"><a href="namespacellvm_1_1lltok.html#af353621f14cb4b4b3af5ffaff84076b1a90341ec0034ef3ce30ba4c96acf92173">llvm::lltok::bar</a></div><div class="ttdeci">@ bar</div><div class="ttdef"><b>Definition:</b> <a href="LLToken_8h_source.html#l00037">LLToken.h:37</a></div></div>
<div class="ttc" id="aREADME-SSE_8txt_html_a0cd314eb6ec4d97be014a36348d9dff0"><div class="ttname"><a href="README-SSE_8txt.html#a0cd314eb6ec4d97be014a36348d9dff0">uses</a></div><div class="ttdeci">This might compile to this xmm1 xorps xmm0 movss xmm0 ret Now consider if the code caused xmm1 to get spilled This might produce this xmm1 movaps xmm0 movaps xmm1 movss xmm0 ret since the reload is only used by these we could fold it into the uses</div><div class="ttdef"><b>Definition:</b> <a href="README-SSE_8txt_source.html#l00258">README-SSE.txt:258</a></div></div>
<div class="ttc" id="aREADME-SSE_8txt_html_acdf0d67d85b95f2fa5cf0e7aba10409e"><div class="ttname"><a href="README-SSE_8txt.html#acdf0d67d85b95f2fa5cf0e7aba10409e">add</a></div><div class="ttdeci">SSE has instructions for doing operations on complex we should pattern match them For this should turn into a horizontal add</div><div class="ttdef"><b>Definition:</b> <a href="README-SSE_8txt_source.html#l00025">README-SSE.txt:25</a></div></div>
<div class="ttc" id="aAMDGPUAliasAnalysis_8cpp_html_a63f565f28385a6f2c7a4756ff6f3fa16"><div class="ttname"><a href="AMDGPUAliasAnalysis_8cpp.html#a63f565f28385a6f2c7a4756ff6f3fa16">Wrapper</a></div><div class="ttdeci">amdgpu aa AMDGPU Address space based Alias Analysis Wrapper</div><div class="ttdef"><b>Definition:</b> <a href="AMDGPUAliasAnalysis_8cpp_source.html#l00031">AMDGPUAliasAnalysis.cpp:31</a></div></div>
<div class="ttc" id="aREADME__ALTIVEC_8txt_html_ab291f2e71eb00e9c419f00fec6d1f3c1"><div class="ttname"><a href="README__ALTIVEC_8txt.html#ab291f2e71eb00e9c419f00fec6d1f3c1">codegen</a></div><div class="ttdeci">Since we know that Vector is byte aligned and we know the element offset of we should change the load into a lve *x instead of doing a load store lve *x sequence Implement passing vectors by value into calls and receiving them as arguments GCC apparently tries to codegen</div><div class="ttdef"><b>Definition:</b> <a href="README__ALTIVEC_8txt_source.html#l00046">README_ALTIVEC.txt:46</a></div></div>
<div class="ttc" id="aREADME-SSE_8txt_html_a1fe4506cbb3b97e360ed5efa762027e9"><div class="ttname"><a href="README-SSE_8txt.html#a1fe4506cbb3b97e360ed5efa762027e9">addl</a></div><div class="ttdeci">This currently compiles esp xmm0 movsd esp eax eax addl</div><div class="ttdef"><b>Definition:</b> <a href="README-SSE_8txt_source.html#l00394">README-SSE.txt:394</a></div></div>
<div class="ttc" id="alib_2Target_2WebAssembly_2README_8txt_html_a22c839ac623ea2fed8f5ab84e2337c92"><div class="ttname"><a href="lib_2Target_2WebAssembly_2README_8txt.html#a22c839ac623ea2fed8f5ab84e2337c92">information</a></div><div class="ttdeci">The object format emitted by the WebAssembly backed is documented see the home and packaging for producing WebAssembly applications that can run in browsers and other environments wasi sdk provides a more minimal C C SDK based on llvm and a libc based on for producing WebAssemmbly applictions that use the WASI ABI Rust provides WebAssembly support integrated into Cargo There are two main which provides a relatively minimal environment that has an emphasis on being native wasm32 unknown which uses Emscripten internally and provides standard C C filesystem GL and SDL bindings For more information</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2WebAssembly_2README_8txt_source.html#l00029">README.txt:29</a></div></div>
<div class="ttc" id="aREADME-SSE_8txt_html_a1706b9d35a69e86ba5b6094f0b256ae0"><div class="ttname"><a href="README-SSE_8txt.html#a1706b9d35a69e86ba5b6094f0b256ae0">tmp5</a></div><div class="ttdeci">&lt; float &gt; tmp5</div><div class="ttdef"><b>Definition:</b> <a href="README-SSE_8txt_source.html#l00794">README-SSE.txt:794</a></div></div>
<div class="ttc" id="aREADME-X86-64_8txt_html_a303fa559ad59a69a615f94f4c2c6e7f5"><div class="ttname"><a href="README-X86-64_8txt.html#a303fa559ad59a69a615f94f4c2c6e7f5">CH</a></div><div class="ttdeci">AMD64 Optimization Manual has some nice information about optimizing integer multiplication by a constant How much of it applies to Intel s X86 implementation There are definite trade offs to xmm0 cvttss2siq rdx jb L3 subss xmm0 rax cvttss2siq rdx xorq rdx rax ret instead of xmm1 cvttss2siq rcx movaps xmm2 subss xmm2 cvttss2siq rax rdx xorq rax ucomiss xmm0 cmovb rax ret Seems like the jb branch has high likelihood of being taken It would have saved a few instructions It s not possible to reference CH</div><div class="ttdef"><b>Definition:</b> <a href="README-X86-64_8txt_source.html#l00044">README-X86-64.txt:44</a></div></div>
<div class="ttc" id="aREADME-SSE_8txt_html_a318ddad18e32d4f015eb27cfecd264a6"><div class="ttname"><a href="README-SSE_8txt.html#a318ddad18e32d4f015eb27cfecd264a6">like</a></div><div class="ttdeci">This might compile to this xmm1 xorps xmm0 movss xmm0 ret Now consider if the code caused xmm1 to get spilled This might produce this xmm1 movaps xmm0 movaps xmm1 movss xmm0 ret since the reload is only used by these we could fold it into the producing something like xmm1 movaps xmm0 ret saving two instructions The basic idea is that a reload from a spill if only one byte chunk is bring in zeros the one element instead of elements This can be used to simplify a variety of shuffle where the elements are fixed zeros This code generates ugly probably due to costs being off or&lt; 4 x float &gt; eax xmm0 pxor xmm1 movaps xmm2 xmm2 xmm0 movaps eax ret Would it be better to ecx xmm0 xor eax xmm0 xmm0 movaps ecx ret Some useful information in the Apple Altivec SSE Migration or Various SSE compare translations Add hooks to commute some CMPP operations Apply the same transformation that merged four float into a single bit load to loads from constant pool Floating point max min are commutable when enable unsafe fp path is specified We should turn int_x86_sse_max_ss and X86ISD::FMIN etc into other nodes which are selected to max min instructions that are marked commutable We should materialize vector constants like all ones and signbit with code like</div><div class="ttdef"><b>Definition:</b> <a href="README-SSE_8txt_source.html#l00340">README-SSE.txt:340</a></div></div>
<div class="ttc" id="aREADME-SSE_8txt_html_af51189abb330aa7476cf811a55f80577"><div class="ttname"><a href="README-SSE_8txt.html#af51189abb330aa7476cf811a55f80577">LCPI1_1</a></div><div class="ttdeci">into eax xorps xmm0 xmm0 eax xmm0 eax xmm0 ret esp eax movdqa xmm0 xmm0 esp const ret align it should be movdqa xmm0 xmm0 We should transform a shuffle of two vectors of constants into a single vector of constants insertelement of a constant into a vector of constants should also result in a vector of constants e g VecISelBug ll We compiled it to something globl _t xmm0 movhps xmm0 movss LCPI1_1</div><div class="ttdef"><b>Definition:</b> <a href="README-SSE_8txt_source.html#l00677">README-SSE.txt:677</a></div></div>
<div class="ttc" id="aREADME-SSE_8txt_html_a898366fd48d1272b01224c58b13050ec"><div class="ttname"><a href="README-SSE_8txt.html#a898366fd48d1272b01224c58b13050ec">i64</a></div><div class="ttdeci">&lt; float &gt; i64</div><div class="ttdef"><b>Definition:</b> <a href="README-SSE_8txt_source.html#l00794">README-SSE.txt:794</a></div></div>
<div class="ttc" id="anamespacellvm_1_1ISD_html_a22ea9cec080dd5f4f47ba234c2f59110ac3f8f8d8437c64b2e2e9f978e2707210"><div class="ttname"><a href="namespacellvm_1_1ISD.html#a22ea9cec080dd5f4f47ba234c2f59110ac3f8f8d8437c64b2e2e9f978e2707210">llvm::ISD::FP_TO_SINT</a></div><div class="ttdeci">@ FP_TO_SINT</div><div class="ttdoc">FP_TO_[US]INT - Convert a floating point value to a signed or unsigned integer.</div><div class="ttdef"><b>Definition:</b> <a href="ISDOpcodes_8h_source.html#l00819">ISDOpcodes.h:819</a></div></div>
<div class="ttc" id="alib_2Target_2X86_2README_8txt_html_a09c65fe6b8b0d95c3585bcfe405acad2"><div class="ttname"><a href="lib_2Target_2X86_2README_8txt.html#a09c65fe6b8b0d95c3585bcfe405acad2">however</a></div><div class="ttdeci">however</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2X86_2README_8txt_source.html#l00253">README.txt:253</a></div></div>
<div class="ttc" id="alib_2Target_2ARM_2README_8txt_html_a91f4469a9d29e354421494afd4ba466d"><div class="ttname"><a href="lib_2Target_2ARM_2README_8txt.html#a91f4469a9d29e354421494afd4ba466d">to</a></div><div class="ttdeci">Should compile to</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2ARM_2README_8txt_source.html#l00449">README.txt:449</a></div></div>
<div class="ttc" id="aclassllvm_1_1Triple_html_a547abd13f7a3c063aa72c8192a868154a13d8ce5e71051718a537277c6a594062"><div class="ttname"><a href="classllvm_1_1Triple.html#a547abd13f7a3c063aa72c8192a868154a13d8ce5e71051718a537277c6a594062">llvm::Triple::x86_64</a></div><div class="ttdeci">@ x86_64</div><div class="ttdef"><b>Definition:</b> <a href="Triple_8h_source.html#l00086">Triple.h:86</a></div></div>
<div class="ttc" id="anamespacellvm_1_1sys_1_1path_html_a214ec2f04ffd92636ed4bd2717607a1d"><div class="ttname"><a href="namespacellvm_1_1sys_1_1path.html#a214ec2f04ffd92636ed4bd2717607a1d">llvm::sys::path::end</a></div><div class="ttdeci">const_iterator end(StringRef path)</div><div class="ttdoc">Get end iterator over path.</div><div class="ttdef"><b>Definition:</b> <a href="Path_8cpp_source.html#l00235">Path.cpp:235</a></div></div>
<div class="ttc" id="alib_2Target_2README_8txt_html_add71801b35be0fc55386370f571068fb"><div class="ttname"><a href="lib_2Target_2README_8txt.html#add71801b35be0fc55386370f571068fb">i8</a></div><div class="ttdeci">Clang compiles this i8</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2README_8txt_source.html#l00504">README.txt:504</a></div></div>
<div class="ttc" id="aPPCMIPeephole_8cpp_html_a2fe1d201770f2584dbb2a26cd39bb556"><div class="ttname"><a href="PPCMIPeephole_8cpp.html#a2fe1d201770f2584dbb2a26cd39bb556">Optimization</a></div><div class="ttdeci">PowerPC MI Peephole Optimization</div><div class="ttdef"><b>Definition:</b> <a href="PPCMIPeephole_8cpp_source.html#l01790">PPCMIPeephole.cpp:1790</a></div></div>
<div class="ttc" id="aREADME-SSE_8txt_html_a45447e6ca59f8d10c9de84e3c5872b2e"><div class="ttname"><a href="README-SSE_8txt.html#a45447e6ca59f8d10c9de84e3c5872b2e">f32</a></div><div class="ttdeci">float f32(v4f32 A)</div><div class="ttdef"><b>Definition:</b> <a href="README-SSE_8txt_source.html#l00026">README-SSE.txt:26</a></div></div>
<div class="ttc" id="aREADME-SSE_8txt_html_a6c62ec3cb52530b4d5ac3891549b253e"><div class="ttname"><a href="README-SSE_8txt.html#a6c62ec3cb52530b4d5ac3891549b253e">know</a></div><div class="ttdeci">the custom lowered code happens to be but we shouldn t have to custom lower anything This is probably related to&lt; 2 x i64 &gt; ops being so bad LLVM currently generates stack realignment when it is not necessary needed The problem is that we need to know about stack alignment too before RA runs At that point we don t know</div><div class="ttdef"><b>Definition:</b> <a href="README-SSE_8txt_source.html#l00489">README-SSE.txt:489</a></div></div>
<div class="ttc" id="aREADME-SSE_8txt_html_a2f4e11261cf9f8fbb141fa1f8a58a7ae"><div class="ttname"><a href="README-SSE_8txt.html#a2f4e11261cf9f8fbb141fa1f8a58a7ae">pinsrb</a></div><div class="ttdeci">into eax xorps xmm0 xmm0 eax xmm0 eax xmm0 ret esp eax movdqa xmm0 xmm0 esp const ret align it should be movdqa xmm0 pinsrb</div><div class="ttdef"><b>Definition:</b> <a href="README-SSE_8txt_source.html#l00650">README-SSE.txt:650</a></div></div>
<div class="ttc" id="aHexagonVectorLoopCarriedReuse_8cpp_html_a3fd4a7024284a5905bb9ffcc1b23761c"><div class="ttname"><a href="HexagonVectorLoopCarriedReuse_8cpp.html#a3fd4a7024284a5905bb9ffcc1b23761c">vectors</a></div><div class="ttdeci">hexagon Hexagon specific predictive commoning for HVX vectors</div><div class="ttdef"><b>Definition:</b> <a href="HexagonVectorLoopCarriedReuse_8cpp_source.html#l00221">HexagonVectorLoopCarriedReuse.cpp:221</a></div></div>
<div class="ttc" id="alib_2Target_2X86_2README_8txt_html_aaf6381f136d6cb9f13adbd90b1781923"><div class="ttname"><a href="lib_2Target_2X86_2README_8txt.html#aaf6381f136d6cb9f13adbd90b1781923">ret</a></div><div class="ttdeci">to esp esp setne al movzbw ax esp setg cl movzbw cx cmove cx cl jne LBB1_2 esp ret(also really horrible code on ppc). This is due to the expand code for 64-bit compares. GCC produces multiple branches</div></div>
<div class="ttc" id="alib_2Target_2ARM_2README_8txt_html_af84fbbd129a1fbd3981dfbe6f607ddf4"><div class="ttname"><a href="lib_2Target_2ARM_2README_8txt.html#af84fbbd129a1fbd3981dfbe6f607ddf4">at</a></div><div class="ttdeci">compiles ldr LCPI1_0 ldr ldr mov lsr tst moveq r1 ldr LCPI1_1 and r0 bx lr It would be better to do something like to fold the shift into the conditional ldr LCPI1_0 ldr ldr tst movne lsr ldr LCPI1_1 and r0 bx lr it saves an instruction and a register It might be profitable to cse MOVi16 if there are lots of bit immediates with the same bottom half Robert Muth started working on an alternate jump table implementation that does not put the tables in line in the text This is more like the llvm default jump table implementation This might be useful sometime Several revisions of patches are on the mailing beginning at</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2ARM_2README_8txt_source.html#l00582">README.txt:582</a></div></div>
<div class="ttc" id="alib_2Target_2ARM_2README_8txt_html_a9ee2c8fe0cc4c9f419a7ba77631dbb69"><div class="ttname"><a href="lib_2Target_2ARM_2README_8txt.html#a9ee2c8fe0cc4c9f419a7ba77631dbb69">worse</a></div><div class="ttdeci">add sub stmia L5 ldr r0 bl L_printf $stub Instead of a and a wouldn t it be better to do three moves *Return an aggregate type is even worse</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2ARM_2README_8txt_source.html#l00210">README.txt:210</a></div></div>
<div class="ttc" id="aREADME-SSE_8txt_html_a075c1fd5f47a8f3c490ae1e722bee10e"><div class="ttname"><a href="README-SSE_8txt.html#a075c1fd5f47a8f3c490ae1e722bee10e">movmskp</a></div><div class="ttdeci">This currently compiles esp xmm0 movsd esp eax eax esp ret We should use movmskp</div><div class="ttdef"><b>Definition:</b> <a href="README-SSE_8txt_source.html#l00397">README-SSE.txt:397</a></div></div>
<div class="ttc" id="anamespacellvm_html_ab4d4bc901fedd8857f647dcc2c0d71de"><div class="ttname"><a href="namespacellvm.html#ab4d4bc901fedd8857f647dcc2c0d71de">llvm::max</a></div><div class="ttdeci">Expected&lt; ExpressionValue &gt; max(const ExpressionValue &amp;Lhs, const ExpressionValue &amp;Rhs)</div><div class="ttdef"><b>Definition:</b> <a href="FileCheck_8cpp_source.html#l00337">FileCheck.cpp:337</a></div></div>
<div class="ttc" id="aREADME-SSE_8txt_html_a649fac3684b17e0f7cc99f553235c433"><div class="ttname"><a href="README-SSE_8txt.html#a649fac3684b17e0f7cc99f553235c433">movl</a></div><div class="ttdeci">into eax xorps xmm0 xmm0 eax xmm0 movl</div><div class="ttdef"><b>Definition:</b> <a href="README-SSE_8txt_source.html#l00624">README-SSE.txt:624</a></div></div>
<div class="ttc" id="alib_2Target_2WebAssembly_2README_8txt_html_a3828c493031579f0c68587b19619f7e2"><div class="ttname"><a href="lib_2Target_2WebAssembly_2README_8txt.html#a3828c493031579f0c68587b19619f7e2">that</a></div><div class="ttdeci">we should consider alternate ways to model stack dependencies Lots of things could be done in WebAssemblyTargetTransformInfo cpp there are numerous optimization related hooks that can be overridden in WebAssemblyTargetLowering Instead of the OptimizeReturned which should consider preserving the returned attribute through to MachineInstrs and extending the MemIntrinsicResults pass to do this optimization on calls too That would also let the WebAssemblyPeephole pass clean up dead defs for such as it does for stores Consider implementing and or getMachineCombinerPatterns Find a clean way to fix the problem which leads to the Shrink Wrapping pass being run after the WebAssembly PEI pass When setting multiple variables to the same we currently get code like const It could be done with a smaller encoding like local tee $pop5 local $pop6 WebAssembly registers are implicitly initialized to zero Explicit zeroing is therefore often redundant and could be optimized away Small indices may use smaller encodings than large indices WebAssemblyRegColoring and or WebAssemblyRegRenumbering should sort registers according to their usage frequency to maximize the usage of smaller encodings Many cases of irreducible control flow could be transformed more optimally than via the transform in WebAssemblyFixIrreducibleControlFlow cpp It may also be worthwhile to do transforms before register particularly when duplicating to allow register coloring to be aware of the duplication WebAssemblyRegStackify could use AliasAnalysis to reorder loads and stores more aggressively WebAssemblyRegStackify is currently a greedy algorithm This means that</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2WebAssembly_2README_8txt_source.html#l00130">README.txt:130</a></div></div>
<div class="ttc" id="alib_2Target_2X86_2README_8txt_html_a82bd4f4b721c049035c0d86cc261eadd"><div class="ttname"><a href="lib_2Target_2X86_2README_8txt.html#a82bd4f4b721c049035c0d86cc261eadd">tmp</a></div><div class="ttdeci">alloca&lt; 16 x float &gt;, align 16 %tmp2=alloca&lt; 16 x float &gt;, align 16 store&lt; 16 x float &gt; %A,&lt; 16 x float &gt; *%tmp %s=bitcast&lt; 16 x float &gt; *%tmp to i8 *%s2=bitcast&lt; 16 x float &gt; *%tmp2 to i8 *call void @llvm.memcpy.i64(i8 *%s, i8 *%s2, i64 64, i32 16) %R=load&lt; 16 x float &gt; *%tmp2 ret&lt; 16 x float &gt; %R } declare void @llvm.memcpy.i64(i8 *nocapture, i8 *nocapture, i64, i32) nounwind which compiles to:_foo:subl $140, %esp movaps %xmm3, 112(%esp) movaps %xmm2, 96(%esp) movaps %xmm1, 80(%esp) movaps %xmm0, 64(%esp) movl 60(%esp), %eax movl %eax, 124(%esp) movl 56(%esp), %eax movl %eax, 120(%esp) movl 52(%esp), %eax&lt; many many more 32-bit copies &gt; movaps(%esp), %xmm0 movaps 16(%esp), %xmm1 movaps 32(%esp), %xmm2 movaps 48(%esp), %xmm3 addl $140, %esp ret On Nehalem, it may even be cheaper to just use movups when unaligned than to fall back to lower-granularity chunks. Implement processor-specific optimizations for parity with GCC on these processors. GCC does two optimizations:1. ix86_pad_returns inserts a noop before ret instructions if immediately preceded by a conditional branch or is the target of a jump. 2. ix86_avoid_jump_misspredicts inserts noops in cases where a 16-byte block of code contains more than 3 branches. The first one is done for all AMDs, Core2, and &quot;Generic&quot; The second one is done for:Atom, Pentium Pro, all AMDs, Pentium 4, Nocona, Core 2, and &quot;Generic&quot; Testcase:int x(int a) { return(a &amp;0xf0)&gt; &gt;4 tmp</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2X86_2README_8txt_source.html#l01347">README.txt:1347</a></div></div>
<div class="ttc" id="alib_2Target_2README_8txt_html_a7d7452607c1ef42f1fccbb83ac7cba6d"><div class="ttname"><a href="lib_2Target_2README_8txt.html#a7d7452607c1ef42f1fccbb83ac7cba6d">handle</a></div><div class="ttdeci">then ret i32 result Tail recursion elimination should handle</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2README_8txt_source.html#l00355">README.txt:355</a></div></div>
<div class="ttc" id="alib_2Target_2X86_2README_8txt_html_aef44c1ad24071fc390303ba8ebf04af3"><div class="ttname"><a href="lib_2Target_2X86_2README_8txt.html#aef44c1ad24071fc390303ba8ebf04af3">generates</a></div><div class="ttdeci">gets compiled into this on rsp movaps rsp movaps rsp movaps rsp movaps rsp movaps rsp movaps rsp movaps rsp movaps rsp movq rsp movq rsp movq rsp movq rsp movq rsp rax movq rsp rax movq rsp rsp rsp eax eax jbe LBB1_3 rcx rax movq rsp eax rsp ret ecx eax rcx movl rsp jmp LBB1_2 gcc generates</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2X86_2README_8txt_source.html#l01153">README.txt:1153</a></div></div>
<div class="ttc" id="alib_2Target_2X86_2README_8txt_html_a0aa3d83b100058ffd7399364d6b76b5d"><div class="ttname"><a href="lib_2Target_2X86_2README_8txt.html#a0aa3d83b100058ffd7399364d6b76b5d">and</a></div><div class="ttdeci">We currently generate a but we really shouldn eax ecx xorl edx divl ecx eax divl ecx movl eax ret A similar code sequence works for division We currently compile i32 v2 eax eax jo LBB1_2 and</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2X86_2README_8txt_source.html#l01271">README.txt:1271</a></div></div>
<div class="ttc" id="alib_2Target_2README_8txt_html_a2352e45658fc7292aa209a94baa095e9"><div class="ttname"><a href="lib_2Target_2README_8txt.html#a2352e45658fc7292aa209a94baa095e9">x86</a></div><div class="ttdeci">Note that only the low bits of effective_addr2 are used On bit we don t eliminate the computation of the top half of effective_addr2 because we don t have whole function selection dags On x86</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2README_8txt_source.html#l00318">README.txt:318</a></div></div>
<div class="ttc" id="aREADME-FPStack_8txt_html_af9c3a44d701cfcdb6ebc65fbccabf8c0"><div class="ttname"><a href="README-FPStack_8txt.html#af9c3a44d701cfcdb6ebc65fbccabf8c0">FpADD32m</a></div><div class="ttdeci">We have fiadd patterns now but the followings have the same cost and complexity We need a way to specify the later is more profitable def FpADD32m</div><div class="ttdef"><b>Definition:</b> <a href="README-FPStack_8txt_source.html#l00018">README-FPStack.txt:18</a></div></div>
<div class="ttc" id="alib_2Target_2X86_2README_8txt_html_af1fa630865127459286e11e4fab4319d"><div class="ttname"><a href="lib_2Target_2X86_2README_8txt.html#af1fa630865127459286e11e4fab4319d">movzwl</a></div><div class="ttdeci">The following code is currently eax eax ecx jb LBB1_2 eax movzbl eax ret eax ret We could change the eax into movzwl(%esp)</div></div>
<div class="ttc" id="anamespacellvm_1_1LegalityPredicates_html_a6fef38ab5d0c9c582fe6cae7d8badf5f"><div class="ttname"><a href="namespacellvm_1_1LegalityPredicates.html#a6fef38ab5d0c9c582fe6cae7d8badf5f">llvm::LegalityPredicates::any</a></div><div class="ttdeci">Predicate any(Predicate P0, Predicate P1)</div><div class="ttdoc">True iff P0 or P1 are true.</div><div class="ttdef"><b>Definition:</b> <a href="LegalizerInfo_8h_source.html#l00241">LegalizerInfo.h:241</a></div></div>
<div class="ttc" id="aREADME-SSE_8txt_html_ac8e9300bcfb80d6e6abf5543bdcf12a6"><div class="ttname"><a href="README-SSE_8txt.html#ac8e9300bcfb80d6e6abf5543bdcf12a6">store</a></div><div class="ttdeci">This currently compiles esp xmm0 movsd esp eax eax esp ret We should use not the dag combiner This is because dagcombine2 needs to be able to see through the X86ISD::Wrapper which DAGCombine can t really do The code for turning x load into a single vector load is target independent and should be moved to the dag combiner The code for turning x load into a vector load can only handle a direct load from a global or a direct load from the stack It should be generalized to handle any load from where P can be anything The alignment inference code cannot handle loads from globals in static non mode because it doesn t look through the extra dyld stub load If you try vec_align ll without relocation you ll see what I mean We should lower store(fneg(load p), q) into an integer load+xor+store</div></div>
<div class="ttc" id="alib_2Target_2README_8txt_html_a0cd8d1bc9a07cfa4b9ea5dd409d753de"><div class="ttname"><a href="lib_2Target_2README_8txt.html#a0cd8d1bc9a07cfa4b9ea5dd409d753de">http</a></div><div class="ttdeci">Clang compiles this i1 i64 store i64 i64 store i64 i64 store i64 i64 store i64 align Which gets codegen d xmm0 movaps rbp movaps rbp movaps rbp movaps rbp rbp rbp rbp rbp It would be better to have movq s of instead of the movaps s http</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2README_8txt_source.html#l00532">README.txt:532</a></div></div>
<div class="ttc" id="alib_2Target_2PowerPC_2README_8txt_html_a7dac26c0290a417e6a6e0ed8ea152a75"><div class="ttname"><a href="lib_2Target_2PowerPC_2README_8txt.html#a7dac26c0290a417e6a6e0ed8ea152a75">like</a></div><div class="ttdeci">Should compile to something like</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2PowerPC_2README_8txt_source.html#l00019">README.txt:19</a></div></div>
<div class="ttc" id="anamespacellvm_1_1X86ISD_html_a9441a4f94d36d0f7c0c34aca42e3f76aa0f4605a7e5bb3cda3e1e3f6b05c08c46"><div class="ttname"><a href="namespacellvm_1_1X86ISD.html#a9441a4f94d36d0f7c0c34aca42e3f76aa0f4605a7e5bb3cda3e1e3f6b05c08c46">llvm::X86ISD::CMPP</a></div><div class="ttdeci">@ CMPP</div><div class="ttdef"><b>Definition:</b> <a href="X86ISelLowering_8h_source.html#l00375">X86ISelLowering.h:375</a></div></div>
<div class="ttc" id="alib_2Target_2WebAssembly_2README_8txt_html_aa10ed15e46ac1ab65d947f018f9bad45"><div class="ttname"><a href="lib_2Target_2WebAssembly_2README_8txt.html#aa10ed15e46ac1ab65d947f018f9bad45">extended</a></div><div class="ttdeci">we should consider alternate ways to model stack dependencies Lots of things could be done in WebAssemblyTargetTransformInfo cpp there are numerous optimization related hooks that can be overridden in WebAssemblyTargetLowering Instead of the OptimizeReturned which should consider preserving the returned attribute through to MachineInstrs and extending the MemIntrinsicResults pass to do this optimization on calls too That would also let the WebAssemblyPeephole pass clean up dead defs for such as it does for stores Consider implementing and or getMachineCombinerPatterns Find a clean way to fix the problem which leads to the Shrink Wrapping pass being run after the WebAssembly PEI pass When setting multiple variables to the same we currently get code like const It could be done with a smaller encoding like local tee $pop5 local $pop6 WebAssembly registers are implicitly initialized to zero Explicit zeroing is therefore often redundant and could be optimized away Small indices may use smaller encodings than large indices WebAssemblyRegColoring and or WebAssemblyRegRenumbering should sort registers according to their usage frequency to maximize the usage of smaller encodings Many cases of irreducible control flow could be transformed more optimally than via the transform in WebAssemblyFixIrreducibleControlFlow cpp It may also be worthwhile to do transforms before register particularly when duplicating to allow register coloring to be aware of the duplication WebAssemblyRegStackify could use AliasAnalysis to reorder loads and stores more aggressively WebAssemblyRegStackify is currently a greedy algorithm This means for a binary however wasm doesn t actually require this WebAssemblyRegStackify could be extended</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2WebAssembly_2README_8txt_source.html#l00149">README.txt:149</a></div></div>
<div class="ttc" id="alib_2Target_2X86_2README_8txt_html_a7ef4d3003047043a3de118adbb0570fd"><div class="ttname"><a href="lib_2Target_2X86_2README_8txt.html#a7ef4d3003047043a3de118adbb0570fd">a</a></div><div class="ttdeci">=0.0 ? 0.0 :(a &gt; 0.0 ? 1.0 :-1.0) a</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2X86_2README_8txt_source.html#l00489">README.txt:489</a></div></div>
<div class="ttc" id="aREADME-FPStack_8txt_html_ac25bbfa16d28ab1f83da03668addad0a"><div class="ttname"><a href="README-FPStack_8txt.html#ac25bbfa16d28ab1f83da03668addad0a">floor</a></div><div class="ttdeci">We have fiadd patterns now but the followings have the same cost and complexity We need a way to specify the later is more profitable def def The FP stackifier should handle simple permutates to reduce number of shuffle e g floor</div><div class="ttdef"><b>Definition:</b> <a href="README-FPStack_8txt_source.html#l00054">README-FPStack.txt:54</a></div></div>
<div class="ttc" id="aREADME-FPStack_8txt_html_a6e593b994b8f0d25ef0863dd42bba406"><div class="ttname"><a href="README-FPStack_8txt.html#a6e593b994b8f0d25ef0863dd42bba406">i32mem</a></div><div class="ttdeci">We have fiadd patterns now but the followings have the same cost and complexity We need a way to specify the later is more profitable def def i32mem</div><div class="ttdef"><b>Definition:</b> <a href="README-FPStack_8txt_source.html#l00023">README-FPStack.txt:23</a></div></div>
<div class="ttc" id="alib_2Target_2ARM_2README_8txt_html_a505ab8ccf28e119d535a848c546abc77"><div class="ttname"><a href="lib_2Target_2ARM_2README_8txt.html#a505ab8ccf28e119d535a848c546abc77">way</a></div><div class="ttdeci">should just be implemented with a CLZ instruction Since there are other e that share this it would be best to implement this in a target independent way</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2ARM_2README_8txt_source.html#l00720">README.txt:720</a></div></div>
<div class="ttc" id="aREADME__P9_8txt_html_ae070adaf1b4bf0e7c12fcae2b9c5ae67"><div class="ttname"><a href="README__P9_8txt.html#ae070adaf1b4bf0e7c12fcae2b9c5ae67">result</a></div><div class="ttdeci">It looks like we only need to define PPCfmarto for these because according to these instructions perform RTO on fma s result</div><div class="ttdef"><b>Definition:</b> <a href="README__P9_8txt_source.html#l00256">README_P9.txt:256</a></div></div>
<div class="ttc" id="aREADME-SSE_8txt_html_ac834ac689f351744bc63babed6915f02"><div class="ttname"><a href="README-SSE_8txt.html#ac834ac689f351744bc63babed6915f02">i32</a></div><div class="ttdeci">&lt; float &gt; i32</div><div class="ttdef"><b>Definition:</b> <a href="README-SSE_8txt_source.html#l00794">README-SSE.txt:794</a></div></div>
<div class="ttc" id="alib_2Target_2X86_2README_8txt_html_ab3481134de37003fa3bc826d229933d8"><div class="ttname"><a href="lib_2Target_2X86_2README_8txt.html#ab3481134de37003fa3bc826d229933d8">imull</a></div><div class="ttdeci">We currently emits imull</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2X86_2README_8txt_source.html#l00235">README.txt:235</a></div></div>
<div class="ttc" id="anamespacellvm_html_abe2c24a8dc2fb979e8e54e15f088169ca5fc53fc8197865c63285f74b1e147013"><div class="ttname"><a href="namespacellvm.html#abe2c24a8dc2fb979e8e54e15f088169ca5fc53fc8197865c63285f74b1e147013">llvm::VFISAKind::SSE</a></div><div class="ttdeci">@ SSE</div></div>
<div class="ttc" id="aREADME-SSE_8txt_html_a11ca92463dc5dfc09bbe2ba2f3ea0c96"><div class="ttname"><a href="README-SSE_8txt.html#a11ca92463dc5dfc09bbe2ba2f3ea0c96">x3</a></div><div class="ttdeci">In x86 we generate this spiffy xmm0 xmm0 ret in x86 we generate this which could be xmm1 movss xmm1 xmm0 ret In sse4 we could use insertps to make both better Here s another testcase that could use x3</div><div class="ttdef"><b>Definition:</b> <a href="README-SSE_8txt_source.html#l00547">README-SSE.txt:547</a></div></div>
<div class="ttc" id="alib_2Target_2X86_2README_8txt_html_ac9423a63151469d95755528cceb322fb"><div class="ttname"><a href="lib_2Target_2X86_2README_8txt.html#ac9423a63151469d95755528cceb322fb">bb</a></div><div class="ttdeci">&lt; i1 &gt; br i1 label label bb bb</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2X86_2README_8txt_source.html#l00978">README.txt:978</a></div></div>
<div class="ttc" id="aAArch64MCAsmInfo_8cpp_html_ad9974102ac4ab550bae0600eca728899afa7ceceb64a6890f8421f695dc71a399"><div class="ttname"><a href="AArch64MCAsmInfo_8cpp.html#ad9974102ac4ab550bae0600eca728899afa7ceceb64a6890f8421f695dc71a399">Apple</a></div><div class="ttdeci">@ Apple</div><div class="ttdef"><b>Definition:</b> <a href="AArch64MCAsmInfo_8cpp_source.html#l00024">AArch64MCAsmInfo.cpp:24</a></div></div>
<div class="ttc" id="aREADME-FPStack_8txt_html_a18f5ebac457be2d6e279cdd3842a4024"><div class="ttname"><a href="README-FPStack_8txt.html#a18f5ebac457be2d6e279cdd3842a4024">turning</a></div><div class="ttdeci">We have fiadd patterns now but the followings have the same cost and complexity We need a way to specify the later is more profitable def def The FP stackifier should handle simple permutates to reduce number of shuffle e g turning</div><div class="ttdef"><b>Definition:</b> <a href="README-FPStack_8txt_source.html#l00054">README-FPStack.txt:54</a></div></div>
<div class="ttc" id="aREADME-X86-64_8txt_html_a370ec291336254d00f17778ad8dc2bbf"><div class="ttname"><a href="README-X86-64_8txt.html#a370ec291336254d00f17778ad8dc2bbf">rcx</a></div><div class="ttdeci">AMD64 Optimization Manual has some nice information about optimizing integer multiplication by a constant How much of it applies to Intel s X86 implementation There are definite trade offs to xmm0 cvttss2siq rdx jb L3 subss xmm0 rax cvttss2siq rdx xorq rdx rax ret instead of xmm1 cvttss2siq rcx movaps xmm2 subss xmm2 cvttss2siq rax rdx xorq rax ucomiss xmm0 cmovb rcx</div><div class="ttdef"><b>Definition:</b> <a href="README-X86-64_8txt_source.html#l00036">README-X86-64.txt:36</a></div></div>
<div class="ttc" id="aREADME-SSE_8txt_html_a9fb6cbbc77fb02ab3a51b0660bd09909"><div class="ttname"><a href="README-SSE_8txt.html#a9fb6cbbc77fb02ab3a51b0660bd09909">select</a></div><div class="ttdeci">into xmm2 addss xmm2 xmm1 xmm3 addss xmm3 movaps xmm0 unpcklps xmm0 ret seems silly when it could just be one addps Expand libm rounding functions main should enable SSE DAZ mode and other fast SSE modes Think about doing i64 math in SSE regs on x86 This testcase should have no SSE instructions in and only one load from a constant double ret double C the select is being which prevents the dag combiner from turning select(load CPI1)</div></div>
<div class="ttc" id="anamespacellvm_1_1PatternMatch_html_a25d956d9e0beadd47ce4bc255dfa811d"><div class="ttname"><a href="namespacellvm_1_1PatternMatch.html#a25d956d9e0beadd47ce4bc255dfa811d">llvm::PatternMatch::match</a></div><div class="ttdeci">bool match(Val *V, const Pattern &amp;P)</div><div class="ttdef"><b>Definition:</b> <a href="PatternMatch_8h_source.html#l00049">PatternMatch.h:49</a></div></div>
<div class="ttc" id="aREADME-SSE_8txt_html_a67354dc6813eefc414e59763f37675e9"><div class="ttname"><a href="README-SSE_8txt.html#a67354dc6813eefc414e59763f37675e9">insertps</a></div><div class="ttdeci">In x86 we generate this spiffy xmm0 xmm0 ret in x86 we generate this which could be xmm1 movss xmm1 xmm0 ret In sse4 we could use insertps to make both better Here s another testcase that could use insertps[mem]</div><div class="ttdef"><b>Definition:</b> <a href="README-SSE_8txt_source.html#l00547">README-SSE.txt:547</a></div></div>
<div class="ttc" id="aREADME-SSE_8txt_html_a83a1af45bddd6bc1acd74e39bb6f3010"><div class="ttname"><a href="README-SSE_8txt.html#a83a1af45bddd6bc1acd74e39bb6f3010">code</a></div><div class="ttdeci">This might compile to this code</div><div class="ttdef"><b>Definition:</b> <a href="README-SSE_8txt_source.html#l00240">README-SSE.txt:240</a></div></div>
<div class="ttc" id="anamespacellvm_1_1ISD_html_a22ea9cec080dd5f4f47ba234c2f59110a35c1cf0dd553444732dba8e8b9be0f6b"><div class="ttname"><a href="namespacellvm_1_1ISD.html#a22ea9cec080dd5f4f47ba234c2f59110a35c1cf0dd553444732dba8e8b9be0f6b">llvm::ISD::ABS</a></div><div class="ttdeci">@ ABS</div><div class="ttdoc">ABS - Determine the unsigned absolute value of a signed integer value of the same bitwidth.</div><div class="ttdef"><b>Definition:</b> <a href="ISDOpcodes_8h_source.html#l00674">ISDOpcodes.h:674</a></div></div>
<div class="ttc" id="alib_2CodeGen_2README_8txt_html_a13f0a2e1f455ac47147b41701e609e17"><div class="ttname"><a href="lib_2CodeGen_2README_8txt.html#a13f0a2e1f455ac47147b41701e609e17">them</a></div><div class="ttdeci">Common register allocation spilling lr str ldr sxth r3 ldr mla r4 can lr mov lr str ldr sxth r3 mla r4 and then merge mul and lr str ldr sxth r3 mla r4 It also increase the likelihood the store may become dead bb27 Successors according to LLVM ID Predecessors according to mbb&lt; bb27, 0x8b0a7c0 &gt; Note ADDri is not a two address instruction its result reg1037 is an operand of the PHI node in bb76 and its operand reg1039 is the result of the PHI node We should treat it as a two address code and make sure the ADDri is scheduled after any node that reads reg1039 Use info(i.e. register scavenger) to assign it a free register to allow reuse the collector could move the objects and invalidate the derived pointer This is bad enough in the first but safe points can crop up unpredictably **array_addr i32 n y store obj obj **nth_el If the i64 division is lowered to a then a safe point array and nth_el no longer point into the correct object The fix for this is to copy address calculations so that dependent pointers are never live across safe point boundaries But the loads cannot be copied like this if there was an intervening so may be hard to get right Only a concurrent mutator can trigger a collection at the libcall safe point So single threaded programs do not have this even with a copying collector LLVM optimizations would probably undo a front end s careful work The ocaml frametable structure supports liveness information It would be good to support it The FIXME in ComputeCommonTailLength in BranchFolding cpp needs to be revisited The check is there to work around a misuse of directives in assembly It would be good to detect collector target compatibility instead of silently doing the wrong thing It would be really nice to be able to write patterns in td files for which would eliminate a bunch of predicates on them(e.g. no side effects). Once this is in place</div></div>
<div class="ttc" id="ainclude_2llvm_2Demangle_2README_8txt_html_a9d56f6c541a0ab888755f9bc198b8eca"><div class="ttname"><a href="include_2llvm_2Demangle_2README_8txt.html#a9d56f6c541a0ab888755f9bc198b8eca">f</a></div><div class="ttdeci">Itanium Name Demangler i e convert the string _Z1fv into f()&quot;. You can also use the CRTP base ManglingParser to perform some simple analysis on the mangled name</div></div>
<div class="ttc" id="aREADME-SSE_8txt_html_ae7fc2fb0e2d536219c1193f1a178e7db"><div class="ttname"><a href="README-SSE_8txt.html#ae7fc2fb0e2d536219c1193f1a178e7db">P2</a></div><div class="ttdeci">This might compile to this xmm1 xorps xmm0 movss xmm0 ret Now consider if the code caused xmm1 to get spilled This might produce this xmm1 movaps xmm0 movaps xmm1 movss xmm0 ret since the reload is only used by these we could fold it into the producing something like xmm1 movaps xmm0 ret saving two instructions The basic idea is that a reload from a spill if only one byte chunk is bring in zeros the one element instead of elements This can be used to simplify a variety of shuffle where the elements are fixed zeros This code generates ugly probably due to costs being off or&lt; 4 x float &gt; * P2</div><div class="ttdef"><b>Definition:</b> <a href="README-SSE_8txt_source.html#l00278">README-SSE.txt:278</a></div></div>
<div class="ttc" id="aREADME__ALTIVEC_8txt_html_a9aacd9146afe44bf656cd664e2a88c8c"><div class="ttname"><a href="README__ALTIVEC_8txt.html#a9aacd9146afe44bf656cd664e2a88c8c">C</a></div><div class="ttdeci">(vector float) vec_cmpeq(*A, *B) C</div><div class="ttdef"><b>Definition:</b> <a href="README__ALTIVEC_8txt_source.html#l00086">README_ALTIVEC.txt:86</a></div></div>
<div class="ttc" id="aREADME-SSE_8txt_html_abd0f7b6ec4cd314d4944100848747be5"><div class="ttname"><a href="README-SSE_8txt.html#abd0f7b6ec4cd314d4944100848747be5">andnot</a></div><div class="ttdeci">This might compile to this xmm1 xorps xmm0 movss xmm0 ret Now consider if the code caused xmm1 to get spilled This might produce this xmm1 movaps xmm0 movaps xmm1 movss xmm0 ret since the reload is only used by these we could fold it into the producing something like xmm1 movaps xmm0 ret saving two instructions The basic idea is that a reload from a spill if only one byte chunk is bring in zeros the one element instead of elements This can be used to simplify a variety of shuffle where the elements are fixed zeros This code generates ugly probably due to costs being off or&lt; 4 x float &gt; eax xmm0 pxor xmm1 movaps xmm2 xmm2 xmm0 movaps eax ret Would it be better to ecx xmm0 xor eax xmm0 xmm0 movaps ecx ret Some useful information in the Apple Altivec SSE Migration andnot</div><div class="ttdef"><b>Definition:</b> <a href="README-SSE_8txt_source.html#l00318">README-SSE.txt:318</a></div></div>
<div class="ttc" id="alib_2Target_2README_8txt_html_a3217063f680fa8e35dea3c59b6e52b18"><div class="ttname"><a href="lib_2Target_2README_8txt.html#a3217063f680fa8e35dea3c59b6e52b18">int</a></div><div class="ttdeci">Clang compiles this i1 i64 store i64 i64 store i64 i64 store i64 i64 store i64 align Which gets codegen d xmm0 movaps rbp movaps rbp movaps rbp movaps rbp rbp rbp rbp rbp It would be better to have movq s of instead of the movaps s LLVM produces ret int</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2README_8txt_source.html#l00536">README.txt:536</a></div></div>
<div class="ttc" id="aREADME-X86-64_8txt_html_ae4e9214eafe54cfd3293f59f4e9e710c"><div class="ttname"><a href="README-X86-64_8txt.html#ae4e9214eafe54cfd3293f59f4e9e710c">rax</a></div><div class="ttdeci">AMD64 Optimization Manual has some nice information about optimizing integer multiplication by a constant How much of it applies to Intel s X86 implementation There are definite trade offs to xmm0 cvttss2siq rdx jb L3 subss xmm0 rax cvttss2siq rdx xorq rax</div><div class="ttdef"><b>Definition:</b> <a href="README-X86-64_8txt_source.html#l00020">README-X86-64.txt:20</a></div></div>
<div class="ttc" id="aOcamlGCPrinter_8cpp_html_afcf2f797ed287a723263583c9b1c1bce"><div class="ttname"><a href="OcamlGCPrinter_8cpp.html#afcf2f797ed287a723263583c9b1c1bce">Y</a></div><div class="ttdeci">static GCMetadataPrinterRegistry::Add&lt; OcamlGCMetadataPrinter &gt; Y(&quot;ocaml&quot;, &quot;ocaml 3.10-compatible collector&quot;)</div></div>
<div class="ttc" id="alog_8txt_html_aa3ab6cc3a59c1050d2f016175ec5c682"><div class="ttname"><a href="log_8txt.html#aa3ab6cc3a59c1050d2f016175ec5c682">h</a></div><div class="ttdeci">IR OperandTraits h</div><div class="ttdef"><b>Definition:</b> <a href="log_8txt_source.html#l00005">log.txt:5</a></div></div>
<div class="ttc" id="alib_2Target_2X86_2README_8txt_html_a8c5ceb5d61c4f106955d6fc557ccd715"><div class="ttname"><a href="lib_2Target_2X86_2README_8txt.html#a8c5ceb5d61c4f106955d6fc557ccd715">shorter</a></div><div class="ttdeci">http eax xorl edx cl sete al setne dl sall eax sall edx But that requires good bit subreg support this might be better It s an extra but it s one instruction shorter</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2X86_2README_8txt_source.html#l00031">README.txt:31</a></div></div>
<div class="ttc" id="aREADME-SSE_8txt_html_a50fd53d9a3e55ae78555e11827355565"><div class="ttname"><a href="README-SSE_8txt.html#a50fd53d9a3e55ae78555e11827355565">t</a></div><div class="ttdeci">bitcast float %x to i32 %s=and i32 %t, 2147483647 %d=bitcast i32 %s to float ret float %d } declare float @fabsf(float %n) define float @bar(float %x) nounwind { %d=call float @fabsf(float %x) ret float %d } This IR(from PR6194):target datalayout=&quot;e-p:64:64:64-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64-f32:32:32-f64:64:64-v64:64:64-v128:128:128-a0:0:64-s0:64:64-f80:128:128-n8:16:32:64-S128&quot; target triple=&quot;x86_64-apple-darwin10.0.0&quot; %0=type { double, double } %struct.float3=type { float, float, float } define void @test(%0, %struct.float3 *nocapture %res) nounwind noinline ssp { entry:%tmp18=extractvalue %0 %0, 0 t</div><div class="ttdef"><b>Definition:</b> <a href="README-SSE_8txt_source.html#l00788">README-SSE.txt:788</a></div></div>
<div class="ttc" id="alib_2Target_2ARM_2README_8txt_html_acdf5bf3bbc10f9331f56441a4d483bb1"><div class="ttname"><a href="lib_2Target_2ARM_2README_8txt.html#acdf5bf3bbc10f9331f56441a4d483bb1">b</a></div><div class="ttdeci">the resulting code requires compare and branches when and if the revised code is with conditional branches instead of More there is a byte word extend before each where there should be only and the condition codes are not remembered when the same two values are compared twice More LSR enhancements i8 and i32 load store addressing modes are identical int b</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2ARM_2README_8txt_source.html#l00418">README.txt:418</a></div></div>
<div class="ttc" id="aREADME-FPStack_8txt_html_a43a0e0dbf10ce7d4120d0de7bcf93e72"><div class="ttname"><a href="README-FPStack_8txt.html#a43a0e0dbf10ce7d4120d0de7bcf93e72">f32mem</a></div><div class="ttdeci">We have fiadd patterns now but the followings have the same cost and complexity We need a way to specify the later is more profitable def f32mem</div><div class="ttdef"><b>Definition:</b> <a href="README-FPStack_8txt_source.html#l00018">README-FPStack.txt:18</a></div></div>
<div class="ttc" id="alib_2Target_2README_8txt_html_ac3ac4028df71f10fda029660ef66594d"><div class="ttname"><a href="lib_2Target_2README_8txt.html#ac3ac4028df71f10fda029660ef66594d">l</a></div><div class="ttdeci">This requires reassociating to forms of expressions that are already something that reassoc doesn t think about yet These two functions should generate the same code on big endian int * l</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2README_8txt_source.html#l00100">README.txt:100</a></div></div>
<div class="ttc" id="aREADME-X86-64_8txt_html_a76797a747278f45920d5cbb3faf48794"><div class="ttname"><a href="README-X86-64_8txt.html#a76797a747278f45920d5cbb3faf48794">codegen</a></div><div class="ttdeci">AMD64 Optimization Manual has some nice information about optimizing integer multiplication by a constant How much of it applies to Intel s X86 implementation There are definite trade offs to xmm0 cvttss2siq rdx jb L3 subss xmm0 rax cvttss2siq rdx xorq rdx rax ret instead of xmm1 cvttss2siq rcx movaps xmm2 subss xmm2 cvttss2siq rax rdx xorq rax ucomiss xmm0 cmovb rax ret Seems like the jb branch has high likelihood of being taken It would have saved a few instructions It s not possible to reference and DH registers in an instruction requiring REX prefix divb and mulb both produce results in AH If isel emits a CopyFromReg which gets turned into a movb and that can be allocated a r8b r15b To get around isel emits a CopyFromReg from AX and then right shift it down by and truncate it It s not pretty but it works We need some register allocation magic to make the hack go which would often require a callee saved register Callees usually need to keep this value live for most of their body so it doesn t add a significant burden on them We currently implement this in codegen</div><div class="ttdef"><b>Definition:</b> <a href="README-X86-64_8txt_source.html#l00064">README-X86-64.txt:64</a></div></div>
<div class="ttc" id="aREADME-SSE_8txt_html_ae29dc7816499411871a0ee4fdbcdbf26"><div class="ttname"><a href="README-SSE_8txt.html#ae29dc7816499411871a0ee4fdbcdbf26">here</a></div><div class="ttdeci">the custom lowered code happens to be but we shouldn t have to custom lower anything This is probably related to&lt; 2 x i64 &gt; ops being so bad LLVM currently generates stack realignment when it is not necessary needed The problem is that we need to know about stack alignment too before RA runs At that point we don t whether there will be vector or not Stack realignment logic is overly conservative here</div><div class="ttdef"><b>Definition:</b> <a href="README-SSE_8txt_source.html#l00490">README-SSE.txt:490</a></div></div>
<div class="ttc" id="aREADME-SSE_8txt_html_aa7fb4df6f9bf107995efe22628bd0f05"><div class="ttname"><a href="README-SSE_8txt.html#aa7fb4df6f9bf107995efe22628bd0f05">tmp20</a></div><div class="ttdeci">&lt; float &gt; tmp20</div><div class="ttdef"><b>Definition:</b> <a href="README-SSE_8txt_source.html#l00424">README-SSE.txt:424</a></div></div>
<div class="ttc" id="aDXILTranslateMetadata_8cpp_html_a495f2f072f4be26544a46193a96bd97b"><div class="ttname"><a href="DXILTranslateMetadata_8cpp.html#a495f2f072f4be26544a46193a96bd97b">emit</a></div><div class="ttdeci">dxil metadata emit</div><div class="ttdef"><b>Definition:</b> <a href="DXILTranslateMetadata_8cpp_source.html#l00073">DXILTranslateMetadata.cpp:73</a></div></div>
<div class="ttc" id="alib_2Target_2WebAssembly_2README_8txt_html_ad0f7d198414c3f3cf72769a0f58e5914"><div class="ttname"><a href="lib_2Target_2WebAssembly_2README_8txt.html#ad0f7d198414c3f3cf72769a0f58e5914">in</a></div><div class="ttdeci">The object format emitted by the WebAssembly backed is documented in</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2WebAssembly_2README_8txt_source.html#l00011">README.txt:11</a></div></div>
<div class="ttc" id="alib_2CodeGen_2README_8txt_html_aa0629dbc89f0868f62da8cbcb681b2be"><div class="ttname"><a href="lib_2CodeGen_2README_8txt.html#aa0629dbc89f0868f62da8cbcb681b2be">be</a></div><div class="ttdeci">Common register allocation spilling lr str ldr sxth r3 ldr mla r4 can be</div><div class="ttdef"><b>Definition:</b> <a href="lib_2CodeGen_2README_8txt_source.html#l00014">README.txt:14</a></div></div>
<div class="ttc" id="aREADME-SSE_8txt_html_a3ae57932e5f34ae3aad5075367cecb11"><div class="ttname"><a href="README-SSE_8txt.html#a3ae57932e5f34ae3aad5075367cecb11">pool</a></div><div class="ttdeci">into xmm2 addss xmm2 xmm1 xmm3 addss xmm3 movaps xmm0 unpcklps xmm0 ret seems silly when it could just be one addps Expand libm rounding functions main should enable SSE DAZ mode and other fast SSE modes Think about doing i64 math in SSE regs on x86 This testcase should have no SSE instructions in and only one load from a constant pool</div><div class="ttdef"><b>Definition:</b> <a href="README-SSE_8txt_source.html#l00085">README-SSE.txt:85</a></div></div>
<div class="ttc" id="anamespacellvm_1_1ISD_html_a22ea9cec080dd5f4f47ba234c2f59110a315004656a75a3c3a9d7294f105a8da2"><div class="ttname"><a href="namespacellvm_1_1ISD.html#a22ea9cec080dd5f4f47ba234c2f59110a315004656a75a3c3a9d7294f105a8da2">llvm::ISD::SINT_TO_FP</a></div><div class="ttdeci">@ SINT_TO_FP</div><div class="ttdoc">[SU]INT_TO_FP - These operators convert integers (whose interpreted sign depends on the first letter)...</div><div class="ttdef"><b>Definition:</b> <a href="ISDOpcodes_8h_source.html#l00773">ISDOpcodes.h:773</a></div></div>
<div class="ttc" id="aREADME-X86-64_8txt_html_a8aa6f98b8a2de9cf3066570fa5d0db10"><div class="ttname"><a href="README-X86-64_8txt.html#a8aa6f98b8a2de9cf3066570fa5d0db10">LBB1_1</a></div><div class="ttdeci">_foo edi jbe LBB1_3 LBB1_1</div><div class="ttdef"><b>Definition:</b> <a href="README-X86-64_8txt_source.html#l00094">README-X86-64.txt:94</a></div></div>
<div class="ttc" id="alib_2XRay_2CMakeLists_8txt_html_aafdfebe14a06b834fe5fb0d10309d43c"><div class="ttname"><a href="lib_2XRay_2CMakeLists_8txt.html#aafdfebe14a06b834fe5fb0d10309d43c">include</a></div><div class="ttdeci">include(LLVM-Build) add_subdirectory(IR) add_subdirectory(FuzzMutate) add_subdirectory(FileCheck) add_subdirectory(InterfaceStub) add_subdirectory(IRPrinter) add_subdirectory(IRReader) add_subdirectory(CodeGen) add_subdirectory(BinaryFormat) add_subdirectory(Bitcode) add_subdirectory(Bitstream) add_subdirectory(DWARFLinker) add_subdirectory(DWARFLinkerParallel) add_subdirectory(Extensions) add_subdirectory(Frontend) add_subdirectory(Transforms) add_subdirectory(Linker) add_subdirectory(Analysis) add_subdirectory(LTO) add_subdirectory(MC) add_subdirectory(MCA) add_subdirectory(ObjCopy) add_subdirectory(Object) add_subdirectory(ObjectYAML) add_subdirectory(Option) add_subdirectory(Remarks) add_subdirectory(Debuginfod) add_subdirectory(DebugInfo) add_subdirectory(DWP) add_subdirectory(ExecutionEngine) add_subdirectory(Target) add_subdirectory(AsmParser) add_subdirectory(LineEditor) add_subdirectory(ProfileData) add_subdirectory(Passes) add_subdirectory(TargetParser) add_subdirectory(TextAPI) add_subdirectory(ToolDrivers) add_subdirectory(XRay) if(LLVM_INCLUDE_TESTS) add_subdirectory(Testing) endif() add_subdirectory(WindowsDriver) add_subdirectory(WindowsManifest) set(LLVMCONFIGLIBRARYDEPENDENCIESINC &quot;$</div><div class="ttdef"><b>Definition:</b> <a href="lib_2XRay_2CMakeLists_8txt_source.html#l00001">CMakeLists.txt:1</a></div></div>
<div class="ttc" id="alib_2Target_2Sparc_2README_8txt_html_a70a3fcaf61f8747c8c16ea386619cf64"><div class="ttname"><a href="lib_2Target_2Sparc_2README_8txt.html#a70a3fcaf61f8747c8c16ea386619cf64">above</a></div><div class="ttdeci">To do *Keep the address of the constant pool in a register instead of forming its address all of the time *We can fold small constant offsets into the hi lo references to constant pool addresses as well *When in V9 register allocate icc *[0-3] Add support for isel ing UMUL_LOHI instead of marking it as Expand *Emit the Branch on Integer Register with Prediction instructions It s not clear how to write a pattern for this int o6 subcc l0 bne LBBt1_2 ! F nop l0 st g0 retl nop should be replaced with a brz in V9 mode *Same as above</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2Sparc_2README_8txt_source.html#l00040">README.txt:40</a></div></div>
<div class="ttc" id="aREADME-FPStack_8txt_html_a44b9b46fdc1015c475549b0cee5d5e48"><div class="ttname"><a href="README-FPStack_8txt.html#a44b9b46fdc1015c475549b0cee5d5e48">FpIADD32m</a></div><div class="ttdeci">We have fiadd patterns now but the followings have the same cost and complexity We need a way to specify the later is more profitable def def FpIADD32m</div><div class="ttdef"><b>Definition:</b> <a href="README-FPStack_8txt_source.html#l00020">README-FPStack.txt:20</a></div></div>
<div class="ttc" id="anamespacellvm_1_1tgtok_html_abbc5259d649363016626e2529fabe0c5ab2ceb2a4ac0a01535be896234ce2d83c"><div class="ttname"><a href="namespacellvm_1_1tgtok.html#abbc5259d649363016626e2529fabe0c5ab2ceb2a4ac0a01535be896234ce2d83c">llvm::tgtok::If</a></div><div class="ttdeci">@ If</div><div class="ttdef"><b>Definition:</b> <a href="TGLexer_8h_source.html#l00051">TGLexer.h:51</a></div></div>
<div class="ttc" id="aLint_8cpp_html_a7fb3c9caadeb0f7fe4828d380158d0f9"><div class="ttname"><a href="Lint_8cpp.html#a7fb3c9caadeb0f7fe4828d380158d0f9">IR</a></div><div class="ttdeci">Statically lint checks LLVM IR</div><div class="ttdef"><b>Definition:</b> <a href="Lint_8cpp_source.html#l00746">Lint.cpp:746</a></div></div>
<div class="ttc" id="aREADME-Thumb_8txt_html_a973d97283c6051f289e2347e413dff5d"><div class="ttname"><a href="README-Thumb_8txt.html#a973d97283c6051f289e2347e413dff5d">modes</a></div><div class="ttdeci">*Add support for compiling functions in both ARM and Thumb then taking the smallest *Add support for compiling individual basic blocks in thumb when in a larger ARM function This can be used for presumed cold like paths to EH handling etc *Thumb doesn t have normal pre post increment addressing modes</div><div class="ttdef"><b>Definition:</b> <a href="README-Thumb_8txt_source.html#l00012">README-Thumb.txt:12</a></div></div>
<div class="ttc" id="aLoopStrengthReduce_8cpp_html_a6d827fc34f1b4371a0b7183d3ca5bcac"><div class="ttname"><a href="LoopStrengthReduce_8cpp.html#a6d827fc34f1b4371a0b7183d3ca5bcac">reduce</a></div><div class="ttdeci">loop reduce</div><div class="ttdef"><b>Definition:</b> <a href="LoopStrengthReduce_8cpp_source.html#l07016">LoopStrengthReduce.cpp:7016</a></div></div>
<div class="ttc" id="aSupport_2tmp_8txt_html_a82c84340651b7249e408f61be003356f"><div class="ttname"><a href="Support_2tmp_8txt.html#a82c84340651b7249e408f61be003356f">CFG</a></div><div class="ttdeci">This file defines a set of templates that efficiently compute a dominator tree over a generic graph This is used typically in LLVM for fast dominance queries on the CFG</div><div class="ttdef"><b>Definition:</b> <a href="Support_2tmp_8txt_source.html#l00001">tmp.txt:1</a></div></div>
<div class="ttc" id="alib_2Target_2ARM_2README_8txt_html_ae3e84a62e4ae19e7766bde30ee72c040"><div class="ttname"><a href="lib_2Target_2ARM_2README_8txt.html#ae3e84a62e4ae19e7766bde30ee72c040">c</a></div><div class="ttdeci">the resulting code requires compare and branches when and if the revised code is with conditional branches instead of More there is a byte word extend before each where there should be only and the condition codes are not remembered when the same two values are compared twice More LSR enhancements i8 and i32 load store addressing modes are identical int int c</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2ARM_2README_8txt_source.html#l00418">README.txt:418</a></div></div>
<div class="ttc" id="aREADME-SSE_8txt_html_a4d543abbbb5e65f82c0ff777e778e848"><div class="ttname"><a href="README-SSE_8txt.html#a4d543abbbb5e65f82c0ff777e778e848">pshufd</a></div><div class="ttdeci">Instead we get xmm1 addss xmm1 pshufd</div><div class="ttdef"><b>Definition:</b> <a href="README-SSE_8txt_source.html#l00035">README-SSE.txt:35</a></div></div>
<div class="ttc" id="aRegionPrinter_8cpp_html_a5782a8740ff1e91516b41b3726a3168c"><div class="ttname"><a href="RegionPrinter_8cpp.html#a5782a8740ff1e91516b41b3726a3168c">only</a></div><div class="ttdeci">dot regions only</div><div class="ttdef"><b>Definition:</b> <a href="RegionPrinter_8cpp_source.html#l00194">RegionPrinter.cpp:194</a></div></div>
<div class="ttc" id="anamespacellvm_1_1ISD_html_a22ea9cec080dd5f4f47ba234c2f59110a84c47705bcf7271413738ae8bf3871e6"><div class="ttname"><a href="namespacellvm_1_1ISD.html#a22ea9cec080dd5f4f47ba234c2f59110a84c47705bcf7271413738ae8bf3871e6">llvm::ISD::CopyFromReg</a></div><div class="ttdeci">@ CopyFromReg</div><div class="ttdoc">CopyFromReg - This node indicates that the input value is a virtual or physical register that is defi...</div><div class="ttdef"><b>Definition:</b> <a href="ISDOpcodes_8h_source.html#l00208">ISDOpcodes.h:208</a></div></div>
<div class="ttc" id="alib_2CodeGen_2README_8txt_html_a134ffba8da3505dfab10eef1a9a8b1ef"><div class="ttname"><a href="lib_2CodeGen_2README_8txt.html#a134ffba8da3505dfab10eef1a9a8b1ef">place</a></div><div class="ttdeci">Common register allocation spilling lr str ldr sxth r3 ldr mla r4 can lr mov lr str ldr sxth r3 mla r4 and then merge mul and lr str ldr sxth r3 mla r4 It also increase the likelihood the store may become dead bb27 Successors according to LLVM ID Predecessors according to mbb&lt; bb27, 0x8b0a7c0 &gt; Note ADDri is not a two address instruction its result reg1037 is an operand of the PHI node in bb76 and its operand reg1039 is the result of the PHI node We should treat it as a two address code and make sure the ADDri is scheduled after any node that reads reg1039 Use info(i.e. register scavenger) to assign it a free register to allow reuse the collector could move the objects and invalidate the derived pointer This is bad enough in the first place</div><div class="ttdef"><b>Definition:</b> <a href="lib_2CodeGen_2README_8txt_source.html#l00050">README.txt:50</a></div></div>
<div class="ttc" id="aREADME-SSE_8txt_html_a0cd157f572169772e656b575fb0deb70"><div class="ttname"><a href="README-SSE_8txt.html#a0cd157f572169772e656b575fb0deb70">_mm_set_ps</a></div><div class="ttdeci">return _mm_set_ps(0.0, 0.0, 0.0, b)</div></div>
<div class="ttc" id="aArchiveWriter_8cpp_html_aba400c73bd6b6fcc6a245293571962a6"><div class="ttname"><a href="ArchiveWriter_8cpp.html#aba400c73bd6b6fcc6a245293571962a6">now</a></div><div class="ttdeci">static sys::TimePoint&lt; std::chrono::seconds &gt; now(bool Deterministic)</div><div class="ttdef"><b>Definition:</b> <a href="ArchiveWriter_8cpp_source.html#l00327">ArchiveWriter.cpp:327</a></div></div>
<div class="ttc" id="ablake3__dispatch_8c_html_a6efa629275df21393eef82e3bf972460a8d896e4fb625a47eaa49059a390971df"><div class="ttname"><a href="blake3__dispatch_8c.html#a6efa629275df21393eef82e3bf972460a8d896e4fb625a47eaa49059a390971df">SSE2</a></div><div class="ttdeci">@ SSE2</div><div class="ttdef"><b>Definition:</b> <a href="blake3__dispatch_8c_source.html#l00065">blake3_dispatch.c:65</a></div></div>
<div class="ttc" id="aErlangGCPrinter_8cpp_html_a74b474c0616ab55c1d9487f11fd31d26"><div class="ttname"><a href="ErlangGCPrinter_8cpp.html#a74b474c0616ab55c1d9487f11fd31d26">X</a></div><div class="ttdeci">static GCMetadataPrinterRegistry::Add&lt; ErlangGCPrinter &gt; X(&quot;erlang&quot;, &quot;erlang-compatible garbage collector&quot;)</div></div>
<div class="ttc" id="aREADME-SSE_8txt_html_a94c6254f4add8936dfd4f63ea51e226a"><div class="ttname"><a href="README-SSE_8txt.html#a94c6254f4add8936dfd4f63ea51e226a">fildl</a></div><div class="ttdeci">In fpstack this compiles esp eax movl esp fildl(%esp) fmuls LCPI1_0 addl $4</div></div>
<div class="ttc" id="alib_2Target_2SystemZ_2README_8txt_html_a8e96f00729aa3d4404fa4eff73925f9d"><div class="ttname"><a href="lib_2Target_2SystemZ_2README_8txt.html#a8e96f00729aa3d4404fa4eff73925f9d">too</a></div><div class="ttdeci">The initial backend is deliberately restricted to z10 We should add support for later architectures at some point If an asm ties an i32 r result to an i64 the input will be treated as an leaving the upper bits uninitialised For i64 store i32 i32 *dst ret void from CodeGen SystemZ asm ll will use LHI rather than LGHI to load This seems to be a general target independent problem The tuning of the choice between LOAD XC and CLC for constant length block operations We could extend them to variable length operations too</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2SystemZ_2README_8txt_source.html#l00040">README.txt:40</a></div></div>
<div class="ttc" id="aREADME-SSE_8txt_html_a647a520ebc05aa3f2389bbed3c0772e6"><div class="ttname"><a href="README-SSE_8txt.html#a647a520ebc05aa3f2389bbed3c0772e6">pinsrw</a></div><div class="ttdeci">This might compile to this xmm1 xorps xmm0 movss xmm0 ret Now consider if the code caused xmm1 to get spilled This might produce this xmm1 movaps xmm0 movaps xmm1 movss xmm0 ret since the reload is only used by these we could fold it into the producing something like xmm1 movaps xmm0 ret saving two instructions The basic idea is that a reload from a spill if only one byte chunk is bring in zeros the one element instead of elements This can be used to simplify a variety of shuffle where the elements are fixed zeros This code generates ugly probably due to costs being off or&lt; 4 x float &gt; eax xmm0 pxor xmm1 movaps xmm2 xmm2 xmm0 movaps eax ret Would it be better to ecx xmm0 xor eax pinsrw</div><div class="ttdef"><b>Definition:</b> <a href="README-SSE_8txt_source.html#l00304">README-SSE.txt:304</a></div></div>
<div class="ttc" id="alib_2CodeGen_2README_8txt_html_a09571efa45610bd20734656e6c524047"><div class="ttname"><a href="lib_2CodeGen_2README_8txt.html#a09571efa45610bd20734656e6c524047">will</a></div><div class="ttdeci">Common register allocation spilling lr str ldr sxth r3 ldr mla r4 can lr mov lr str ldr sxth r3 mla r4 and then merge mul and lr str ldr sxth r3 mla r4 It also increase the likelihood the store may become dead bb27 Successors according to LLVM ID Predecessors according to mbb&lt; bb27, 0x8b0a7c0 &gt; Note ADDri is not a two address instruction its result reg1037 is an operand of the PHI node in bb76 and its operand reg1039 is the result of the PHI node We should treat it as a two address code and make sure the ADDri is scheduled after any node that reads reg1039 Use info(i.e. register scavenger) to assign it a free register to allow reuse the collector could move the objects and invalidate the derived pointer This is bad enough in the first but safe points can crop up unpredictably **array_addr i32 n y store obj obj **nth_el If the i64 division is lowered to a then a safe point will(must) appear for the call site. If a collection occurs</div></div>
<div class="ttc" id="alib_2Target_2README_8txt_html_a819b717d29c6c488a332fefeeb3815ba"><div class="ttname"><a href="lib_2Target_2README_8txt.html#a819b717d29c6c488a332fefeeb3815ba">foo</a></div><div class="ttdeci">&lt; i32 &gt; tmp foo</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2README_8txt_source.html#l00383">README.txt:383</a></div></div>
<div class="ttc" id="alib_2Target_2ARM_2README_8txt_html_ade8c6980e1babe1b309a9bcec7eefd2c"><div class="ttname"><a href="lib_2Target_2ARM_2README_8txt.html#ade8c6980e1babe1b309a9bcec7eefd2c">one</a></div><div class="ttdeci">the resulting code requires compare and branches when and if the revised code is with conditional branches instead of More there is a byte word extend before each where there should be only one</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2ARM_2README_8txt_source.html#l00401">README.txt:401</a></div></div>
<div class="ttc" id="aREADME-SSE_8txt_html_aa8d96446b4ab4fc8ea26f7a6d9e9b38c"><div class="ttname"><a href="README-SSE_8txt.html#aa8d96446b4ab4fc8ea26f7a6d9e9b38c">tmp12</a></div><div class="ttdeci">&lt; i32 &gt; tmp12</div><div class="ttdef"><b>Definition:</b> <a href="README-SSE_8txt_source.html#l00793">README-SSE.txt:793</a></div></div>
<div class="ttc" id="alib_2Target_2README_8txt_html_a50c8e2b4c2b4b443dd0149c808a1f812"><div class="ttname"><a href="lib_2Target_2README_8txt.html#a50c8e2b4c2b4b443dd0149c808a1f812">into</a></div><div class="ttdeci">Clang compiles this into</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2README_8txt_source.html#l00504">README.txt:504</a></div></div>
<div class="ttc" id="alib_2Target_2X86_2README_8txt_html_a70ec792a441b34b77d4803f0607cf763"><div class="ttname"><a href="lib_2Target_2X86_2README_8txt.html#a70ec792a441b34b77d4803f0607cf763">Instead</a></div><div class="ttdeci">Current eax eax eax ret Ideal eax eax ret Re implement atomic builtins x86 does not have to use add to implement these Instead</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2X86_2README_8txt_source.html#l01366">README.txt:1366</a></div></div>
<div class="ttc" id="alib_2CodeGen_2README_8txt_html_a39b85bbe83e984ed97956f03d6c42501"><div class="ttname"><a href="lib_2CodeGen_2README_8txt.html#a39b85bbe83e984ed97956f03d6c42501">i32</a></div><div class="ttdeci">Common register allocation spilling lr str ldr sxth r3 ldr mla r4 can lr mov lr str ldr sxth r3 mla r4 and then merge mul and lr str ldr sxth r3 mla r4 It also increase the likelihood the store may become dead bb27 Successors according to LLVM ID Predecessors according to mbb&lt; bb27, 0x8b0a7c0 &gt; Note ADDri is not a two address instruction its result reg1037 is an operand of the PHI node in bb76 and its operand reg1039 is the result of the PHI node We should treat it as a two address code and make sure the ADDri is scheduled after any node that reads reg1039 Use info(i.e. register scavenger) to assign it a free register to allow reuse the collector could move the objects and invalidate the derived pointer This is bad enough in the first but safe points can crop up unpredictably **array_addr i32</div><div class="ttdef"><b>Definition:</b> <a href="lib_2CodeGen_2README_8txt_source.html#l00122">README.txt:122</a></div></div>
<div class="ttc" id="aREADME-SSE_8txt_html_ae94fea53621b256a05a1db5d3cfd5e3a"><div class="ttname"><a href="README-SSE_8txt.html#ae94fea53621b256a05a1db5d3cfd5e3a">foo1</a></div><div class="ttdeci">__m128 foo1(float x1, float x4)</div><div class="ttdef"><b>Definition:</b> <a href="README-SSE_8txt_source.html#l00548">README-SSE.txt:548</a></div></div>
<div class="ttc" id="aREADME-SSE_8txt_html_a27194520958d0f6fe3ac6a6bca0c67fd"><div class="ttname"><a href="README-SSE_8txt.html#a27194520958d0f6fe3ac6a6bca0c67fd">_t</a></div><div class="ttdeci">into eax xorps xmm0 xmm0 eax xmm0 eax xmm0 ret esp eax movdqa xmm0 xmm0 esp const ret align it should be movdqa xmm0 xmm0 We should transform a shuffle of two vectors of constants into a single vector of constants insertelement of a constant into a vector of constants should also result in a vector of constants e g VecISelBug ll We compiled it to something globl _t _t</div><div class="ttdef"><b>Definition:</b> <a href="README-SSE_8txt_source.html#l00675">README-SSE.txt:675</a></div></div>
<div class="ttc" id="aREADME-X86-64_8txt_html_a55b697114b0cd7a85b8d09edcebbefd5"><div class="ttname"><a href="README-X86-64_8txt.html#a55b697114b0cd7a85b8d09edcebbefd5">this</a></div><div class="ttdeci">AMD64 Optimization Manual has some nice information about optimizing integer multiplication by a constant How much of it applies to Intel s X86 implementation There are definite trade offs to xmm0 cvttss2siq rdx jb L3 subss xmm0 rax cvttss2siq rdx xorq rdx rax ret instead of xmm1 cvttss2siq rcx movaps xmm2 subss xmm2 cvttss2siq rax rdx xorq rax ucomiss xmm0 cmovb rax ret Seems like the jb branch has high likelihood of being taken It would have saved a few instructions It s not possible to reference and DH registers in an instruction requiring REX prefix divb and mulb both produce results in AH If isel emits a CopyFromReg which gets turned into a movb and that can be allocated a r8b r15b To get around this</div><div class="ttdef"><b>Definition:</b> <a href="README-X86-64_8txt_source.html#l00049">README-X86-64.txt:49</a></div></div>
<div class="ttc" id="aREADME-SSE_8txt_html_a4bd75d64b910a657cfeff45d4c21a405"><div class="ttname"><a href="README-SSE_8txt.html#a4bd75d64b910a657cfeff45d4c21a405">movsd</a></div><div class="ttdeci">This currently compiles esp movsd(%esp)</div></div>
<div class="ttc" id="aREADME-SSE_8txt_html_a74cbdc7d94b0939a18d91b65d2a046aa"><div class="ttname"><a href="README-SSE_8txt.html#a74cbdc7d94b0939a18d91b65d2a046aa">bad</a></div><div class="ttdeci">We currently generate an sqrtsd and divsd instructions This is bad</div><div class="ttdef"><b>Definition:</b> <a href="README-SSE_8txt_source.html#l00820">README-SSE.txt:820</a></div></div>
<div class="ttc" id="anamespacellvm_1_1tgtok_html_abbc5259d649363016626e2529fabe0c5a5fa7b4069ef3bd1ceb9f2caa315cf5ac"><div class="ttname"><a href="namespacellvm_1_1tgtok.html#abbc5259d649363016626e2529fabe0c5a5fa7b4069ef3bd1ceb9f2caa315cf5ac">llvm::tgtok::In</a></div><div class="ttdeci">@ In</div><div class="ttdef"><b>Definition:</b> <a href="TGLexer_8h_source.html#l00051">TGLexer.h:51</a></div></div>
<div class="ttc" id="aREADME-FPStack_8txt_html_ac989cf76f6b54e4ef9810444bf47585c"><div class="ttname"><a href="README-FPStack_8txt.html#ac989cf76f6b54e4ef9810444bf47585c">code</a></div><div class="ttdeci">We have fiadd patterns now but the followings have the same cost and complexity We need a way to specify the later is more profitable def def The FP stackifier should handle simple permutates to reduce number of shuffle e g which prevents the spiller from folding spill code into the instructions Currently the x86 codegen isn t very good at mixing SSE and FPStack code</div><div class="ttdef"><b>Definition:</b> <a href="README-FPStack_8txt_source.html#l00071">README-FPStack.txt:71</a></div></div>
<div class="ttc" id="anamespacellvm_1_1lto_html_a89ef034c1f3a70da2446c1af1d656dab"><div class="ttname"><a href="namespacellvm_1_1lto.html#a89ef034c1f3a70da2446c1af1d656dab">llvm::lto::backend</a></div><div class="ttdeci">Error backend(const Config &amp;C, AddStreamFn AddStream, unsigned ParallelCodeGenParallelismLevel, Module &amp;M, ModuleSummaryIndex &amp;CombinedIndex)</div><div class="ttdoc">Runs a regular LTO backend.</div><div class="ttdef"><b>Definition:</b> <a href="LTOBackend_8cpp_source.html#l00497">LTOBackend.cpp:497</a></div></div>
<div class="ttc" id="anamespacellvm_html_a35832c1b6a34093b01da33c2501a22ed"><div class="ttname"><a href="namespacellvm.html#a35832c1b6a34093b01da33c2501a22ed">llvm::getTheX86_32Target</a></div><div class="ttdeci">Target &amp; getTheX86_32Target()</div><div class="ttdef"><b>Definition:</b> <a href="X86TargetInfo_8cpp_source.html#l00013">X86TargetInfo.cpp:13</a></div></div>
<div class="ttc" id="aREADME__ALTIVEC_8txt_html_a52d387873c0d733fc2f0b9de3730223d"><div class="ttname"><a href="README__ALTIVEC_8txt.html#a52d387873c0d733fc2f0b9de3730223d">needed</a></div><div class="ttdeci">We should do a little better with eliminating dead stores The stores to the stack are dead since a and b are not needed</div><div class="ttdef"><b>Definition:</b> <a href="README__ALTIVEC_8txt_source.html#l00212">README_ALTIVEC.txt:212</a></div></div>
<div class="ttc" id="aREADME-SSE_8txt_html_a95f2850bc8948fe1629b4395cc3eac8a"><div class="ttname"><a href="README-SSE_8txt.html#a95f2850bc8948fe1629b4395cc3eac8a">x2</a></div><div class="ttdeci">gcc mainline compiles it x2(%rip)</div></div>
<div class="ttc" id="aREADME-X86-64_8txt_html_aac3add0badd5c39bebc02df0b5d9bdcf"><div class="ttname"><a href="README-X86-64_8txt.html#aac3add0badd5c39bebc02df0b5d9bdcf">type</a></div><div class="ttdeci">AMD64 Optimization Manual has some nice information about optimizing integer multiplication by a constant How much of it applies to Intel s X86 implementation There are definite trade offs to xmm0 cvttss2siq rdx jb L3 subss xmm0 rax cvttss2siq rdx xorq rdx rax ret instead of xmm1 cvttss2siq rcx movaps xmm2 subss xmm2 cvttss2siq rax rdx xorq rax ucomiss xmm0 cmovb rax ret Seems like the jb branch has high likelihood of being taken It would have saved a few instructions It s not possible to reference and DH registers in an instruction requiring REX prefix divb and mulb both produce results in AH If isel emits a CopyFromReg which gets turned into a movb and that can be allocated a r8b r15b To get around isel emits a CopyFromReg from AX and then right shift it down by and truncate it It s not pretty but it works We need some register allocation magic to make the hack go which would often require a callee saved register Callees usually need to keep this value live for most of their body so it doesn t add a significant burden on them We currently implement this in however this is suboptimal because it means that it would be quite awkward to implement the optimization for callers A better implementation would be to relax the LLVM IR rules for sret arguments to allow a function with an sret argument to have a non void return type</div><div class="ttdef"><b>Definition:</b> <a href="README-X86-64_8txt_source.html#l00070">README-X86-64.txt:70</a></div></div>
<div class="ttc" id="aAMDGPUUnifyDivergentExitNodes_8cpp_html_aaa253dd3e56c37edd403113782c0ef94"><div class="ttname"><a href="AMDGPUUnifyDivergentExitNodes_8cpp.html#aaa253dd3e56c37edd403113782c0ef94">nodes</a></div><div class="ttdeci">Unify divergent function exit nodes</div><div class="ttdef"><b>Definition:</b> <a href="AMDGPUUnifyDivergentExitNodes_8cpp_source.html#l00087">AMDGPUUnifyDivergentExitNodes.cpp:87</a></div></div>
<div class="ttc" id="aREADME__ALTIVEC_8txt_html_a98586ea01a32ff5046b0868b036a1849"><div class="ttname"><a href="README__ALTIVEC_8txt.html#a98586ea01a32ff5046b0868b036a1849">index</a></div><div class="ttdeci">splat index</div><div class="ttdef"><b>Definition:</b> <a href="README__ALTIVEC_8txt_source.html#l00181">README_ALTIVEC.txt:181</a></div></div>
<div class="ttc" id="alib_2Target_2README_8txt_html_a9026bda84f719fb903ddea83fc478a76"><div class="ttname"><a href="lib_2Target_2README_8txt.html#a9026bda84f719fb903ddea83fc478a76">following</a></div><div class="ttdeci">This is equivalent to the following</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2README_8txt_source.html#l00671">README.txt:671</a></div></div>
<div class="ttc" id="aCompiler_8h_html_adeb6f14d9f377993d79fae2efb34ecac"><div class="ttname"><a href="Compiler_8h.html#adeb6f14d9f377993d79fae2efb34ecac">LLVM_EXTERNAL_VISIBILITY</a></div><div class="ttdeci">#define LLVM_EXTERNAL_VISIBILITY</div><div class="ttdef"><b>Definition:</b> <a href="Compiler_8h_source.html#l00127">Compiler.h:127</a></div></div>
<div class="ttc" id="aREADME-SSE_8txt_html_afd91459f7d35fb3d57a28214c8a358dd"><div class="ttname"><a href="README-SSE_8txt.html#afd91459f7d35fb3d57a28214c8a358dd">tmp10</a></div><div class="ttdeci">&lt; i128 &gt; tmp10</div><div class="ttdef"><b>Definition:</b> <a href="README-SSE_8txt_source.html#l00791">README-SSE.txt:791</a></div></div>
<div class="ttc" id="anamespacellvm_1_1ARM__MB_html_ad70272e2a9ec2a7e3a497458e1edbc85aed0b9bef861c96eee19e89db753db7b2"><div class="ttname"><a href="namespacellvm_1_1ARM__MB.html#ad70272e2a9ec2a7e3a497458e1edbc85aed0b9bef861c96eee19e89db753db7b2">llvm::ARM_MB::ST</a></div><div class="ttdeci">@ ST</div><div class="ttdef"><b>Definition:</b> <a href="MCTargetDesc_2ARMBaseInfo_8h_source.html#l00073">ARMBaseInfo.h:73</a></div></div>
<div class="ttc" id="aREADME-SSE_8txt_html_a019e22102ee3b50e193cf17c60c2aef6"><div class="ttname"><a href="README-SSE_8txt.html#a019e22102ee3b50e193cf17c60c2aef6">SSE4</a></div><div class="ttdeci">gcc mainline compiles it xmm0 xmm1 movaps xmm2 movlhps xmm2 movaps xmm0 ret We compile vector multiply by constant into poor&lt; i32 10, i32 10, i32 10, i32 10 &gt; ret&lt; 4 x i32 &gt; A On targets without SSE4</div><div class="ttdef"><b>Definition:</b> <a href="README-SSE_8txt_source.html#l00571">README-SSE.txt:571</a></div></div>
<div class="ttc" id="aREADME-X86-64_8txt_html_a9de23273550c17a1957b1b325a01960e"><div class="ttname"><a href="README-X86-64_8txt.html#a9de23273550c17a1957b1b325a01960e">AH</a></div><div class="ttdeci">AMD64 Optimization Manual has some nice information about optimizing integer multiplication by a constant How much of it applies to Intel s X86 implementation There are definite trade offs to xmm0 cvttss2siq rdx jb L3 subss xmm0 rax cvttss2siq rdx xorq rdx rax ret instead of xmm1 cvttss2siq rcx movaps xmm2 subss xmm2 cvttss2siq rax rdx xorq rax ucomiss xmm0 cmovb rax ret Seems like the jb branch has high likelihood of being taken It would have saved a few instructions It s not possible to reference AH</div><div class="ttdef"><b>Definition:</b> <a href="README-X86-64_8txt_source.html#l00044">README-X86-64.txt:44</a></div></div>
<div class="ttc" id="aREADME-SSE_8txt_html_a5bb85f857c34e7994807b47c7241cb2c"><div class="ttname"><a href="README-SSE_8txt.html#a5bb85f857c34e7994807b47c7241cb2c">slot</a></div><div class="ttdeci">This might compile to this xmm1 xorps xmm0 movss xmm0 ret Now consider if the code caused xmm1 to get spilled This might produce this xmm1 movaps xmm0 movaps xmm1 movss xmm0 ret since the reload is only used by these we could fold it into the producing something like xmm1 movaps xmm0 ret saving two instructions The basic idea is that a reload from a spill slot</div><div class="ttdef"><b>Definition:</b> <a href="README-SSE_8txt_source.html#l00269">README-SSE.txt:269</a></div></div>
<div class="ttc" id="anamespacellvm_1_1LegalityPredicates_html_ad7ac7032baa62cc00002886633b9f281"><div class="ttname"><a href="namespacellvm_1_1LegalityPredicates.html#ad7ac7032baa62cc00002886633b9f281">llvm::LegalityPredicates::all</a></div><div class="ttdeci">Predicate all(Predicate P0, Predicate P1)</div><div class="ttdoc">True iff P0 and P1 are true.</div><div class="ttdef"><b>Definition:</b> <a href="LegalizerInfo_8h_source.html#l00228">LegalizerInfo.h:228</a></div></div>
<div class="ttc" id="alib_2Target_2README_8txt_html_a5a6a05b7d9e9efb3f7b098c20fa0088a"><div class="ttname"><a href="lib_2Target_2README_8txt.html#a5a6a05b7d9e9efb3f7b098c20fa0088a">s</a></div><div class="ttdeci">multiplies can be turned into SHL s</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2README_8txt_source.html#l00370">README.txt:370</a></div></div>
<div class="ttc" id="anamespacellvm_1_1ARM__AM_html_a5d0557608eaebed12bc00812724ba2cdae6bcee28992dab735eaa43f5dfa48a09"><div class="ttname"><a href="namespacellvm_1_1ARM__AM.html#a5d0557608eaebed12bc00812724ba2cdae6bcee28992dab735eaa43f5dfa48a09">llvm::ARM_AM::add</a></div><div class="ttdeci">@ add</div><div class="ttdef"><b>Definition:</b> <a href="ARMAddressingModes_8h_source.html#l00039">ARMAddressingModes.h:39</a></div></div>
<div class="ttc" id="anamespacellvm_1_1logicalview_html_ace26b39c8ec4392e05223c28d8572c4d"><div class="ttname"><a href="namespacellvm_1_1logicalview.html#ace26b39c8ec4392e05223c28d8572c4d">llvm::logicalview::patterns</a></div><div class="ttdeci">LVPatterns &amp; patterns()</div><div class="ttdef"><b>Definition:</b> <a href="LVOptions_8h_source.html#l00640">LVOptions.h:640</a></div></div>
<div class="ttc" id="alib_2Target_2ARM_2README_8txt_html_ad3a99906764c35b2694ae90fa57744a5"><div class="ttname"><a href="lib_2Target_2ARM_2README_8txt.html#ad3a99906764c35b2694ae90fa57744a5">move</a></div><div class="ttdeci">compiles ldr LCPI1_0 ldr ldr mov lsr tst moveq r1 ldr LCPI1_1 and r0 bx lr It would be better to do something like to fold the shift into the conditional move</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2ARM_2README_8txt_source.html#l00546">README.txt:546</a></div></div>
<div class="ttc" id="anamespacellvm_1_1numbers_html_a92f4283d4e0e2ea1776894b3ae93640f"><div class="ttname"><a href="namespacellvm_1_1numbers.html#a92f4283d4e0e2ea1776894b3ae93640f">llvm::numbers::e</a></div><div class="ttdeci">constexpr double e</div><div class="ttdef"><b>Definition:</b> <a href="MathExtras_8h_source.html#l00031">MathExtras.h:31</a></div></div>
<div class="ttc" id="alib_2Target_2PowerPC_2README_8txt_html_aba0c170191748fa03b4c2ff10328fb94"><div class="ttname"><a href="lib_2Target_2PowerPC_2README_8txt.html#aba0c170191748fa03b4c2ff10328fb94">slightly</a></div><div class="ttdeci">entry stw r5 blr GCC r3 srawi xor r4 subf r0 stw r5 blr which is much nicer This theoretically may help improve twolf slightly(used in dimbox.c:142?).</div></div>
<div class="ttc" id="aREADME-SSE_8txt_html_a1721fc47ceb559582d0b5cc35a009afe"><div class="ttname"><a href="README-SSE_8txt.html#a1721fc47ceb559582d0b5cc35a009afe">to</a></div><div class="ttdeci">This compiles xmm1 mulss xmm1 xorps xmm0 movss xmm0 ret Because mulss doesn t modify the top the top elements of xmm1 are already zero d We could compile this to</div><div class="ttdef"><b>Definition:</b> <a href="README-SSE_8txt_source.html#l00224">README-SSE.txt:224</a></div></div>
<div class="ttc" id="aMD5_8cpp_html_ac0eafdc9ee161b71e7af98af736952fd"><div class="ttname"><a href="MD5_8cpp.html#ac0eafdc9ee161b71e7af98af736952fd">I</a></div><div class="ttdeci">#define I(x, y, z)</div><div class="ttdef"><b>Definition:</b> <a href="MD5_8cpp_source.html#l00058">MD5.cpp:58</a></div></div>
<div class="ttc" id="aREADME-SSE_8txt_html_a2b0732029f53354e4c2f685e93b36cac"><div class="ttname"><a href="README-SSE_8txt.html#a2b0732029f53354e4c2f685e93b36cac">something</a></div><div class="ttdeci">This might compile to this xmm1 xorps xmm0 movss xmm0 ret Now consider if the code caused xmm1 to get spilled This might produce this xmm1 movaps xmm0 movaps xmm1 movss xmm0 ret since the reload is only used by these we could fold it into the producing something like xmm1 movaps xmm0 ret saving two instructions The basic idea is that a reload from a spill if only one byte chunk is bring in zeros the one element instead of elements This can be used to simplify a variety of shuffle where the elements are fixed zeros This code generates ugly probably due to costs being off or something</div><div class="ttdef"><b>Definition:</b> <a href="README-SSE_8txt_source.html#l00278">README-SSE.txt:278</a></div></div>
<div class="ttc" id="alib_2Target_2ARM_2README_8txt_html_a09f6d95681fd43c904d1164c81a5141d"><div class="ttname"><a href="lib_2Target_2ARM_2README_8txt.html#a09f6d95681fd43c904d1164c81a5141d">call</a></div><div class="ttdeci">S is passed via registers r2 But gcc stores them to the and then reload them to and r3 before issuing the call(r0 contains the address of the format string)</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2ARM_2README_8txt_source.html#l00190">README.txt:190</a></div></div>
<div class="ttc" id="aREADME-SSE_8txt_html_adb7d9f7a99bf1090decff0ea8b50452d"><div class="ttname"><a href="README-SSE_8txt.html#adb7d9f7a99bf1090decff0ea8b50452d">node</a></div><div class="ttdeci">This currently compiles esp xmm0 movsd esp eax eax esp ret We should use not the dag combiner This is because dagcombine2 needs to be able to see through the X86ISD::Wrapper node</div><div class="ttdef"><b>Definition:</b> <a href="README-SSE_8txt_source.html#l00406">README-SSE.txt:406</a></div></div>
<div class="ttc" id="alib_2Target_2X86_2README_8txt_html_ad0a666df390b6bb23e152cd3805fe429"><div class="ttname"><a href="lib_2Target_2X86_2README_8txt.html#ad0a666df390b6bb23e152cd3805fe429">generated</a></div><div class="ttdeci">The following code is currently generated</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2X86_2README_8txt_source.html#l00954">README.txt:954</a></div></div>
<div class="ttc" id="aREADME-SSE_8txt_html_ad0309a241b6466a18eb3be300d7f1ae9"><div class="ttname"><a href="README-SSE_8txt.html#ad0309a241b6466a18eb3be300d7f1ae9">numbers</a></div><div class="ttdeci">SSE has instructions for doing operations on complex numbers</div><div class="ttdef"><b>Definition:</b> <a href="README-SSE_8txt_source.html#l00022">README-SSE.txt:22</a></div></div>
<div class="ttc" id="aREADME-Thumb_8txt_html_aba06a6e625a3fd56ccd541e3e78ab6be"><div class="ttname"><a href="README-Thumb_8txt.html#aba06a6e625a3fd56ccd541e3e78ab6be">LCPI1_0</a></div><div class="ttdeci">&gt; ldr r0, pc, #((LCPI1_0-(LPCRELL0+4))&amp;0xfffffffc) We compile the following:define i16 @func_entry_2E_ce(i32 %i) { switch i32 %i, label %bb12.exitStub[i32 0, label %bb4.exitStub i32 1, label %bb9.exitStub i32 2, label %bb4.exitStub i32 3, label %bb4.exitStub i32 7, label %bb9.exitStub i32 8, label %bb.exitStub i32 9, label %bb9.exitStub] bb12.exitStub:ret i16 0 bb4.exitStub:ret i16 1 bb9.exitStub:ret i16 2 bb.exitStub:ret i16 3 } into:_func_entry_2E_ce:mov r2, #1 lsl r2, r0 cmp r0, #9 bhi LBB1_4 @bb12.exitStub LBB1_1:@newFuncRoot mov r1, #13 tst r2, r1 bne LBB1_5 @bb4.exitStub LBB1_2:@newFuncRoot ldr r1, LCPI1_0 tst r2, r1 bne LBB1_6 @bb9.exitStub LBB1_3:@newFuncRoot mov r1, #1 lsl r1, r1, #8 tst r2, r1 bne LBB1_7 @bb.exitStub LBB1_4:@bb12.exitStub mov r0, #0 bx lr LBB1_5:@bb4.exitStub mov r0, #1 bx lr LBB1_6:@bb9.exitStub mov r0, #2 bx lr LBB1_7:@bb.exitStub mov r0, #3 bx lr LBB1_8:.align 2 LCPI1_0:.long 642 gcc compiles to:cmp r0, #9 @ lr needed for prologue bhi L2 ldr r3, L11 mov r2, #1 mov r1, r2, asl r0 ands r0, r3, r2, asl r0 movne r0, #2 bxne lr tst r1, #13 beq L9 L3:mov r0, r2 bx lr L9:tst r1, #256 movne r0, #3 bxne lr L2:mov r0, #0 bx lr L12:.align 2 L11:.long 642 GCC is doing a couple of clever things here:1. It is predicating one of the returns. This isn 't a clear win though:in cases where that return isn 't taken, it is replacing one condbranch with two 'ne' predicated instructions. 2. It is sinking the shift of &quot;1 &lt;&lt; i&quot; into the tst, and using ands instead of tst. This will probably require whole function isel. 3. GCC emits:tst r1, #256 we emit:mov r1, #1 lsl r1, r1, #8 tst r2, r1 When spilling in thumb mode and the sp offset is too large to fit in the ldr/str offset field, we load the offset from a constpool entry and add it to sp:ldr r2, LCPI add r2, sp ldr r2,[r2] These instructions preserve the condition code which is important if the spill is between a cmp and a bcc instruction. However, we can use the(potentially) cheaper sequence if we know it 's ok to clobber the condition register. add r2, sp, #255 *4 add r2, #132 ldr r2,[r2, #7 *4] This is especially bad when dynamic alloca is used. The all fixed size stack objects are referenced off the frame pointer with negative offsets. See oggenc for an example. Poor codegen test/CodeGen/ARM/select.ll f7:ldr r5, LCPI1_0 LPC0:add r5, pc ldr r6, LCPI1_1 ldr r2, LCPI1_2 mov r3, r6 mov lr, pc bx r5 Make register allocator/spiller smarter so we can re-materialize &quot;mov r, imm&quot;, etc. Almost all Thumb instructions clobber condition code. Thumb load/store address mode offsets are scaled. The values kept in the instruction operands are pre-scale values. This probably ought to be changed to avoid extra work when we convert Thumb2 instructions to Thumb1 instructions. We need to make(some of the) Thumb1 instructions predicable. That will allow shrinking of predicated Thumb2 instructions. To allow this, we need to be able to toggle the 's' bit since they do not set CPSR when they are inside IT blocks. Make use of hi register variants of cmp:tCMPhir/tCMPZhir. Thumb1 immediate field sometimes keep pre-scaled values. See ThumbRegisterInfo::eliminateFrameIndex. This is inconsistent from ARM and Thumb2. Rather than having tBR_JTr print a &quot;.align 2&quot; and constant island pass pad it, add a target specific ALIGN instruction instead. That way, getInstSizeInBytes won 't have to over-estimate. It can also be used for loop alignment pass. We generate conditional code for icmp when we don 't need to. This code:int foo(int s) { return s==1 LCPI1_0</div><div class="ttdef"><b>Definition:</b> <a href="README-Thumb_8txt_source.html#l00249">README-Thumb.txt:249</a></div></div>
<div class="ttc" id="anamespacellvm_html_a457abdc792a2b697c1031f09edb8492f"><div class="ttname"><a href="namespacellvm.html#a457abdc792a2b697c1031f09edb8492f">llvm::shuffle</a></div><div class="ttdeci">void shuffle(Iterator first, Iterator last, RNG &amp;&amp;g)</div><div class="ttdef"><b>Definition:</b> <a href="STLExtras_8h_source.html#l01577">STLExtras.h:1577</a></div></div>
<div class="ttc" id="aREADME-SSE_8txt_html_ae71309f701fc132f606d3dd8d2f1b235"><div class="ttname"><a href="README-SSE_8txt.html#ae71309f701fc132f606d3dd8d2f1b235">Guide</a></div><div class="ttdeci">This might compile to this xmm1 xorps xmm0 movss xmm0 ret Now consider if the code caused xmm1 to get spilled This might produce this xmm1 movaps xmm0 movaps xmm1 movss xmm0 ret since the reload is only used by these we could fold it into the producing something like xmm1 movaps xmm0 ret saving two instructions The basic idea is that a reload from a spill if only one byte chunk is bring in zeros the one element instead of elements This can be used to simplify a variety of shuffle where the elements are fixed zeros This code generates ugly probably due to costs being off or&lt; 4 x float &gt; eax xmm0 pxor xmm1 movaps xmm2 xmm2 xmm0 movaps eax ret Would it be better to ecx xmm0 xor eax xmm0 xmm0 movaps ecx ret Some useful information in the Apple Altivec SSE Migration Guide</div><div class="ttdef"><b>Definition:</b> <a href="README-SSE_8txt_source.html#l00318">README-SSE.txt:318</a></div></div>
<div class="ttc" id="aXRayInstrumentation_8cpp_html_a3d7f8a500f0593da70cb5a39b985840d"><div class="ttname"><a href="XRayInstrumentation_8cpp.html#a3d7f8a500f0593da70cb5a39b985840d">ops</a></div><div class="ttdeci">xray Insert XRay ops</div><div class="ttdef"><b>Definition:</b> <a href="XRayInstrumentation_8cpp_source.html#l00268">XRayInstrumentation.cpp:268</a></div></div>
<div class="ttc" id="alib_2Target_2ARM_2README_8txt_html_ae2bb081d94f22e64ca6bc4bd58512a93"><div class="ttname"><a href="lib_2Target_2ARM_2README_8txt.html#ae2bb081d94f22e64ca6bc4bd58512a93">memcpy</a></div><div class="ttdeci">&lt;%struct.s * &gt; cast struct s *S to sbyte *&lt; sbyte * &gt; sbyte uint cast struct s *agg result to sbyte *&lt; sbyte * &gt; sbyte uint cast struct s *memtmp to sbyte *&lt; sbyte * &gt; sbyte uint ret void llc ends up issuing two memcpy or custom lower memcpy(of small size) to be ldmia/stmia. I think option 2 is better but the current register allocator cannot allocate a chunk of registers at a time. A feasible temporary solution is to use specific physical registers at the lowering time for small(&lt;</div></div>
<div class="ttc" id="aLoopExtractor_8cpp_html_a84dff14934298a71113ab11312c243f6"><div class="ttname"><a href="LoopExtractor_8cpp.html#a84dff14934298a71113ab11312c243f6">extract</a></div><div class="ttdeci">loop extract</div><div class="ttdef"><b>Definition:</b> <a href="LoopExtractor_8cpp_source.html#l00092">LoopExtractor.cpp:92</a></div></div>
<div class="ttc" id="aREADME-SSE_8txt_html_ad795430afc323aa07d2ee7eaf084c8ed"><div class="ttname"><a href="README-SSE_8txt.html#ad795430afc323aa07d2ee7eaf084c8ed">B</a></div><div class="ttdeci">Instead we get xmm1 addss xmm1 xmm2 movhlps xmm0 movaps xmm3 addss xmm3 movdqa xmm0 addss xmm0 ret there are cases where some simple SLP would improve codegen a bit compiling _Complex float B</div><div class="ttdef"><b>Definition:</b> <a href="README-SSE_8txt_source.html#l00046">README-SSE.txt:46</a></div></div>
<div class="ttc" id="anamespacellvm_1_1ScaledNumbers_html_a0651aa0a52c69c4fe12cf730e7ed65ab"><div class="ttname"><a href="namespacellvm_1_1ScaledNumbers.html#a0651aa0a52c69c4fe12cf730e7ed65ab">llvm::ScaledNumbers::compare</a></div><div class="ttdeci">int compare(DigitsT LDigits, int16_t LScale, DigitsT RDigits, int16_t RScale)</div><div class="ttdoc">Compare two scaled numbers.</div><div class="ttdef"><b>Definition:</b> <a href="ScaledNumber_8h_source.html#l00252">ScaledNumber.h:252</a></div></div>
<div class="ttc" id="alib_2Target_2X86_2README_8txt_html_ae0623af8f1debe2f6deaf507c4adbaf9"><div class="ttname"><a href="lib_2Target_2X86_2README_8txt.html#ae0623af8f1debe2f6deaf507c4adbaf9">slower</a></div><div class="ttdeci">Instead of the following for memset char edx edx edx It might be better to generate eax movl edx movl edx movw edx when we can spare a register It reduces code size Evaluate what the best way to codegen sdiv C is For we currently get ret i32 Y eax movl ecx ecx ecx addl eax eax ret GCC knows several different ways to codegen one of which is eax eax ecx cmovle eax eax ret which is probably slower</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2X86_2README_8txt_source.html#l00161">README.txt:161</a></div></div>
<div class="ttc" id="aREADME-SSE_8txt_html_adff055de8bac5465d2600c78402012f4"><div class="ttname"><a href="README-SSE_8txt.html#adff055de8bac5465d2600c78402012f4">edi</a></div><div class="ttdeci">into eax xorps xmm0 xmm0 eax xmm0 eax xmm0 ret esp eax movdqa xmm0 xmm0 esp const ret align it should be movdqa xmm0 edi</div><div class="ttdef"><b>Definition:</b> <a href="README-SSE_8txt_source.html#l00650">README-SSE.txt:650</a></div></div>
<div class="ttc" id="alib_2Target_2README_8txt_html_aa08809ca81b324a7ecb8582b8b01325a"><div class="ttname"><a href="lib_2Target_2README_8txt.html#aa08809ca81b324a7ecb8582b8b01325a">movq</a></div><div class="ttdeci">Clang compiles this i1 i64 store i64 i64 store i64 i64 store i64 i64 store i64 align Which gets codegen d xmm0 movaps rbp movaps rbp movaps rbp movaps rbp movq</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2README_8txt_source.html#l00521">README.txt:521</a></div></div>
<div class="ttc" id="aMemDepPrinter_8cpp_html_a470d8721ad7c3b718e9daeabdaeb4700"><div class="ttname"><a href="MemDepPrinter_8cpp.html#a470d8721ad7c3b718e9daeabdaeb4700">function</a></div><div class="ttdeci">print Print MemDeps of function</div><div class="ttdef"><b>Definition:</b> <a href="MemDepPrinter_8cpp_source.html#l00082">MemDepPrinter.cpp:82</a></div></div>
<div class="ttc" id="aREADME-SSE_8txt_html_a4dcf393bc0c26fe7709c9cb233a753cc"><div class="ttname"><a href="README-SSE_8txt.html#a4dcf393bc0c26fe7709c9cb233a753cc">cvtsi2sd</a></div><div class="ttdeci">In fpstack this compiles esp eax movl esp esp ret in SSE it compiles into significantly slower esp cvtsi2sd(%esp)</div></div>
<div class="ttc" id="alib_2Target_2PowerPC_2README_8txt_html_a0f7b1322c308206fa2a288a73d971615"><div class="ttname"><a href="lib_2Target_2PowerPC_2README_8txt.html#a0f7b1322c308206fa2a288a73d971615">_a</a></div><div class="ttdeci">So that lo16() _a(r2) lbz r2</div></div>
<div class="ttc" id="aREADME-X86-64_8txt_html_a158d4e36abc00d4b6d81ec82c1ef783b"><div class="ttname"><a href="README-X86-64_8txt.html#a158d4e36abc00d4b6d81ec82c1ef783b">foo</a></div><div class="ttdeci">int foo(unsigned x)</div><div class="ttdef"><b>Definition:</b> <a href="README-X86-64_8txt_source.html#l00081">README-X86-64.txt:81</a></div></div>
<div class="ttc" id="aSIOptimizeExecMaskingPreRA_8cpp_html_a3e47bdb3e296b00df96eff7896fa57bf"><div class="ttname"><a href="SIOptimizeExecMaskingPreRA_8cpp.html#a3e47bdb3e296b00df96eff7896fa57bf">RA</a></div><div class="ttdeci">SI optimize exec mask operations pre RA</div><div class="ttdef"><b>Definition:</b> <a href="SIOptimizeExecMaskingPreRA_8cpp_source.html#l00071">SIOptimizeExecMaskingPreRA.cpp:71</a></div></div>
<div class="ttc" id="aAMDGPUISelDAGToDAG_8cpp_html_a1bcea9a90cf7291ab18e2df09099b9ad"><div class="ttname"><a href="AMDGPUISelDAGToDAG_8cpp.html#a1bcea9a90cf7291ab18e2df09099b9ad">isel</a></div><div class="ttdeci">amdgpu isel</div><div class="ttdef"><b>Definition:</b> <a href="AMDGPUISelDAGToDAG_8cpp_source.html#l00109">AMDGPUISelDAGToDAG.cpp:109</a></div></div>
<div class="ttc" id="aREADME-SSE_8txt_html_a2aed79b3604227d932c081fff333d13f"><div class="ttname"><a href="README-SSE_8txt.html#a2aed79b3604227d932c081fff333d13f">shufps</a></div><div class="ttdeci">This might compile to this xmm1 xorps xmm0 movss xmm0 ret Now consider if the code caused xmm1 to get spilled This might produce this xmm1 movaps xmm0 movaps xmm1 movss xmm0 ret since the reload is only used by these we could fold it into the producing something like xmm1 movaps xmm0 ret saving two instructions The basic idea is that a reload from a spill if only one byte chunk is bring in zeros the one element instead of elements This can be used to simplify a variety of shuffle where the elements are fixed zeros This code generates ugly probably due to costs being off or&lt; 4 x float &gt; eax xmm0 pxor xmm1 movaps xmm2 shufps</div><div class="ttdef"><b>Definition:</b> <a href="README-SSE_8txt_source.html#l00293">README-SSE.txt:293</a></div></div>
<div class="ttc" id="alib_2Target_2README_8txt_html_a00fbe120dd0ce034b4a84296fe00f63b"><div class="ttname"><a href="lib_2Target_2README_8txt.html#a00fbe120dd0ce034b4a84296fe00f63b">also</a></div><div class="ttdeci">Doing so could allow SROA of the destination pointers See also</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2README_8txt_source.html#l00166">README.txt:166</a></div></div>
<div class="ttc" id="aREADME-SSE_8txt_html_a557b2a20b8cd67dc8c5cf18f167bffe6"><div class="ttname"><a href="README-SSE_8txt.html#a557b2a20b8cd67dc8c5cf18f167bffe6">norm</a></div><div class="ttdeci">void norm(double x, double y, double z)</div><div class="ttdef"><b>Definition:</b> <a href="README-SSE_8txt_source.html#l00815">README-SSE.txt:815</a></div></div>
<div class="ttc" id="aREADME-SSE_8txt_html_a07c9d568a9ec7929a526f2b6753b764f"><div class="ttname"><a href="README-SSE_8txt.html#a07c9d568a9ec7929a526f2b6753b764f">gcc</a></div><div class="ttdeci">into eax xorps xmm0 xmm0 eax xmm0 eax xmm0 ret gcc</div><div class="ttdef"><b>Definition:</b> <a href="README-SSE_8txt_source.html#l00630">README-SSE.txt:630</a></div></div>
<div class="ttc" id="aREADME-SSE_8txt_html_af0593b732249f24e0bf308c756b7fcd7"><div class="ttname"><a href="README-SSE_8txt.html#af0593b732249f24e0bf308c756b7fcd7">rdar</a></div><div class="ttdeci">into eax xorps xmm0 xmm0 eax xmm0 eax xmm0 ret esp eax movdqa xmm0 xmm0 esp const ret align it should be movdqa xmm0 xmm0 We should transform a shuffle of two vectors of constants into a single vector of constants insertelement of a constant into a vector of constants should also result in a vector of constants e g VecISelBug ll We compiled it to something globl _t xmm0 movhps xmm0 movss xmm1 movaps xmm2 xmm2 xmm0 movaps rdar</div><div class="ttdef"><b>Definition:</b> <a href="README-SSE_8txt_source.html#l00689">README-SSE.txt:689</a></div></div>
<div class="ttc" id="anamespacellvm_html_a57f2ca0e57f4f7b13f56f9aa16af3e0d"><div class="ttname"><a href="namespacellvm.html#a57f2ca0e57f4f7b13f56f9aa16af3e0d">llvm::min</a></div><div class="ttdeci">Expected&lt; ExpressionValue &gt; min(const ExpressionValue &amp;Lhs, const ExpressionValue &amp;Rhs)</div><div class="ttdef"><b>Definition:</b> <a href="FileCheck_8cpp_source.html#l00357">FileCheck.cpp:357</a></div></div>
<div class="ttc" id="aREADME-SSE_8txt_html_a18d36b4a92c6ff6f001363ae248165d6"><div class="ttname"><a href="README-SSE_8txt.html#a18d36b4a92c6ff6f001363ae248165d6">elements</a></div><div class="ttdeci">This compiles xmm1 mulss xmm1 xorps xmm0 movss xmm0 ret Because mulss doesn t modify the top elements</div><div class="ttdef"><b>Definition:</b> <a href="README-SSE_8txt_source.html#l00221">README-SSE.txt:221</a></div></div>
<div class="ttc" id="aREADME-X86-64_8txt_html_a8263ab76864f3825a9ab363f831212d9"><div class="ttname"><a href="README-X86-64_8txt.html#a8263ab76864f3825a9ab363f831212d9">LBB1_2</a></div><div class="ttdeci">_foo edi jbe LBB1_3 eax LBB1_2</div><div class="ttdef"><b>Definition:</b> <a href="README-X86-64_8txt_source.html#l00096">README-X86-64.txt:96</a></div></div>
<div class="ttc" id="alib_2Target_2X86_2README_8txt_html_a7be0f11e03983f0479d6810c99eff54c"><div class="ttname"><a href="lib_2Target_2X86_2README_8txt.html#a7be0f11e03983f0479d6810c99eff54c">esp</a></div><div class="ttdeci">We currently emits esp</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2X86_2README_8txt_source.html#l00235">README.txt:235</a></div></div>
<div class="ttc" id="aREADME-SSE_8txt_html_adad32264994a045ab3879ba5c7c00f8f"><div class="ttname"><a href="README-SSE_8txt.html#adad32264994a045ab3879ba5c7c00f8f">xmm2</a></div><div class="ttdeci">Instead we get xmm1 addss xmm1 xmm2 movhlps xmm0 movaps xmm3 addss xmm3 movdqa xmm2</div><div class="ttdef"><b>Definition:</b> <a href="README-SSE_8txt_source.html#l00039">README-SSE.txt:39</a></div></div>
<div class="ttc" id="aREADME__ALTIVEC_8txt_html_a015846b6188ce15e08cd94c74a9df1a3"><div class="ttname"><a href="README__ALTIVEC_8txt.html#a015846b6188ce15e08cd94c74a9df1a3">A</a></div><div class="ttdeci">* A</div><div class="ttdef"><b>Definition:</b> <a href="README__ALTIVEC_8txt_source.html#l00089">README_ALTIVEC.txt:89</a></div></div>
<div class="ttc" id="aREADME__ALTIVEC_8txt_html_a3b54c55bd8a7121b30fc06cc567afcf0"><div class="ttname"><a href="README__ALTIVEC_8txt.html#a3b54c55bd8a7121b30fc06cc567afcf0">instruction</a></div><div class="ttdeci">Since we know that Vector is byte aligned and we know the element offset of we should change the load into a lve *x instruction</div><div class="ttdef"><b>Definition:</b> <a href="README__ALTIVEC_8txt_source.html#l00037">README_ALTIVEC.txt:37</a></div></div>
<div class="ttc" id="aREADME-SSE_8txt_html_a10b70cdd8ae9a200f1682767e2229b8b"><div class="ttname"><a href="README-SSE_8txt.html#a10b70cdd8ae9a200f1682767e2229b8b">lowered</a></div><div class="ttdeci">into xmm2 addss xmm2 xmm1 xmm3 addss xmm3 movaps xmm0 unpcklps xmm0 ret seems silly when it could just be one addps Expand libm rounding functions main should enable SSE DAZ mode and other fast SSE modes Think about doing i64 math in SSE regs on x86 This testcase should have no SSE instructions in and only one load from a constant double ret double C the select is being lowered</div><div class="ttdef"><b>Definition:</b> <a href="README-SSE_8txt_source.html#l00089">README-SSE.txt:89</a></div></div>
<div class="ttc" id="aBranchProbability_8cpp_html_aa8c7ae7da7990d5320b67c57f6fc3b59"><div class="ttname"><a href="BranchProbability_8cpp.html#aa8c7ae7da7990d5320b67c57f6fc3b59">scale</a></div><div class="ttdeci">static uint64_t scale(uint64_t Num, uint32_t N, uint32_t D)</div><div class="ttdef"><b>Definition:</b> <a href="BranchProbability_8cpp_source.html#l00069">BranchProbability.cpp:69</a></div></div>
<div class="ttc" id="aREADME-FPStack_8txt_html_aeb9a134c2755c0ad7801bf630a790904"><div class="ttname"><a href="README-FPStack_8txt.html#aeb9a134c2755c0ad7801bf630a790904">trunc</a></div><div class="ttdeci">We have fiadd patterns now but the followings have the same cost and complexity We need a way to specify the later is more profitable def def The FP stackifier should handle simple permutates to reduce number of shuffle e g trunc</div><div class="ttdef"><b>Definition:</b> <a href="README-FPStack_8txt_source.html#l00063">README-FPStack.txt:63</a></div></div>
<div class="ttc" id="aREADME-SSE_8txt_html_a051ffba49261f95a3e4b04985b604a81"><div class="ttname"><a href="README-SSE_8txt.html#a051ffba49261f95a3e4b04985b604a81">fldl</a></div><div class="ttdeci">In fpstack this compiles esp eax movl esp esp ret in SSE it compiles into significantly slower esp xmm0 mulsd xmm0 movsd esp fldl(%esp) addl $12</div></div>
<div class="ttc" id="alib_2Target_2X86_2README_8txt_html_adbcd470b5e5a9cc475f1bc60ea3582a0"><div class="ttname"><a href="lib_2Target_2X86_2README_8txt.html#adbcd470b5e5a9cc475f1bc60ea3582a0">LBB1_3</a></div><div class="ttdeci">For the entry BB esp pxor xmm0 xmm1 ucomisd xmm1 setnp al sete cl testb al jne LBB1_5 xmm2 cvtss2sd xmm3 ucomisd xmm0 ja LBB1_3 xmm2 LBB1_3</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2X86_2README_8txt_source.html#l00521">README.txt:521</a></div></div>
<div class="ttc" id="alib_2CodeGen_2README_8txt_html_a37b703060219534badc7e9e41ef240f0"><div class="ttname"><a href="lib_2CodeGen_2README_8txt.html#a37b703060219534badc7e9e41ef240f0">Consider</a></div><div class="ttdeci">Common register allocation spilling lr str ldr sxth r3 ldr mla r4 can lr mov lr str ldr sxth r3 mla r4 and then merge mul and lr str ldr sxth r3 mla r4 It also increase the likelihood the store may become dead bb27 Successors according to LLVM ID Predecessors according to mbb&lt; bb27, 0x8b0a7c0 &gt; Note ADDri is not a two address instruction its result reg1037 is an operand of the PHI node in bb76 and its operand reg1039 is the result of the PHI node We should treat it as a two address code and make sure the ADDri is scheduled after any node that reads reg1039 Use info(i.e. register scavenger) to assign it a free register to allow reuse the collector could move the objects and invalidate the derived pointer This is bad enough in the first but safe points can crop up unpredictably Consider</div><div class="ttdef"><b>Definition:</b> <a href="lib_2CodeGen_2README_8txt_source.html#l00121">README.txt:121</a></div></div>
<div class="ttc" id="alib_2Target_2X86_2README_8txt_html_a35b4e9931514f0279aa86d42fbf42ccb"><div class="ttname"><a href="lib_2Target_2X86_2README_8txt.html#a35b4e9931514f0279aa86d42fbf42ccb">xor</a></div><div class="ttdeci">We currently generate a but we really shouldn eax ecx xorl edx divl ecx eax divl ecx movl eax ret A similar code sequence works for division We currently compile i32 v2 eax eax jo LBB1_2 xor</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2X86_2README_8txt_source.html#l01271">README.txt:1271</a></div></div>
<div class="ttc" id="alib_2Target_2README_8txt_html_a7df6ed7588301267782c2bd4b7f6899d"><div class="ttname"><a href="lib_2Target_2README_8txt.html#a7df6ed7588301267782c2bd4b7f6899d">for</a></div><div class="ttdeci">this could be done in SelectionDAGISel along with other special for</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2README_8txt_source.html#l00104">README.txt:104</a></div></div>
<div class="ttc" id="aREADME-SSE_8txt_html_a46c8085554844d09b2f3c80bdc833a19"><div class="ttname"><a href="README-SSE_8txt.html#a46c8085554844d09b2f3c80bdc833a19">consider</a></div><div class="ttdeci">This currently compiles esp xmm0 movsd esp eax eax esp ret We should use not the dag combiner This is because dagcombine2 needs to be able to see through the X86ISD::Wrapper which DAGCombine can t really do The code for turning x load into a single vector load is target independent and should be moved to the dag combiner The code for turning x load into a vector load can only handle a direct load from a global or a direct load from the stack It should be generalized to handle any load from where P can be anything The alignment inference code cannot handle loads from globals in static non mode because it doesn t look through the extra dyld stub load If you try vec_align ll without relocation you ll see what I mean We should lower which eliminates a constant pool load For consider</div><div class="ttdef"><b>Definition:</b> <a href="README-SSE_8txt_source.html#l00421">README-SSE.txt:421</a></div></div>
<div class="ttc" id="aREADME-FPStack_8txt_html_a889fa095273abbe439677044aea2c31f"><div class="ttname"><a href="README-FPStack_8txt.html#a889fa095273abbe439677044aea2c31f">instructions</a></div><div class="ttdeci">We have fiadd patterns now but the followings have the same cost and complexity We need a way to specify the later is more profitable def def The FP stackifier should handle simple permutates to reduce number of shuffle instructions</div><div class="ttdef"><b>Definition:</b> <a href="README-FPStack_8txt_source.html#l00025">README-FPStack.txt:25</a></div></div>
<div class="ttc" id="aREADME-X86-64_8txt_html_a10fdb803b02d258eb015ef80106ddf93"><div class="ttname"><a href="README-X86-64_8txt.html#a10fdb803b02d258eb015ef80106ddf93">However</a></div><div class="ttdeci">AMD64 Optimization Manual has some nice information about optimizing integer multiplication by a constant How much of it applies to Intel s X86 implementation There are definite trade offs to xmm0 cvttss2siq rdx jb L3 subss xmm0 rax cvttss2siq rdx xorq rdx rax ret instead of xmm1 cvttss2siq rcx movaps xmm2 subss xmm2 cvttss2siq rax rdx xorq rax ucomiss xmm0 cmovb rax ret Seems like the jb branch has high likelihood of being taken It would have saved a few instructions It s not possible to reference and DH registers in an instruction requiring REX prefix However</div><div class="ttdef"><b>Definition:</b> <a href="README-X86-64_8txt_source.html#l00045">README-X86-64.txt:45</a></div></div>
<div class="ttc" id="alib_2Target_2ARM_2README_8txt_html_a46e498e9b70d8cac397bcbb09510c615"><div class="ttname"><a href="lib_2Target_2ARM_2README_8txt.html#a46e498e9b70d8cac397bcbb09510c615">not</a></div><div class="ttdeci">Should compile r2 movcc movcs str strb mov lr r1 movcs movcc mov lr not</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2ARM_2README_8txt_source.html#l00465">README.txt:465</a></div></div>
<div class="ttc" id="aREADME-SSE_8txt_html_a28e029e2e6494d38a6a16477b740dfe2"><div class="ttname"><a href="README-SSE_8txt.html#a28e029e2e6494d38a6a16477b740dfe2">movzbl</a></div><div class="ttdeci">into eax xorps xmm0 xmm0 movzbl(%esp)</div></div>
<div class="ttc" id="alib_2Target_2X86_2README_8txt_html_a115261e730f097d0f23d72326fbbe67f"><div class="ttname"><a href="lib_2Target_2X86_2README_8txt.html#a115261e730f097d0f23d72326fbbe67f">t1</a></div><div class="ttdeci">&lt;%struct.bf ** &gt; define void t1() nounwind ssp</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2X86_2README_8txt_source.html#l01497">README.txt:1497</a></div></div>
<div class="ttc" id="aREADME-SSE_8txt_html_ab3cef6ef8e0ec90bd4f44b6794a4fd9c"><div class="ttname"><a href="README-SSE_8txt.html#ab3cef6ef8e0ec90bd4f44b6794a4fd9c">instructions</a></div><div class="ttdeci">This might compile to this xmm1 xorps xmm0 movss xmm0 ret Now consider if the code caused xmm1 to get spilled This might produce this xmm1 movaps xmm0 movaps xmm1 movss xmm0 ret since the reload is only used by these instructions</div><div class="ttdef"><b>Definition:</b> <a href="README-SSE_8txt_source.html#l00257">README-SSE.txt:257</a></div></div>
<div class="ttc" id="anamespaceFIXME_html_ab540b4225b27525c895776ad9350e729"><div class="ttname"><a href="namespaceFIXME.html#ab540b4225b27525c895776ad9350e729">FIXME::unit</a></div><div class="ttdeci">unit</div><div class="ttdef"><b>Definition:</b> <a href="include_2llvm_2Demangle_2README_8txt_source.html#l00055">README.txt:55</a></div></div>
<div class="ttc" id="aREADME-SSE_8txt_html_a489a33a25e00e1000eae3b54c9c548b1"><div class="ttname"><a href="README-SSE_8txt.html#a489a33a25e00e1000eae3b54c9c548b1">Testcase</a></div><div class="ttdeci">the custom lowered code happens to be but we shouldn t have to custom lower anything This is probably related to&lt; 2 x i64 &gt; ops being so bad LLVM currently generates stack realignment when it is not necessary needed The problem is that we need to know about stack alignment too before RA runs At that point we don t whether there will be vector or not Stack realignment logic is overly conservative but otherwise we can produce unaligned loads stores Fixing this will require some huge RA changes Testcase</div><div class="ttdef"><b>Definition:</b> <a href="README-SSE_8txt_source.html#l00498">README-SSE.txt:498</a></div></div>
<div class="ttc" id="aX86TargetInfo_8cpp_html_a322daa16581038024ce0d2d04e5091d1"><div class="ttname"><a href="X86TargetInfo_8cpp.html#a322daa16581038024ce0d2d04e5091d1">LLVMInitializeX86TargetInfo</a></div><div class="ttdeci">LLVM_EXTERNAL_VISIBILITY void LLVMInitializeX86TargetInfo()</div><div class="ttdef"><b>Definition:</b> <a href="X86TargetInfo_8cpp_source.html#l00022">X86TargetInfo.cpp:22</a></div></div>
<div class="ttc" id="aREADME-Thumb_8txt_html_ad7bf7cc723b97ab4a518502c217ddbd7"><div class="ttname"><a href="README-Thumb_8txt.html#ad7bf7cc723b97ab4a518502c217ddbd7">mode</a></div><div class="ttdeci">*Add support for compiling functions in both ARM and Thumb mode</div><div class="ttdef"><b>Definition:</b> <a href="README-Thumb_8txt_source.html#l00005">README-Thumb.txt:5</a></div></div>
<div class="ttc" id="alib_2Target_2ARM_2README_8txt_html_afa4b88db99757d588d8206e7f0783700"><div class="ttname"><a href="lib_2Target_2ARM_2README_8txt.html#afa4b88db99757d588d8206e7f0783700">possible</a></div><div class="ttdeci">the resulting code requires compare and branches when and if the revised code is with conditional branches instead of More there is a byte word extend before each where there should be only and the condition codes are not remembered when the same two values are compared twice More LSR enhancements possible</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2ARM_2README_8txt_source.html#l00410">README.txt:410</a></div></div>
<div class="ttc" id="aREADME-FPStack_8txt_html_aed5f5193c55c84e3b070141538ed4c66"><div class="ttname"><a href="README-FPStack_8txt.html#aed5f5193c55c84e3b070141538ed4c66">OneArgFPRW</a></div><div class="ttdeci">We have fiadd patterns now but the followings have the same cost and complexity We need a way to specify the later is more profitable def OneArgFPRW</div><div class="ttdef"><b>Definition:</b> <a href="README-FPStack_8txt_source.html#l00018">README-FPStack.txt:18</a></div></div>
<div class="ttc" id="aREADME-SSE_8txt_html_ab0d01de2cfd143286d8714b59a8a0cfd"><div class="ttname"><a href="README-SSE_8txt.html#ab0d01de2cfd143286d8714b59a8a0cfd">foo</a></div><div class="ttdeci">&lt; float * &gt; store float float *tmp5 ret void Compiles rax rax movl rdi ret This would be better kept in the SSE unit by treating XMM0 as a and doing a shuffle from v[1] to v[0] then a float store[UNSAFE FP] void foo(double, double, double)</div></div>
<div class="ttc" id="alib_2Target_2ARM_2README_8txt_html_a3a82232c420700208dd1b19e316558d8"><div class="ttname"><a href="lib_2Target_2ARM_2README_8txt.html#a3a82232c420700208dd1b19e316558d8">bit</a></div><div class="ttdeci">compiles ldr LCPI1_0 ldr ldr mov lsr tst moveq r1 ldr LCPI1_1 and r0 bx lr It would be better to do something like to fold the shift into the conditional ldr LCPI1_0 ldr ldr tst movne lsr ldr LCPI1_1 and r0 bx lr it saves an instruction and a register It might be profitable to cse MOVi16 if there are lots of bit immediates with the same bottom half Robert Muth started working on an alternate jump table implementation that does not put the tables in line in the text This is more like the llvm default jump table implementation This might be useful sometime Several revisions of patches are on the mailing beginning while CMP sets them like a subtract Therefore to be able to use CMN for comparisons other than the Z bit</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2ARM_2README_8txt_source.html#l00584">README.txt:584</a></div></div>
<div class="ttc" id="aREADME-Thumb_8txt_html_a5d98a8b5139e56ebf0d2ff4cbaa0dc5e"><div class="ttname"><a href="README-Thumb_8txt.html#a5d98a8b5139e56ebf0d2ff4cbaa0dc5e">code</a></div><div class="ttdeci">*Add support for compiling functions in both ARM and Thumb then taking the smallest *Add support for compiling individual basic blocks in thumb when in a larger ARM function This can be used for presumed cold code</div><div class="ttdef"><b>Definition:</b> <a href="README-Thumb_8txt_source.html#l00009">README-Thumb.txt:9</a></div></div>
<div class="ttc" id="aREADME-SSE_8txt_html_a4240386010e8ab75256e7fd072800b1a"><div class="ttname"><a href="README-SSE_8txt.html#a4240386010e8ab75256e7fd072800b1a">can</a></div><div class="ttdeci">This might compile to this xmm1 xorps xmm0 movss xmm0 ret Now consider if the code caused xmm1 to get spilled This might produce this xmm1 movaps xmm0 movaps xmm1 movss xmm0 ret since the reload is only used by these we could fold it into the producing something like xmm1 movaps xmm0 ret saving two instructions The basic idea is that a reload from a spill can</div><div class="ttdef"><b>Definition:</b> <a href="README-SSE_8txt_source.html#l00269">README-SSE.txt:269</a></div></div>
<div class="ttc" id="alib_2Target_2README_8txt_html_af9f7a898c4a757821053e38056d9383f"><div class="ttname"><a href="lib_2Target_2README_8txt.html#af9f7a898c4a757821053e38056d9383f">or</a></div><div class="ttdeci">compiles or</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2README_8txt_source.html#l00606">README.txt:606</a></div></div>
<div class="ttc" id="alib_2Target_2PowerPC_2README_8txt_html_aa91241c8c54738377749dc47ee489e0d"><div class="ttname"><a href="lib_2Target_2PowerPC_2README_8txt.html#aa91241c8c54738377749dc47ee489e0d">get</a></div><div class="ttdeci">Should compile to something r4 addze r3 instead we get</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2PowerPC_2README_8txt_source.html#l00024">README.txt:24</a></div></div>
<div class="ttc" id="aREADME__ALTIVEC_8txt_html_af279f70fce803d73d58062f72beefc2c"><div class="ttname"><a href="README__ALTIVEC_8txt.html#af279f70fce803d73d58062f72beefc2c">_test</a></div><div class="ttdeci">float space text globl _test align _test</div><div class="ttdef"><b>Definition:</b> <a href="README__ALTIVEC_8txt_source.html#l00118">README_ALTIVEC.txt:118</a></div></div>
<div class="ttc" id="anamespacellvm_1_1support_html_a2560071a977efb94947d664e396f7206aa2d63b0536e1684292bd8bbbe49a6099"><div class="ttname"><a href="namespacellvm_1_1support.html#a2560071a977efb94947d664e396f7206aa2d63b0536e1684292bd8bbbe49a6099">llvm::support::aligned</a></div><div class="ttdeci">@ aligned</div><div class="ttdef"><b>Definition:</b> <a href="Endian_8h_source.html#l00030">Endian.h:30</a></div></div>
<div class="ttc" id="anamespacellvm_1_1support_html_a2560071a977efb94947d664e396f7206af6b11e8bcea1b0b70051b197f2cb3f84"><div class="ttname"><a href="namespacellvm_1_1support.html#a2560071a977efb94947d664e396f7206af6b11e8bcea1b0b70051b197f2cb3f84">llvm::support::unaligned</a></div><div class="ttdeci">@ unaligned</div><div class="ttdef"><b>Definition:</b> <a href="Endian_8h_source.html#l00030">Endian.h:30</a></div></div>
<div class="ttc" id="anamespacellvm_1_1X86ISD_html_a9441a4f94d36d0f7c0c34aca42e3f76aabad10e5691f05a78824d6bad0300e529"><div class="ttname"><a href="namespacellvm_1_1X86ISD.html#a9441a4f94d36d0f7c0c34aca42e3f76aabad10e5691f05a78824d6bad0300e529">llvm::X86ISD::FMIN</a></div><div class="ttdeci">@ FMIN</div><div class="ttdef"><b>Definition:</b> <a href="X86ISelLowering_8h_source.html#l00265">X86ISelLowering.h:265</a></div></div>
<div class="ttc" id="aREADME-FPStack_8txt_html_aa8ea581c0435890dd4e28c4ee2111f3c"><div class="ttname"><a href="README-FPStack_8txt.html#aa8ea581c0435890dd4e28c4ee2111f3c">targets</a></div><div class="ttdeci">Some targets(e.g. athlons) prefer freep to fstp ST(0)</div><div class="ttdef"><b>Definition:</b> <a href="README-FPStack_8txt_source.html#l00007">README-FPStack.txt:7</a></div></div>
<div class="ttc" id="aREADME-SSE_8txt_html_aa909e47be20d3c871de457c29a9d8e66"><div class="ttname"><a href="README-SSE_8txt.html#aa909e47be20d3c871de457c29a9d8e66">better</a></div><div class="ttdeci">In x86 we generate this spiffy xmm0 xmm0 ret in x86 we generate this which could be better</div><div class="ttdef"><b>Definition:</b> <a href="README-SSE_8txt_source.html#l00537">README-SSE.txt:537</a></div></div>
<div class="ttc" id="astructllvm_1_1RegisterTarget_html"><div class="ttname"><a href="structllvm_1_1RegisterTarget.html">llvm::RegisterTarget</a></div><div class="ttdoc">RegisterTarget - Helper template for registering a target, for use in the target's initialization fun...</div><div class="ttdef"><b>Definition:</b> <a href="TargetRegistry_8h_source.html#l01136">TargetRegistry.h:1136</a></div></div>
<div class="ttc" id="aREADME-SSE_8txt_html_ad5e57085f0a5626e0728f308cd1e28a9"><div class="ttname"><a href="README-SSE_8txt.html#ad5e57085f0a5626e0728f308cd1e28a9">LC0</a></div><div class="ttdeci">into eax xorps xmm0 xmm0 eax xmm0 eax xmm0 ret esp eax movdqa LC0</div><div class="ttdef"><b>Definition:</b> <a href="README-SSE_8txt_source.html#l00632">README-SSE.txt:632</a></div></div>
<div class="ttc" id="alib_2Target_2PowerPC_2README_8txt_html_ad78486583aa82143a9e9bb4337cc97fe"><div class="ttname"><a href="lib_2Target_2PowerPC_2README_8txt.html#ad78486583aa82143a9e9bb4337cc97fe">x</a></div><div class="ttdeci">TODO unsigned x</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2PowerPC_2README_8txt_source.html#l00010">README.txt:10</a></div></div>
<div class="ttc" id="aDXContainerGlobals_8cpp_html_ace9918659ef4a022d158646784619514"><div class="ttname"><a href="DXContainerGlobals_8cpp.html#ace9918659ef4a022d158646784619514">globals</a></div><div class="ttdeci">dxil globals</div><div class="ttdef"><b>Definition:</b> <a href="DXContainerGlobals_8cpp_source.html#l00107">DXContainerGlobals.cpp:107</a></div></div>
<div class="ttc" id="aRelocation_8txt_html_a68313176186aa4c2f15836f8c0d7ec38"><div class="ttname"><a href="Relocation_8txt.html#a68313176186aa4c2f15836f8c0d7ec38">got</a></div><div class="ttdeci">Generic address nodes are lowered to some combination of target independent and machine specific and compilation options The choice of specific instructions that are to be used is delegated to ISel which in turn relies on TableGen patterns to choose subtarget specific instructions For in the pseudo code generated got(sym))</div></div>
<div class="ttc" id="aREADME-SSE_8txt_html_aba06a6e625a3fd56ccd541e3e78ab6be"><div class="ttname"><a href="README-SSE_8txt.html#aba06a6e625a3fd56ccd541e3e78ab6be">LCPI1_0</a></div><div class="ttdeci">gcc mainline compiles it xmm0 xmm1 movaps xmm2 movlhps xmm2 movaps xmm0 ret We compile vector multiply by constant into poor&lt; i32 10, i32 10, i32 10, i32 10 &gt; ret&lt; 4 x i32 &gt; A On targets without this compiles globl _f xmm1 movd eax imull LCPI1_0</div><div class="ttdef"><b>Definition:</b> <a href="README-SSE_8txt_source.html#l00584">README-SSE.txt:584</a></div></div>
<div class="ttc" id="alib_2Target_2PowerPC_2README_8txt_html_a8895a2a3113ec14d3ff4ccaae3de69b1"><div class="ttname"><a href="lib_2Target_2PowerPC_2README_8txt.html#a8895a2a3113ec14d3ff4ccaae3de69b1">than</a></div><div class="ttdeci">So that lo16() r2 stb r3 blr Becomes r3 they should compile to something better than</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2PowerPC_2README_8txt_source.html#l00161">README.txt:161</a></div></div>
<div class="ttc" id="alib_2Target_2README_8txt_html_a69955d334349c9adad86cd95171dce4c"><div class="ttname"><a href="lib_2Target_2README_8txt.html#a69955d334349c9adad86cd95171dce4c">transform</a></div><div class="ttdeci">instcombine should handle this transform</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2README_8txt_source.html#l00262">README.txt:262</a></div></div>
<div class="ttc" id="aREADME-SSE_8txt_html_ae84295a97a5c91f83808c66cdf8d8ae6"><div class="ttname"><a href="README-SSE_8txt.html#ae84295a97a5c91f83808c66cdf8d8ae6">shift_right</a></div><div class="ttdeci">SSE Variable shift can be custom lowered to something like which uses a small table unaligned load shuffle instead of going through memory __m128i shift_right(__m128i value, unsigned long offset)</div><div class="ttdef"><b>Definition:</b> <a href="README-SSE_8txt_source.html#l00015">README-SSE.txt:15</a></div></div>
<div class="ttc" id="alib_2Target_2X86_2README_8txt_html_a56c9db45beb30274a14b02303322dbba"><div class="ttname"><a href="lib_2Target_2X86_2README_8txt.html#a56c9db45beb30274a14b02303322dbba">flds</a></div><div class="ttdeci">esp eax movl ecx ecx cvtsi2ss xmm0 eax cvtsi2ss xmm1 xmm0 addss xmm0 movss flds(%esp, 1) 0000002d addl $0x04</div></div>
<div class="ttc" id="anamespacellvm_1_1MCID_html_ab357441fcd1ea1f9b0d27c12700f6023a2b016c207343046b2bac45e69e76dcec"><div class="ttname"><a href="namespacellvm_1_1MCID.html#ab357441fcd1ea1f9b0d27c12700f6023a2b016c207343046b2bac45e69e76dcec">llvm::MCID::Add</a></div><div class="ttdeci">@ Add</div><div class="ttdef"><b>Definition:</b> <a href="MCInstrDesc_8h_source.html#l00186">MCInstrDesc.h:186</a></div></div>
<div class="ttc" id="aX86MCAsmInfo_8cpp_html_a4b03ac9ad021493fa239610fa246f195a8bdd46a005182f6bb046e0e134efcb02"><div class="ttname"><a href="X86MCAsmInfo_8cpp.html#a4b03ac9ad021493fa239610fa246f195a8bdd46a005182f6bb046e0e134efcb02">Intel</a></div><div class="ttdeci">@ Intel</div><div class="ttdef"><b>Definition:</b> <a href="X86MCAsmInfo_8cpp_source.html#l00023">X86MCAsmInfo.cpp:23</a></div></div>
<div class="ttc" id="alib_2Target_2README_8txt_html_a66529b13967f1d18538dfa09dfb603d8"><div class="ttname"><a href="lib_2Target_2README_8txt.html#a66529b13967f1d18538dfa09dfb603d8">arguments</a></div><div class="ttdeci">we compile this esp call L1 $pb L1 esp je LBB1_2 esp ret but is currently always computed in the entry block It would be better to sink the picbase computation down into the block for the as it is the only one that uses it This happens for a lot of code with early outs Another example is loads of arguments</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2README_8txt_source.html#l00425">README.txt:425</a></div></div>
<div class="ttc" id="aREADME-SSE_8txt_html_a26453c881beeb33cd589962e4c10b791"><div class="ttname"><a href="README-SSE_8txt.html#a26453c881beeb33cd589962e4c10b791">horrible</a></div><div class="ttdeci">into eax xorps xmm0 xmm0 eax xmm0 eax xmm0 ret esp eax movdqa xmm0 xmm0 esp const ret align it should be movdqa xmm0 xmm0 We should transform a shuffle of two vectors of constants into a single vector of constants insertelement of a constant into a vector of constants should also result in a vector of constants e g VecISelBug ll We compiled it to something horrible</div><div class="ttdef"><b>Definition:</b> <a href="README-SSE_8txt_source.html#l00672">README-SSE.txt:672</a></div></div>
<div class="ttc" id="alib_2Target_2X86_2README_8txt_html_a82149c97ea37050346bdc9a259830e23"><div class="ttname"><a href="lib_2Target_2X86_2README_8txt.html#a82149c97ea37050346bdc9a259830e23">shifts</a></div><div class="ttdeci">http eax xorl edx cl sete al setne dl sall eax sall edx But that requires good bit subreg support this might be better It s an extra but it s one instruction and doesn t stress bit subreg eax eax movl edx edx sall eax sall cl edx bit shifts(in general) expand to really bad code. Instead of using cmovs</div></div>
<div class="ttc" id="aREADME-SSE_8txt_html_a88133f077b219dc1aa8430c3082c3c60"><div class="ttname"><a href="README-SSE_8txt.html#a88133f077b219dc1aa8430c3082c3c60">y</a></div><div class="ttdeci">void y(unsigned n)</div><div class="ttdef"><b>Definition:</b> <a href="README-SSE_8txt_source.html#l00358">README-SSE.txt:358</a></div></div>
<div class="ttc" id="aREADME-SSE_8txt_html_ad7bf7cc723b97ab4a518502c217ddbd7"><div class="ttname"><a href="README-SSE_8txt.html#ad7bf7cc723b97ab4a518502c217ddbd7">mode</a></div><div class="ttdeci">In x86 mode</div><div class="ttdef"><b>Definition:</b> <a href="README-SSE_8txt_source.html#l00527">README-SSE.txt:527</a></div></div>
<div class="ttc" id="alib_2Target_2ARM_2README_8txt_html_a0923c429b0c515f4ace7a106c97935d4"><div class="ttname"><a href="lib_2Target_2ARM_2README_8txt.html#a0923c429b0c515f4ace7a106c97935d4">This</a></div><div class="ttdeci">the resulting code requires compare and branches when and if the revised code is with conditional branches instead of More there is a byte word extend before each where there should be only and the condition codes are not remembered when the same two values are compared twice More LSR enhancements i8 and i32 load store addressing modes are identical This</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2ARM_2README_8txt_source.html#l00418">README.txt:418</a></div></div>
<div class="ttc" id="aREADME-X86-64_8txt_html_af6b32b3392ff64883b0113536e2a2181"><div class="ttname"><a href="README-X86-64_8txt.html#af6b32b3392ff64883b0113536e2a2181">BH</a></div><div class="ttdeci">AMD64 Optimization Manual has some nice information about optimizing integer multiplication by a constant How much of it applies to Intel s X86 implementation There are definite trade offs to xmm0 cvttss2siq rdx jb L3 subss xmm0 rax cvttss2siq rdx xorq rdx rax ret instead of xmm1 cvttss2siq rcx movaps xmm2 subss xmm2 cvttss2siq rax rdx xorq rax ucomiss xmm0 cmovb rax ret Seems like the jb branch has high likelihood of being taken It would have saved a few instructions It s not possible to reference BH</div><div class="ttdef"><b>Definition:</b> <a href="README-X86-64_8txt_source.html#l00044">README-X86-64.txt:44</a></div></div>
<div class="ttc" id="aREADME-SSE_8txt_html_ab64eb2268e80cb6e7c6d70ef67cc36f4"><div class="ttname"><a href="README-SSE_8txt.html#ab64eb2268e80cb6e7c6d70ef67cc36f4">_f</a></div><div class="ttdeci">gcc mainline compiles it xmm0 xmm1 movaps xmm2 movlhps xmm2 movaps xmm0 ret We compile vector multiply by constant into poor&lt; i32 10, i32 10, i32 10, i32 10 &gt; ret&lt; 4 x i32 &gt; A On targets without this compiles globl _f _f</div><div class="ttdef"><b>Definition:</b> <a href="README-SSE_8txt_source.html#l00582">README-SSE.txt:582</a></div></div>
<div class="ttc" id="aREADME-SSE_8txt_html_a21496e452d1b284494d85ed01a98d8ee"><div class="ttname"><a href="README-SSE_8txt.html#a21496e452d1b284494d85ed01a98d8ee">xmm3</a></div><div class="ttdeci">Instead we get xmm1 addss xmm1 xmm2 movhlps xmm0 movaps xmm3 addss xmm3 movdqa xmm0 addss xmm3</div><div class="ttdef"><b>Definition:</b> <a href="README-SSE_8txt_source.html#l00040">README-SSE.txt:40</a></div></div>
<div class="ttc" id="aREADME-SSE_8txt_html_afd6f6f24b23f9cb36763c45a21e92080"><div class="ttname"><a href="README-SSE_8txt.html#afd6f6f24b23f9cb36763c45a21e92080">Currently</a></div><div class="ttdeci">into xmm2 addss xmm2 xmm1 xmm3 addss xmm3 movaps xmm0 unpcklps xmm0 ret seems silly when it could just be one addps Expand libm rounding functions main should enable SSE DAZ mode and other fast SSE modes Think about doing i64 math in SSE regs on x86 This testcase should have no SSE instructions in and only one load from a constant double ret double C Currently</div><div class="ttdef"><b>Definition:</b> <a href="README-SSE_8txt_source.html#l00089">README-SSE.txt:89</a></div></div>
<div class="ttc" id="aREADME-SSE_8txt_html_a610fe5a018a1d4a21039cbcb56a5f8b7"><div class="ttname"><a href="README-SSE_8txt.html#a610fe5a018a1d4a21039cbcb56a5f8b7">Also</a></div><div class="ttdeci">Instead we get xmm1 addss xmm1 xmm2 movhlps xmm0 movaps xmm3 addss xmm3 movdqa xmm0 addss xmm0 ret Also</div><div class="ttdef"><b>Definition:</b> <a href="README-SSE_8txt_source.html#l00043">README-SSE.txt:43</a></div></div>
<div class="ttc" id="aREADME-SSE_8txt_html_aae2d2977835e891eef9c1569d44462d7"><div class="ttname"><a href="README-SSE_8txt.html#aae2d2977835e891eef9c1569d44462d7">used</a></div><div class="ttdeci">This might compile to this xmm1 xorps xmm0 movss xmm0 ret Now consider if the code caused xmm1 to get spilled This might produce this xmm1 movaps xmm0 movaps xmm1 movss xmm0 ret since the reload is only used by these we could fold it into the producing something like xmm1 movaps xmm0 ret saving two instructions The basic idea is that a reload from a spill if only one byte chunk is used</div><div class="ttdef"><b>Definition:</b> <a href="README-SSE_8txt_source.html#l00270">README-SSE.txt:270</a></div></div>
<div class="ttc" id="aREADME-X86-64_8txt_html_a31538bd407722ed0d3710ed609a66586"><div class="ttname"><a href="README-X86-64_8txt.html#a31538bd407722ed0d3710ed609a66586">edi</a></div><div class="ttdeci">_foo edi jbe LBB1_3 edi</div><div class="ttdef"><b>Definition:</b> <a href="README-X86-64_8txt_source.html#l00094">README-X86-64.txt:94</a></div></div>
<div class="ttc" id="aAArch64ISelDAGToDAG_8cpp_html_a2098a5fa6ada61b6c4a1f210ad84e4a1a4ebada6a2af2bcba53ded1d7b414f081"><div class="ttname"><a href="AArch64ISelDAGToDAG_8cpp.html#a2098a5fa6ada61b6c4a1f210ad84e4a1a4ebada6a2af2bcba53ded1d7b414f081">SelectTypeKind::FP</a></div><div class="ttdeci">@ FP</div></div>
<div class="ttc" id="alib_2Target_2X86_2README_8txt_html_abf89f09e76ca3bcfb207cddc821f3299"><div class="ttname"><a href="lib_2Target_2X86_2README_8txt.html#abf89f09e76ca3bcfb207cddc821f3299">shift</a></div><div class="ttdeci">http eax xorl edx cl sete al setne dl sall eax sall edx But that requires good bit subreg support this might be better It s an extra shift</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2X86_2README_8txt_source.html#l00030">README.txt:30</a></div></div>
<div class="ttc" id="aRelocation_8txt_html_ad0265f082d0dc86496888b7cec1b717d"><div class="ttname"><a href="Relocation_8txt.html#ad0265f082d0dc86496888b7cec1b717d">LLVM</a></div><div class="ttdeci">MIPS Relocation Principles In LLVM</div><div class="ttdef"><b>Definition:</b> <a href="Relocation_8txt_source.html#l00003">Relocation.txt:3</a></div></div>
<div class="ttc" id="alib_2Target_2ARM_2README_8txt_html_ac3302d36e5507ecfe3ed8ba03d5e320c"><div class="ttname"><a href="lib_2Target_2ARM_2README_8txt.html#ac3302d36e5507ecfe3ed8ba03d5e320c">stack</a></div><div class="ttdeci">S is passed via registers r2 But gcc stores them to the stack</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2ARM_2README_8txt_source.html#l00189">README.txt:189</a></div></div>
<div class="ttc" id="aREADME-SSE_8txt_html_a046a6d1aee589cf3d51d08c2e9a66236"><div class="ttname"><a href="README-SSE_8txt.html#a046a6d1aee589cf3d51d08c2e9a66236">However</a></div><div class="ttdeci">This might compile to this xmm1 xorps xmm0 movss xmm0 ret Now consider if the code caused xmm1 to get spilled This might produce this xmm1 movaps xmm0 movaps xmm1 movss xmm0 ret However</div><div class="ttdef"><b>Definition:</b> <a href="README-SSE_8txt_source.html#l00257">README-SSE.txt:257</a></div></div>
<div class="ttc" id="aREADME-SSE_8txt_html_ae08edf2a0482a5d008070bbd72580a40"><div class="ttname"><a href="README-SSE_8txt.html#ae08edf2a0482a5d008070bbd72580a40">early</a></div><div class="ttdeci">the custom lowered code happens to be but we shouldn t have to custom lower anything This is probably related to&lt; 2 x i64 &gt; ops being so bad LLVM currently generates stack realignment when it is not necessary needed The problem is that we need to know about stack alignment too early</div><div class="ttdef"><b>Definition:</b> <a href="README-SSE_8txt_source.html#l00486">README-SSE.txt:486</a></div></div>
<div class="ttc" id="alib_2Target_2X86_2README_8txt_html_a751e570be9981fc075f53f59e6de3132"><div class="ttname"><a href="lib_2Target_2X86_2README_8txt.html#a751e570be9981fc075f53f59e6de3132">andl</a></div><div class="ttdeci">esp eax movl ecx ecx cvtsi2ss xmm0 andl</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2X86_2README_8txt_source.html#l00302">README.txt:302</a></div></div>
<div class="ttc" id="alib_2CodeGen_2README_8txt_html_a09776db24cf586ec9f1e18f3bae14099"><div class="ttname"><a href="lib_2CodeGen_2README_8txt.html#a09776db24cf586ec9f1e18f3bae14099">BB</a></div><div class="ttdeci">Common register allocation spilling lr str ldr sxth r3 ldr mla r4 can lr mov lr str ldr sxth r3 mla r4 and then merge mul and lr str ldr sxth r3 mla r4 It also increase the likelihood the store may become dead bb27 Successors according to LLVM BB</div><div class="ttdef"><b>Definition:</b> <a href="lib_2CodeGen_2README_8txt_source.html#l00039">README.txt:39</a></div></div>
<div class="ttc" id="alib_2CodeGen_2README_8txt_html_a3fef6e4a83d2d619d46298f2ea45ca6d"><div class="ttname"><a href="lib_2CodeGen_2README_8txt.html#a3fef6e4a83d2d619d46298f2ea45ca6d">problem</a></div><div class="ttdeci">Common register allocation spilling problem</div><div class="ttdef"><b>Definition:</b> <a href="lib_2CodeGen_2README_8txt_source.html#l00005">README.txt:5</a></div></div>
<div class="ttc" id="aREADME-SSE_8txt_html_aab39054d94a440b7b09d0458d26767f3"><div class="ttname"><a href="README-SSE_8txt.html#aab39054d94a440b7b09d0458d26767f3">tmp11</a></div><div class="ttdeci">&lt; i128 &gt;&lt; i128 &gt; tmp11</div><div class="ttdef"><b>Definition:</b> <a href="README-SSE_8txt_source.html#l00792">README-SSE.txt:792</a></div></div>
<div class="ttc" id="alib_2Target_2X86_2README_8txt_html_a96ccf5cfb52d627161ce94e8098cb91a"><div class="ttname"><a href="lib_2Target_2X86_2README_8txt.html#a96ccf5cfb52d627161ce94e8098cb91a">nounwind</a></div><div class="ttdeci">this lets us change the cmpl into a which is and eliminate the shift We compile this i32 i32 i8 zeroext d nounwind</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2X86_2README_8txt_source.html#l00973">README.txt:973</a></div></div>
<div class="ttc" id="aREADME__P9_8txt_html_a1339768ca51595b3ebf5c0e69b80c9e8"><div class="ttname"><a href="README__P9_8txt.html#a1339768ca51595b3ebf5c0e69b80c9e8">lshr</a></div><div class="ttdeci">Vector Shift Left don t map to llvm shl and lshr</div><div class="ttdef"><b>Definition:</b> <a href="README__P9_8txt_source.html#l00118">README_P9.txt:118</a></div></div>
<div class="ttc" id="aREADME-SSE_8txt_html_a7246178f42b1eaef4e9bba10a9f39323"><div class="ttname"><a href="README-SSE_8txt.html#a7246178f42b1eaef4e9bba10a9f39323">spill</a></div><div class="ttdeci">the custom lowered code happens to be but we shouldn t have to custom lower anything This is probably related to&lt; 2 x i64 &gt; ops being so bad LLVM currently generates stack realignment when it is not necessary needed The problem is that we need to know about stack alignment too before RA runs At that point we don t whether there will be vector spill</div><div class="ttdef"><b>Definition:</b> <a href="README-SSE_8txt_source.html#l00489">README-SSE.txt:489</a></div></div>
<div class="ttc" id="anamespaceshuffles_html_a6abf8a645bd24dfb42085db9672ac39a"><div class="ttname"><a href="namespaceshuffles.html#a6abf8a645bd24dfb42085db9672ac39a">shuffles::mask</a></div><div class="ttdeci">auto mask(ShuffFunc S, unsigned Length, OptArgs... args) -&gt; MaskT</div><div class="ttdef"><b>Definition:</b> <a href="HexagonISelDAGToDAGHVX_8cpp_source.html#l00903">HexagonISelDAGToDAGHVX.cpp:903</a></div></div>
<div class="ttc" id="aREADME__P9_8txt_html_afdb2c86c54a7de682961e9b0a42a080d"><div class="ttname"><a href="README__P9_8txt.html#afdb2c86c54a7de682961e9b0a42a080d">f64</a></div><div class="ttdeci">QP Compare Ordered outs ins xscmpudp No builtin are required Or llvm fcmp order unorder compare DP QP Compare builtin are required DP xscmp *dp write to VSX register Use int_ppc_vsx_xscmpeqdp f64</div><div class="ttdef"><b>Definition:</b> <a href="README__P9_8txt_source.html#l00314">README_P9.txt:314</a></div></div>
<div class="ttc" id="alib_2Target_2ARM_2README_8txt_html_a901ce7389ca67dd79b8ab5b53c4a7da8"><div class="ttname"><a href="lib_2Target_2ARM_2README_8txt.html#a901ce7389ca67dd79b8ab5b53c4a7da8">d</a></div><div class="ttdeci">the resulting code requires compare and branches when and if the revised code is with conditional branches instead of More there is a byte word extend before each where there should be only and the condition codes are not remembered when the same two values are compared twice More LSR enhancements i8 and i32 load store addressing modes are identical int int int d</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2ARM_2README_8txt_source.html#l00418">README.txt:418</a></div></div>
<div class="ttc" id="alib_2Target_2README_8txt_html_ab335e668fd33542ea14a2c7b527e64d3"><div class="ttname"><a href="lib_2Target_2README_8txt.html#ab335e668fd33542ea14a2c7b527e64d3">n</a></div><div class="ttdeci">The same transformation can work with an even modulo with the addition of a and shrink the compare RHS by the same amount Unless the target supports that transformation probably isn t worthwhile The transformation can also easily be made to work with non zero equality for n</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2README_8txt_source.html#l00685">README.txt:685</a></div></div>
<div class="ttc" id="aInstructionCombining_8cpp_html_a7d4d7e39548303ef4c1f5a0ed13a9c23"><div class="ttname"><a href="InstructionCombining_8cpp.html#a7d4d7e39548303ef4c1f5a0ed13a9c23">instcombine</a></div><div class="ttdeci">instcombine</div><div class="ttdef"><b>Definition:</b> <a href="InstructionCombining_8cpp_source.html#l04747">InstructionCombining.cpp:4747</a></div></div>
<div class="ttc" id="anamespacellvm_1_1SISrcMods_html_a1d705f3f6f4a6c585d068369ef0f4916af1ceb53a1b47dab205dc19070b47a1a6"><div class="ttname"><a href="namespacellvm_1_1SISrcMods.html#a1d705f3f6f4a6c585d068369ef0f4916af1ceb53a1b47dab205dc19070b47a1a6">llvm::SISrcMods::NEG</a></div><div class="ttdeci">@ NEG</div><div class="ttdef"><b>Definition:</b> <a href="SIDefines_8h_source.html#l00228">SIDefines.h:228</a></div></div>
<div class="ttc" id="aREADME__ALTIVEC_8txt_html_ac2bca51fd633d11e41373896183538f6"><div class="ttname"><a href="README__ALTIVEC_8txt.html#ac2bca51fd633d11e41373896183538f6">registers</a></div><div class="ttdeci">Implement PPCInstrInfo::isLoadFromStackSlot isStoreToStackSlot for vector registers</div><div class="ttdef"><b>Definition:</b> <a href="README__ALTIVEC_8txt_source.html#l00004">README_ALTIVEC.txt:4</a></div></div>
<div class="ttc" id="aREADME-SSE_8txt_html_a1b9bf5045cc095f0c9bc83a9df55ab71"><div class="ttname"><a href="README-SSE_8txt.html#a1b9bf5045cc095f0c9bc83a9df55ab71">tmp19</a></div><div class="ttdeci">&lt; double &gt; tmp19</div><div class="ttdef"><b>Definition:</b> <a href="README-SSE_8txt_source.html#l00789">README-SSE.txt:789</a></div></div>
<div class="ttc" id="aREADME-SSE_8txt_html_a22e7866be85852a21786d1c32d5999a6"><div class="ttname"><a href="README-SSE_8txt.html#a22e7866be85852a21786d1c32d5999a6">model</a></div><div class="ttdeci">This currently compiles esp xmm0 movsd esp eax eax esp ret We should use not the dag combiner This is because dagcombine2 needs to be able to see through the X86ISD::Wrapper which DAGCombine can t really do The code for turning x load into a single vector load is target independent and should be moved to the dag combiner The code for turning x load into a vector load can only handle a direct load from a global or a direct load from the stack It should be generalized to handle any load from where P can be anything The alignment inference code cannot handle loads from globals in static non mode because it doesn t look through the extra dyld stub load If you try vec_align ll without relocation model</div><div class="ttdef"><b>Definition:</b> <a href="README-SSE_8txt_source.html#l00414">README-SSE.txt:414</a></div></div>
<div class="ttc" id="aModuloSchedule_8cpp_html_a106e32122c569cdb42ddf61ecbb0aad1"><div class="ttname"><a href="ModuloSchedule_8cpp.html#a106e32122c569cdb42ddf61ecbb0aad1">test</a></div><div class="ttdeci">modulo schedule test</div><div class="ttdef"><b>Definition:</b> <a href="ModuloSchedule_8cpp_source.html#l02143">ModuloSchedule.cpp:2143</a></div></div>
<div class="ttc" id="alib_2Target_2README_8txt_html_afdf2770d4d0e00f3875afd6e7c61aa9d"><div class="ttname"><a href="lib_2Target_2README_8txt.html#afdf2770d4d0e00f3875afd6e7c61aa9d">X86</a></div><div class="ttdeci">Unrolling by would eliminate the &amp;in both leading to a net reduction in code size The resultant code would then also be suitable for exit value computation We miss a bunch of rotate opportunities on various including etc On X86</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2README_8txt_source.html#l00568">README.txt:568</a></div></div>
<div class="ttc" id="aX86TargetInfo_8h_html"><div class="ttname"><a href="X86TargetInfo_8h.html">X86TargetInfo.h</a></div></div>
<div class="ttc" id="aTargetRegistry_8h_html"><div class="ttname"><a href="TargetRegistry_8h.html">TargetRegistry.h</a></div></div>
<div class="ttc" id="alib_2Target_2PowerPC_2README_8txt_html_aedc03c509f8675fe4598af61b18f5489"><div class="ttname"><a href="lib_2Target_2PowerPC_2README_8txt.html#aedc03c509f8675fe4598af61b18f5489">_foo</a></div><div class="ttdeci">So that _foo</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2PowerPC_2README_8txt_source.html#l00132">README.txt:132</a></div></div>
<div class="ttc" id="aREADME-SSE_8txt_html_aa38a636405ee581795ea6b3f4efdb400"><div class="ttname"><a href="README-SSE_8txt.html#aa38a636405ee581795ea6b3f4efdb400">shrl</a></div><div class="ttdeci">This currently compiles esp xmm0 movsd esp eax shrl</div><div class="ttdef"><b>Definition:</b> <a href="README-SSE_8txt_source.html#l00393">README-SSE.txt:393</a></div></div>
<div class="ttc" id="aREADME__P9_8txt_html_af7618b37d3bd1fe61c87480f31a79b03"><div class="ttname"><a href="README__P9_8txt.html#af7618b37d3bd1fe61c87480f31a79b03">$dst</a></div><div class="ttdeci">So we should use XX3Form_Rcr to implement intrinsic Convert DP outs ins xscvdpsp No builtin are required Round &amp;Convert QP DP(dword[1] is set to zero) No builtin are required Round to Quad Precision because you need to assign rounding mode in instruction Provide builtin(set f128:$vT,(int_ppc_vsx_xsrqpi f128:$vB))(set f128 yields&lt; n x&lt; ty &gt; &gt;&lt; result &gt; yields&lt; ty &gt;&lt; result &gt; No builtin are required Load Store load store see def memrix16 in PPCInstrInfo td Load Store Vector load store outs ins lxsdx set load store with conversion from to outs ins lxsspx set load store outs ins lxsiwzx set PPClfiwzx ins stxsiwx $dst</div><div class="ttdef"><b>Definition:</b> <a href="README__P9_8txt_source.html#l00538">README_P9.txt:538</a></div></div>
<div class="ttc" id="alib_2Target_2PowerPC_2README_8txt_html_a48b7bab6e856fc5a11b20a99e47afb46"><div class="ttname"><a href="lib_2Target_2PowerPC_2README_8txt.html#a48b7bab6e856fc5a11b20a99e47afb46">produce</a></div><div class="ttdeci">bb420 i The CBE manages to produce</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2PowerPC_2README_8txt_source.html#l00049">README.txt:49</a></div></div>
<div class="ttc" id="alib_2CodeGen_2README_8txt_html_a3625bbe909f59184d26d2652d7f5119b"><div class="ttname"><a href="lib_2CodeGen_2README_8txt.html#a3625bbe909f59184d26d2652d7f5119b">libcall</a></div><div class="ttdeci">Common register allocation spilling lr str ldr sxth r3 ldr mla r4 can lr mov lr str ldr sxth r3 mla r4 and then merge mul and lr str ldr sxth r3 mla r4 It also increase the likelihood the store may become dead bb27 Successors according to LLVM ID Predecessors according to mbb&lt; bb27, 0x8b0a7c0 &gt; Note ADDri is not a two address instruction its result reg1037 is an operand of the PHI node in bb76 and its operand reg1039 is the result of the PHI node We should treat it as a two address code and make sure the ADDri is scheduled after any node that reads reg1039 Use info(i.e. register scavenger) to assign it a free register to allow reuse the collector could move the objects and invalidate the derived pointer This is bad enough in the first but safe points can crop up unpredictably **array_addr i32 n y store obj obj **nth_el If the i64 division is lowered to a libcall</div><div class="ttdef"><b>Definition:</b> <a href="lib_2CodeGen_2README_8txt_source.html#l00127">README.txt:127</a></div></div>
<div class="ttc" id="aHexagonConstExtenders_8cpp_html_a43d54efefb64441d158c7ee76c121c7a"><div class="ttname"><a href="HexagonConstExtenders_8cpp.html#a43d54efefb64441d158c7ee76c121c7a">optimization</a></div><div class="ttdeci">hexagon cext Hexagon constant extender optimization</div><div class="ttdef"><b>Definition:</b> <a href="HexagonConstExtenders_8cpp_source.html#l00574">HexagonConstExtenders.cpp:574</a></div></div>
<div class="ttc" id="aMustExecute_8cpp_html_ac00fd2bd5d2febf1f9988294a6c56b33"><div class="ttname"><a href="MustExecute_8cpp.html#ac00fd2bd5d2febf1f9988294a6c56b33">entry</a></div><div class="ttdeci">print Instructions which execute on loop entry</div><div class="ttdef"><b>Definition:</b> <a href="MustExecute_8cpp_source.html#l00346">MustExecute.cpp:346</a></div></div>
<div class="ttc" id="aREADME-SSE_8txt_html_a4b890349dd5d0e72b3c9480da80fcd9c"><div class="ttname"><a href="README-SSE_8txt.html#a4b890349dd5d0e72b3c9480da80fcd9c">operations</a></div><div class="ttdeci">This might compile to this xmm1 xorps xmm0 movss xmm0 ret Now consider if the code caused xmm1 to get spilled This might produce this xmm1 movaps xmm0 movaps xmm1 movss xmm0 ret since the reload is only used by these we could fold it into the producing something like xmm1 movaps xmm0 ret saving two instructions The basic idea is that a reload from a spill if only one byte chunk is bring in zeros the one element instead of elements This can be used to simplify a variety of shuffle operations</div><div class="ttdef"><b>Definition:</b> <a href="README-SSE_8txt_source.html#l00271">README-SSE.txt:271</a></div></div>
<div class="ttc" id="aREADME-SSE_8txt_html_af9692e108cf888d8dbd74e3bc602f08a"><div class="ttname"><a href="README-SSE_8txt.html#af9692e108cf888d8dbd74e3bc602f08a">eax</a></div><div class="ttdeci">This might compile to this xmm1 xorps xmm0 movss xmm0 ret Now consider if the code caused xmm1 to get spilled This might produce this xmm1 movaps xmm0 movaps xmm1 movss xmm0 ret since the reload is only used by these we could fold it into the producing something like xmm1 movaps xmm0 ret saving two instructions The basic idea is that a reload from a spill if only one byte chunk is bring in zeros the one element instead of elements This can be used to simplify a variety of shuffle where the elements are fixed zeros This code generates ugly probably due to costs being off or&lt; 4 x float &gt; eax xmm0 pxor xmm1 movaps xmm2 xmm2 xmm0 movaps eax ret Would it be better to ecx xmm0 xor eax</div><div class="ttdef"><b>Definition:</b> <a href="README-SSE_8txt_source.html#l00303">README-SSE.txt:303</a></div></div>
<div class="ttc" id="alib_2Target_2README_8txt_html_ace6b37d5eaf50e6fd3465513bc022e93"><div class="ttname"><a href="lib_2Target_2README_8txt.html#ace6b37d5eaf50e6fd3465513bc022e93">of</a></div><div class="ttdeci">Add support for conditional and other related patterns Instead of</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2README_8txt_source.html#l00134">README.txt:134</a></div></div>
<div class="ttc" id="aREADME-SSE_8txt_html_ae7022af3b0e34d6d665e97dd6058f713"><div class="ttname"><a href="README-SSE_8txt.html#ae7022af3b0e34d6d665e97dd6058f713">xmm1</a></div><div class="ttdeci">Instead we get xmm1 addss xmm1 xmm2 movhlps xmm0 movaps xmm3 addss xmm1</div><div class="ttdef"><b>Definition:</b> <a href="README-SSE_8txt_source.html#l00038">README-SSE.txt:38</a></div></div>
<div class="ttc" id="aMSA_8txt_html_aa2413c5ed8f7347c0e9c3965f78e1ee7"><div class="ttname"><a href="MSA_8txt.html#aa2413c5ed8f7347c0e9c3965f78e1ee7">cases</a></div><div class="ttdeci">Code Generation Notes for reduce the size of the ISel and reduce repetition in the implementation In a small number of cases</div><div class="ttdef"><b>Definition:</b> <a href="MSA_8txt_source.html#l00006">MSA.txt:6</a></div></div>
<div class="ttc" id="aREADME-SSE_8txt_html_a636047a61c4f9dead2a05cbb3a588ecb"><div class="ttname"><a href="README-SSE_8txt.html#a636047a61c4f9dead2a05cbb3a588ecb">example</a></div><div class="ttdeci">SSE has instructions for doing operations on complex we should pattern match them For example</div><div class="ttdef"><b>Definition:</b> <a href="README-SSE_8txt_source.html#l00023">README-SSE.txt:23</a></div></div>
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Aug 7 2023 10:21:21 for LLVM by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
