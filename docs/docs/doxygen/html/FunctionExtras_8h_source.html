<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>LLVM: include/llvm/ADT/FunctionExtras.h Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">LLVM
   &#160;<span id="projectnumber">17.0.0git</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_d44c64559bbebec7f509842c48db8b23.html">include</a></li><li class="navelem"><a class="el" href="dir_dcde91663b8816e1e2311938ccd8f690.html">llvm</a></li><li class="navelem"><a class="el" href="dir_32453792af2ba70c54e3ccae3a790d1b.html">ADT</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">FunctionExtras.h</div>  </div>
</div><!--header-->
<div class="contents">
<a href="FunctionExtras_8h.html">Go to the documentation of this file.</a><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;<span class="comment">//===- FunctionExtras.h - Function type erasure utilities -------*- C++ -*-===//</span></div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;<span class="comment">//</span></div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;<span class="comment">// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.</span></div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;<span class="comment">// See https://llvm.org/LICENSE.txt for license information.</span></div>
<div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;<span class="comment">// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception</span></div>
<div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;<span class="comment">//</span></div>
<div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;<span class="comment">//===----------------------------------------------------------------------===//</span><span class="comment"></span></div>
<div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;<span class="comment">/// \file</span></div>
<div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;<span class="comment">/// This file provides a collection of function (or more generally, callable)</span></div>
<div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;<span class="comment">/// type erasure utilities supplementing those provided by the standard library</span></div>
<div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;<span class="comment">/// in `&lt;function&gt;`.</span></div>
<div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;<span class="comment">///</span></div>
<div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;<span class="comment">/// It provides `unique_function`, which works like `std::function` but supports</span></div>
<div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;<span class="comment">/// move-only callable objects and const-qualification.</span></div>
<div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;<span class="comment">///</span></div>
<div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160;<span class="comment">/// Future plans:</span></div>
<div class="line"><a name="l00017"></a><span class="lineno">   17</span>&#160;<span class="comment">/// - Add a `function` that provides ref-qualified support, which doesn&#39;t work</span></div>
<div class="line"><a name="l00018"></a><span class="lineno">   18</span>&#160;<span class="comment">///   with `std::function`.</span></div>
<div class="line"><a name="l00019"></a><span class="lineno">   19</span>&#160;<span class="comment">/// - Provide support for specifying multiple signatures to type erase callable</span></div>
<div class="line"><a name="l00020"></a><span class="lineno">   20</span>&#160;<span class="comment">///   objects with an overload set, such as those produced by generic lambdas.</span></div>
<div class="line"><a name="l00021"></a><span class="lineno">   21</span>&#160;<span class="comment">/// - Expand to include a copyable utility that directly replaces std::function</span></div>
<div class="line"><a name="l00022"></a><span class="lineno">   22</span>&#160;<span class="comment">///   but brings the above improvements.</span></div>
<div class="line"><a name="l00023"></a><span class="lineno">   23</span>&#160;<span class="comment">///</span></div>
<div class="line"><a name="l00024"></a><span class="lineno">   24</span>&#160;<span class="comment">/// Note that LLVM&#39;s utilities are greatly simplified by not supporting</span></div>
<div class="line"><a name="l00025"></a><span class="lineno">   25</span>&#160;<span class="comment">/// allocators.</span></div>
<div class="line"><a name="l00026"></a><span class="lineno">   26</span>&#160;<span class="comment">///</span></div>
<div class="line"><a name="l00027"></a><span class="lineno">   27</span>&#160;<span class="comment">/// If the standard library ever begins to provide comparable facilities we can</span></div>
<div class="line"><a name="l00028"></a><span class="lineno">   28</span>&#160;<span class="comment">/// consider switching to those.</span></div>
<div class="line"><a name="l00029"></a><span class="lineno">   29</span>&#160;<span class="comment">///</span></div>
<div class="line"><a name="l00030"></a><span class="lineno">   30</span>&#160;<span class="comment"></span><span class="comment">//===----------------------------------------------------------------------===//</span></div>
<div class="line"><a name="l00031"></a><span class="lineno">   31</span>&#160; </div>
<div class="line"><a name="l00032"></a><span class="lineno">   32</span>&#160;<span class="preprocessor">#ifndef LLVM_ADT_FUNCTIONEXTRAS_H</span></div>
<div class="line"><a name="l00033"></a><span class="lineno">   33</span>&#160;<span class="preprocessor">#define LLVM_ADT_FUNCTIONEXTRAS_H</span></div>
<div class="line"><a name="l00034"></a><span class="lineno">   34</span>&#160; </div>
<div class="line"><a name="l00035"></a><span class="lineno">   35</span>&#160;<span class="preprocessor">#include &quot;<a class="code" href="PointerIntPair_8h.html">llvm/ADT/PointerIntPair.h</a>&quot;</span></div>
<div class="line"><a name="l00036"></a><span class="lineno">   36</span>&#160;<span class="preprocessor">#include &quot;<a class="code" href="PointerUnion_8h.html">llvm/ADT/PointerUnion.h</a>&quot;</span></div>
<div class="line"><a name="l00037"></a><span class="lineno">   37</span>&#160;<span class="preprocessor">#include &quot;<a class="code" href="STLForwardCompat_8h.html">llvm/ADT/STLForwardCompat.h</a>&quot;</span></div>
<div class="line"><a name="l00038"></a><span class="lineno">   38</span>&#160;<span class="preprocessor">#include &quot;<a class="code" href="MemAlloc_8h.html">llvm/Support/MemAlloc.h</a>&quot;</span></div>
<div class="line"><a name="l00039"></a><span class="lineno">   39</span>&#160;<span class="preprocessor">#include &quot;<a class="code" href="type__traits_8h.html">llvm/Support/type_traits.h</a>&quot;</span></div>
<div class="line"><a name="l00040"></a><span class="lineno">   40</span>&#160;<span class="preprocessor">#include &lt;cstring&gt;</span></div>
<div class="line"><a name="l00041"></a><span class="lineno">   41</span>&#160;<span class="preprocessor">#include &lt;memory&gt;</span></div>
<div class="line"><a name="l00042"></a><span class="lineno">   42</span>&#160;<span class="preprocessor">#include &lt;type_traits&gt;</span></div>
<div class="line"><a name="l00043"></a><span class="lineno">   43</span>&#160; </div>
<div class="line"><a name="l00044"></a><span class="lineno">   44</span>&#160;<span class="keyword">namespace </span><a class="code" href="namespacellvm.html">llvm</a> {</div>
<div class="line"><a name="l00045"></a><span class="lineno">   45</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00046"></a><span class="lineno">   46</span>&#160;<span class="comment">/// unique_function is a type-erasing functor similar to std::function.</span></div>
<div class="line"><a name="l00047"></a><span class="lineno">   47</span>&#160;<span class="comment">///</span></div>
<div class="line"><a name="l00048"></a><span class="lineno">   48</span>&#160;<span class="comment">/// It can hold move-only function objects, like lambdas capturing unique_ptrs.</span></div>
<div class="line"><a name="l00049"></a><span class="lineno">   49</span>&#160;<span class="comment">/// Accordingly, it is movable but not copyable.</span></div>
<div class="line"><a name="l00050"></a><span class="lineno">   50</span>&#160;<span class="comment">///</span></div>
<div class="line"><a name="l00051"></a><span class="lineno">   51</span>&#160;<span class="comment">/// It supports const-qualification:</span></div>
<div class="line"><a name="l00052"></a><span class="lineno">   52</span>&#160;<span class="comment">/// - unique_function&lt;int() const&gt; has a const operator().</span></div>
<div class="line"><a name="l00053"></a><span class="lineno">   53</span>&#160;<span class="comment">///   It can only hold functions which themselves have a const operator().</span></div>
<div class="line"><a name="l00054"></a><span class="lineno">   54</span>&#160;<span class="comment">/// - unique_function&lt;int()&gt; has a non-const operator().</span></div>
<div class="line"><a name="l00055"></a><span class="lineno">   55</span>&#160;<span class="comment">///   It can hold functions with a non-const operator(), like mutable lambdas.</span></div>
<div class="line"><a name="l00056"></a><span class="lineno"><a class="line" href="classllvm_1_1unique__function.html">   56</a></span>&#160;<span class="comment"></span><span class="keyword">template</span> &lt;<span class="keyword">typename</span> FunctionT&gt; <span class="keyword">class </span><a class="code" href="classllvm_1_1unique__function.html">unique_function</a>;</div>
<div class="line"><a name="l00057"></a><span class="lineno">   57</span>&#160; </div>
<div class="line"><a name="l00058"></a><span class="lineno">   58</span>&#160;<span class="keyword">namespace </span>detail {</div>
<div class="line"><a name="l00059"></a><span class="lineno">   59</span>&#160; </div>
<div class="line"><a name="l00060"></a><span class="lineno">   60</span>&#160;<span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line"><a name="l00061"></a><span class="lineno">   61</span>&#160;<span class="keyword">using</span> <a class="code" href="namespacellvm_1_1detail.html#a5e379eb0e8afa7d6acbceca9906572ac">EnableIfTrivial</a> =</div>
<div class="line"><a name="l00062"></a><span class="lineno">   62</span>&#160;    std::enable_if_t&lt;llvm::is_trivially_move_constructible&lt;T&gt;::value &amp;&amp;</div>
<div class="line"><a name="l00063"></a><span class="lineno"><a class="line" href="namespacellvm_1_1detail.html#a5e379eb0e8afa7d6acbceca9906572ac">   63</a></span>&#160;                     std::is_trivially_destructible&lt;T&gt;::value&gt;;</div>
<div class="line"><a name="l00064"></a><span class="lineno">   64</span>&#160;<span class="keyword">template</span> &lt;<span class="keyword">typename</span> CallableT, <span class="keyword">typename</span> ThisT&gt;</div>
<div class="line"><a name="l00065"></a><span class="lineno">   65</span>&#160;<span class="keyword">using</span> <a class="code" href="namespacellvm_1_1detail.html#adda4c37ee77c163c1daf9fa242bd9408">EnableUnlessSameType</a> =</div>
<div class="line"><a name="l00066"></a><span class="lineno"><a class="line" href="namespacellvm_1_1detail.html#adda4c37ee77c163c1daf9fa242bd9408">   66</a></span>&#160;    std::enable_if_t&lt;!std::is_same&lt;remove_cvref_t&lt;CallableT&gt;, ThisT&gt;::value&gt;;</div>
<div class="line"><a name="l00067"></a><span class="lineno">   67</span>&#160;<span class="keyword">template</span> &lt;<span class="keyword">typename</span> CallableT, <span class="keyword">typename</span> <a class="code" href="namespacellvm_1_1MipsISD.html#a422daf9aa810935178671306b651d69ba366e1eac31eeb1a1892d62ccfc0c8cf8">Ret</a>, <span class="keyword">typename</span>... Params&gt;</div>
<div class="line"><a name="l00068"></a><span class="lineno">   68</span>&#160;<span class="keyword">using</span> <a class="code" href="namespacellvm_1_1detail.html#a29ac72f534b5279feda1e95d06c4adbe">EnableIfCallable</a> = std::enable_if_t&lt;std::disjunction&lt;</div>
<div class="line"><a name="l00069"></a><span class="lineno">   69</span>&#160;    std::is_void&lt;Ret&gt;,</div>
<div class="line"><a name="l00070"></a><span class="lineno">   70</span>&#160;    std::is_same&lt;decltype(std::declval&lt;CallableT&gt;()(std::declval&lt;Params&gt;()...)),</div>
<div class="line"><a name="l00071"></a><span class="lineno">   71</span>&#160;                 <a class="code" href="namespacellvm_1_1MipsISD.html#a422daf9aa810935178671306b651d69ba366e1eac31eeb1a1892d62ccfc0c8cf8">Ret</a>&gt;,</div>
<div class="line"><a name="l00072"></a><span class="lineno">   72</span>&#160;    std::is_same&lt;<span class="keyword">const</span> decltype(std::declval&lt;CallableT&gt;()(</div>
<div class="line"><a name="l00073"></a><span class="lineno">   73</span>&#160;                     std::declval&lt;Params&gt;()...)),</div>
<div class="line"><a name="l00074"></a><span class="lineno">   74</span>&#160;                 <a class="code" href="namespacellvm_1_1MipsISD.html#a422daf9aa810935178671306b651d69ba366e1eac31eeb1a1892d62ccfc0c8cf8">Ret</a>&gt;,</div>
<div class="line"><a name="l00075"></a><span class="lineno">   75</span>&#160;    std::is_convertible&lt;decltype(std::declval&lt;CallableT&gt;()(</div>
<div class="line"><a name="l00076"></a><span class="lineno">   76</span>&#160;                            std::declval&lt;Params&gt;()...)),</div>
<div class="line"><a name="l00077"></a><span class="lineno"><a class="line" href="namespacellvm_1_1detail.html#a29ac72f534b5279feda1e95d06c4adbe">   77</a></span>&#160;                        <a class="code" href="namespacellvm_1_1MipsISD.html#a422daf9aa810935178671306b651d69ba366e1eac31eeb1a1892d62ccfc0c8cf8">Ret</a>&gt;&gt;::value&gt;;</div>
<div class="line"><a name="l00078"></a><span class="lineno">   78</span>&#160; </div>
<div class="line"><a name="l00079"></a><span class="lineno"><a class="line" href="classllvm_1_1detail_1_1UniqueFunctionBase.html">   79</a></span>&#160;<span class="keyword">template</span> &lt;<span class="keyword">typename</span> ReturnT, <span class="keyword">typename</span>... ParamTs&gt; <span class="keyword">class </span><a class="code" href="classllvm_1_1detail_1_1UniqueFunctionBase.html">UniqueFunctionBase</a> {</div>
<div class="line"><a name="l00080"></a><span class="lineno">   80</span>&#160;<span class="keyword">protected</span>:</div>
<div class="line"><a name="l00081"></a><span class="lineno"><a class="line" href="classllvm_1_1detail_1_1UniqueFunctionBase.html#afc8bea8bffe6f12ac46e3a44352f75eb">   81</a></span>&#160;  <span class="keyword">static</span> constexpr <span class="keywordtype">size_t</span> <a class="code" href="classllvm_1_1detail_1_1UniqueFunctionBase.html#afc8bea8bffe6f12ac46e3a44352f75eb">InlineStorageSize</a> = <span class="keyword">sizeof</span>(<span class="keywordtype">void</span> *) * 3;</div>
<div class="line"><a name="l00082"></a><span class="lineno">   82</span>&#160; </div>
<div class="line"><a name="l00083"></a><span class="lineno">   83</span>&#160;  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">class</span> = <span class="keywordtype">void</span>&gt;</div>
<div class="line"><a name="l00084"></a><span class="lineno"><a class="line" href="structllvm_1_1detail_1_1UniqueFunctionBase_1_1IsSizeLessThanThresholdT.html">   84</a></span>&#160;  <span class="keyword">struct </span><a class="code" href="structllvm_1_1detail_1_1UniqueFunctionBase_1_1IsSizeLessThanThresholdT.html">IsSizeLessThanThresholdT</a> : std::false_type {};</div>
<div class="line"><a name="l00085"></a><span class="lineno">   85</span>&#160; </div>
<div class="line"><a name="l00086"></a><span class="lineno">   86</span>&#160;  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line"><a name="l00087"></a><span class="lineno"><a class="line" href="classllvm_1_1detail_1_1UniqueFunctionBase.html#a07d0691a7b2fa04f00be55fca6cbade5">   87</a></span>&#160;  <span class="keyword">struct </span>IsSizeLessThanThresholdT&lt;</div>
<div class="line"><a name="l00088"></a><span class="lineno">   88</span>&#160;      <a class="code" href="Mips16ISelLowering_8cpp.html#a0acb682b8260ab1c60b918599864e2e5">T</a>, <a class="code" href="namespacestd.html">std</a>::enable_if_t&lt;sizeof(T) &lt;= 2 * sizeof(void *)&gt;&gt; : std::true_type {};</div>
<div class="line"><a name="l00089"></a><span class="lineno">   89</span>&#160; </div>
<div class="line"><a name="l00090"></a><span class="lineno">   90</span>&#160;  <span class="comment">// Provide a type function to map parameters that won&#39;t observe extra copies</span></div>
<div class="line"><a name="l00091"></a><span class="lineno">   91</span>&#160;  <span class="comment">// or moves and which are small enough to likely pass in register to values</span></div>
<div class="line"><a name="l00092"></a><span class="lineno">   92</span>&#160;  <span class="comment">// and all other types to l-value reference types. We use this to compute the</span></div>
<div class="line"><a name="l00093"></a><span class="lineno">   93</span>&#160;  <span class="comment">// types used in our erased call utility to minimize copies and moves unless</span></div>
<div class="line"><a name="l00094"></a><span class="lineno">   94</span>&#160;  <span class="comment">// doing so would force things unnecessarily into memory.</span></div>
<div class="line"><a name="l00095"></a><span class="lineno">   95</span>&#160;  <span class="comment">//</span></div>
<div class="line"><a name="l00096"></a><span class="lineno">   96</span>&#160;  <span class="comment">// The heuristic used is related to common ABI register passing conventions.</span></div>
<div class="line"><a name="l00097"></a><span class="lineno">   97</span>&#160;  <span class="comment">// It doesn&#39;t have to be exact though, and in one way it is more strict</span></div>
<div class="line"><a name="l00098"></a><span class="lineno">   98</span>&#160;  <span class="comment">// because we want to still be able to observe either moves *or* copies.</span></div>
<div class="line"><a name="l00099"></a><span class="lineno">   99</span>&#160;  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">struct </span>AdjustedParamTBase {</div>
<div class="line"><a name="l00100"></a><span class="lineno">  100</span>&#160;    static_assert(!std::is_reference&lt;T&gt;::value,</div>
<div class="line"><a name="l00101"></a><span class="lineno">  101</span>&#160;                  <span class="stringliteral">&quot;references should be handled by template specialization&quot;</span>);</div>
<div class="line"><a name="l00102"></a><span class="lineno">  102</span>&#160;    <span class="keyword">using</span> <a class="code" href="README-X86-64_8txt.html#aac3add0badd5c39bebc02df0b5d9bdcf">type</a> = std::conditional_t&lt;</div>
<div class="line"><a name="l00103"></a><span class="lineno">  103</span>&#160;        <a class="code" href="structllvm_1_1is__trivially__copy__constructible.html">llvm::is_trivially_copy_constructible&lt;T&gt;::value</a> &amp;&amp;</div>
<div class="line"><a name="l00104"></a><span class="lineno">  104</span>&#160;            <a class="code" href="structllvm_1_1is__trivially__move__constructible.html">llvm::is_trivially_move_constructible&lt;T&gt;::value</a> &amp;&amp;</div>
<div class="line"><a name="l00105"></a><span class="lineno">  105</span>&#160;            IsSizeLessThanThresholdT&lt;T&gt;::value,</div>
<div class="line"><a name="l00106"></a><span class="lineno">  106</span>&#160;        <a class="code" href="Mips16ISelLowering_8cpp.html#a0acb682b8260ab1c60b918599864e2e5">T</a>, <a class="code" href="Mips16ISelLowering_8cpp.html#a0acb682b8260ab1c60b918599864e2e5">T</a> &amp;&gt;;</div>
<div class="line"><a name="l00107"></a><span class="lineno">  107</span>&#160;  };</div>
<div class="line"><a name="l00108"></a><span class="lineno">  108</span>&#160; </div>
<div class="line"><a name="l00109"></a><span class="lineno">  109</span>&#160;  <span class="comment">// This specialization ensures that &#39;AdjustedParam&lt;V&lt;T&gt;&amp;&gt;&#39; or</span></div>
<div class="line"><a name="l00110"></a><span class="lineno">  110</span>&#160;  <span class="comment">// &#39;AdjustedParam&lt;V&lt;T&gt;&amp;&amp;&gt;&#39; does not trigger a compile-time error when &#39;T&#39; is</span></div>
<div class="line"><a name="l00111"></a><span class="lineno">  111</span>&#160;  <span class="comment">// an incomplete type and V a templated type.</span></div>
<div class="line"><a name="l00112"></a><span class="lineno">  112</span>&#160;  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">struct </span>AdjustedParamTBase&lt;<a class="code" href="Mips16ISelLowering_8cpp.html#a0acb682b8260ab1c60b918599864e2e5">T</a> &amp;&gt; { <span class="keyword">using</span> <a class="code" href="README-X86-64_8txt.html#aac3add0badd5c39bebc02df0b5d9bdcf">type</a> = <a class="code" href="Mips16ISelLowering_8cpp.html#a0acb682b8260ab1c60b918599864e2e5">T</a> &amp;; };</div>
<div class="line"><a name="l00113"></a><span class="lineno">  113</span>&#160;  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">struct </span>AdjustedParamTBase&lt;<a class="code" href="Mips16ISelLowering_8cpp.html#a0acb682b8260ab1c60b918599864e2e5">T</a> &amp;&amp;&gt; { <span class="keyword">using</span> <a class="code" href="README-X86-64_8txt.html#aac3add0badd5c39bebc02df0b5d9bdcf">type</a> = <a class="code" href="Mips16ISelLowering_8cpp.html#a0acb682b8260ab1c60b918599864e2e5">T</a> &amp;; };</div>
<div class="line"><a name="l00114"></a><span class="lineno">  114</span>&#160; </div>
<div class="line"><a name="l00115"></a><span class="lineno">  115</span>&#160;  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line"><a name="l00116"></a><span class="lineno">  116</span>&#160;  <span class="keyword">using</span> AdjustedParamT = <span class="keyword">typename</span> <a class="code" href="README-X86-64_8txt.html#aac3add0badd5c39bebc02df0b5d9bdcf">AdjustedParamTBase&lt;T&gt;::type</a>;</div>
<div class="line"><a name="l00117"></a><span class="lineno">  117</span>&#160; </div>
<div class="line"><a name="l00118"></a><span class="lineno">  118</span>&#160;  <span class="comment">// The type of the erased function pointer we use as a callback to dispatch to</span></div>
<div class="line"><a name="l00119"></a><span class="lineno">  119</span>&#160;  <span class="comment">// the stored callable when it is trivial to move and destroy.</span></div>
<div class="line"><a name="l00120"></a><span class="lineno">  120</span>&#160;  <span class="keyword">using</span> CallPtrT = ReturnT (*)(<span class="keywordtype">void</span> *CallableAddr,</div>
<div class="line"><a name="l00121"></a><span class="lineno">  121</span>&#160;                               AdjustedParamT&lt;ParamTs&gt;... Params);</div>
<div class="line"><a name="l00122"></a><span class="lineno">  122</span>&#160;  <span class="keyword">using</span> MovePtrT = void (*)(<span class="keywordtype">void</span> *LHSCallableAddr, <span class="keywordtype">void</span> *RHSCallableAddr);</div>
<div class="line"><a name="l00123"></a><span class="lineno">  123</span>&#160;  <span class="keyword">using</span> DestroyPtrT = void (*)(<span class="keywordtype">void</span> *CallableAddr);</div>
<div class="line"><a name="l00124"></a><span class="lineno">  124</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00125"></a><span class="lineno">  125</span>&#160;<span class="comment">  /// A struct to hold a single trivial callback with sufficient alignment for</span></div>
<div class="line"><a name="l00126"></a><span class="lineno">  126</span>&#160;<span class="comment">  /// our bitpacking.</span></div>
<div class="line"><a name="l00127"></a><span class="lineno">  127</span>&#160;<span class="comment"></span>  <span class="keyword">struct </span><span class="keyword">alignas</span>(8) TrivialCallback {</div>
<div class="line"><a name="l00128"></a><span class="lineno">  128</span>&#160;    CallPtrT <a class="code" href="classllvm_1_1detail_1_1UniqueFunctionBase.html#a07d0691a7b2fa04f00be55fca6cbade5">CallPtr</a>;</div>
<div class="line"><a name="l00129"></a><span class="lineno">  129</span>&#160;  };</div>
<div class="line"><a name="l00130"></a><span class="lineno">  130</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00131"></a><span class="lineno">  131</span>&#160;<span class="comment">  /// A struct we use to aggregate three callbacks when we need full set of</span></div>
<div class="line"><a name="l00132"></a><span class="lineno">  132</span>&#160;<span class="comment">  /// operations.</span></div>
<div class="line"><a name="l00133"></a><span class="lineno">  133</span>&#160;<span class="comment"></span>  <span class="keyword">struct </span><span class="keyword">alignas</span>(8) NonTrivialCallbacks {</div>
<div class="line"><a name="l00134"></a><span class="lineno">  134</span>&#160;    CallPtrT <a class="code" href="classllvm_1_1detail_1_1UniqueFunctionBase.html#a07d0691a7b2fa04f00be55fca6cbade5">CallPtr</a>;</div>
<div class="line"><a name="l00135"></a><span class="lineno">  135</span>&#160;    MovePtrT MovePtr;</div>
<div class="line"><a name="l00136"></a><span class="lineno">  136</span>&#160;    DestroyPtrT DestroyPtr;</div>
<div class="line"><a name="l00137"></a><span class="lineno">  137</span>&#160;  };</div>
<div class="line"><a name="l00138"></a><span class="lineno">  138</span>&#160; </div>
<div class="line"><a name="l00139"></a><span class="lineno">  139</span>&#160;  <span class="comment">// Create a pointer union between either a pointer to a static trivial call</span></div>
<div class="line"><a name="l00140"></a><span class="lineno">  140</span>&#160;  <span class="comment">// pointer in a struct or a pointer to a static struct of the call, move, and</span></div>
<div class="line"><a name="l00141"></a><span class="lineno">  141</span>&#160;  <span class="comment">// destroy pointers.</span></div>
<div class="line"><a name="l00142"></a><span class="lineno">  142</span>&#160;  <span class="keyword">using</span> CallbackPointerUnionT =</div>
<div class="line"><a name="l00143"></a><span class="lineno">  143</span>&#160;      PointerUnion&lt;TrivialCallback *, NonTrivialCallbacks *&gt;;</div>
<div class="line"><a name="l00144"></a><span class="lineno">  144</span>&#160; </div>
<div class="line"><a name="l00145"></a><span class="lineno">  145</span>&#160;  <span class="comment">// The main storage buffer. This will either have a pointer to out-of-line</span></div>
<div class="line"><a name="l00146"></a><span class="lineno">  146</span>&#160;  <span class="comment">// storage or an inline buffer storing the callable.</span></div>
<div class="line"><a name="l00147"></a><span class="lineno">  147</span>&#160;  <span class="keyword">union </span>StorageUnionT {</div>
<div class="line"><a name="l00148"></a><span class="lineno">  148</span>&#160;    <span class="comment">// For out-of-line storage we keep a pointer to the underlying storage and</span></div>
<div class="line"><a name="l00149"></a><span class="lineno">  149</span>&#160;    <span class="comment">// the size. This is enough to deallocate the memory.</span></div>
<div class="line"><a name="l00150"></a><span class="lineno">  150</span>&#160;    <span class="keyword">struct </span>OutOfLineStorageT {</div>
<div class="line"><a name="l00151"></a><span class="lineno">  151</span>&#160;      <span class="keywordtype">void</span> *StoragePtr;</div>
<div class="line"><a name="l00152"></a><span class="lineno">  152</span>&#160;      <span class="keywordtype">size_t</span> <a class="code" href="namespacellvm_1_1Check.html#a067ee17412e800f03802fa9517685732a3450a9712780ac26b071f9da4288a396">Size</a>;</div>
<div class="line"><a name="l00153"></a><span class="lineno">  153</span>&#160;      <span class="keywordtype">size_t</span> Alignment;</div>
<div class="line"><a name="l00154"></a><span class="lineno">  154</span>&#160;    } OutOfLineStorage;</div>
<div class="line"><a name="l00155"></a><span class="lineno">  155</span>&#160;    static_assert(</div>
<div class="line"><a name="l00156"></a><span class="lineno">  156</span>&#160;        <span class="keyword">sizeof</span>(OutOfLineStorageT) &lt;= <a class="code" href="classllvm_1_1detail_1_1UniqueFunctionBase.html#afc8bea8bffe6f12ac46e3a44352f75eb">InlineStorageSize</a>,</div>
<div class="line"><a name="l00157"></a><span class="lineno">  157</span>&#160;        <span class="stringliteral">&quot;Should always use all of the out-of-line storage for inline storage!&quot;</span>);</div>
<div class="line"><a name="l00158"></a><span class="lineno">  158</span>&#160; </div>
<div class="line"><a name="l00159"></a><span class="lineno">  159</span>&#160;    <span class="comment">// For in-line storage, we just provide an aligned character buffer. We</span></div>
<div class="line"><a name="l00160"></a><span class="lineno">  160</span>&#160;    <span class="comment">// provide three pointers worth of storage here.</span></div>
<div class="line"><a name="l00161"></a><span class="lineno">  161</span>&#160;    <span class="comment">// This is mutable as an inlined `const unique_function&lt;void() const&gt;` may</span></div>
<div class="line"><a name="l00162"></a><span class="lineno">  162</span>&#160;    <span class="comment">// still modify its own mutable members.</span></div>
<div class="line"><a name="l00163"></a><span class="lineno">  163</span>&#160;    <span class="keyword">mutable</span> std::aligned_storage_t&lt;<a class="code" href="classllvm_1_1detail_1_1UniqueFunctionBase.html#afc8bea8bffe6f12ac46e3a44352f75eb">InlineStorageSize</a>, <span class="keyword">alignof</span>(<span class="keywordtype">void</span> *)&gt;</div>
<div class="line"><a name="l00164"></a><span class="lineno">  164</span>&#160;        InlineStorage;</div>
<div class="line"><a name="l00165"></a><span class="lineno">  165</span>&#160;  } StorageUnion;</div>
<div class="line"><a name="l00166"></a><span class="lineno">  166</span>&#160; </div>
<div class="line"><a name="l00167"></a><span class="lineno">  167</span>&#160;  <span class="comment">// A compressed pointer to either our dispatching callback or our table of</span></div>
<div class="line"><a name="l00168"></a><span class="lineno">  168</span>&#160;  <span class="comment">// dispatching callbacks and the flag for whether the callable itself is</span></div>
<div class="line"><a name="l00169"></a><span class="lineno">  169</span>&#160;  <span class="comment">// stored inline or not.</span></div>
<div class="line"><a name="l00170"></a><span class="lineno">  170</span>&#160;  PointerIntPair&lt;CallbackPointerUnionT, 1, bool&gt; CallbackAndInlineFlag;</div>
<div class="line"><a name="l00171"></a><span class="lineno">  171</span>&#160; </div>
<div class="line"><a name="l00172"></a><span class="lineno">  172</span>&#160;  <span class="keywordtype">bool</span> isInlineStorage()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> CallbackAndInlineFlag.getInt(); }</div>
<div class="line"><a name="l00173"></a><span class="lineno">  173</span>&#160; </div>
<div class="line"><a name="l00174"></a><span class="lineno">  174</span>&#160;  <span class="keywordtype">bool</span> isTrivialCallback()<span class="keyword"> const </span>{</div>
<div class="line"><a name="l00175"></a><span class="lineno">  175</span>&#160;    <span class="keywordflow">return</span> CallbackAndInlineFlag.getPointer().template is&lt;TrivialCallback *&gt;();</div>
<div class="line"><a name="l00176"></a><span class="lineno">  176</span>&#160;  }</div>
<div class="line"><a name="l00177"></a><span class="lineno">  177</span>&#160; </div>
<div class="line"><a name="l00178"></a><span class="lineno">  178</span>&#160;  CallPtrT getTrivialCallback()<span class="keyword"> const </span>{</div>
<div class="line"><a name="l00179"></a><span class="lineno">  179</span>&#160;    <span class="keywordflow">return</span> CallbackAndInlineFlag.getPointer().template get&lt;TrivialCallback *&gt;()-&gt;CallPtr;</div>
<div class="line"><a name="l00180"></a><span class="lineno">  180</span>&#160;  }</div>
<div class="line"><a name="l00181"></a><span class="lineno">  181</span>&#160; </div>
<div class="line"><a name="l00182"></a><span class="lineno"><a class="line" href="classllvm_1_1detail_1_1UniqueFunctionBase.html#a33790c30f9d9cc8b0974d22eb6648ec1">  182</a></span>&#160;  NonTrivialCallbacks *<a class="code" href="classllvm_1_1detail_1_1UniqueFunctionBase.html#a33790c30f9d9cc8b0974d22eb6648ec1">getNonTrivialCallbacks</a>()<span class="keyword"> const </span>{</div>
<div class="line"><a name="l00183"></a><span class="lineno">  183</span>&#160;    <span class="keywordflow">return</span> CallbackAndInlineFlag.getPointer()</div>
<div class="line"><a name="l00184"></a><span class="lineno">  184</span>&#160;        .template get&lt;NonTrivialCallbacks *&gt;();</div>
<div class="line"><a name="l00185"></a><span class="lineno">  185</span>&#160;  }</div>
<div class="line"><a name="l00186"></a><span class="lineno">  186</span>&#160; </div>
<div class="line"><a name="l00187"></a><span class="lineno"><a class="line" href="classllvm_1_1detail_1_1UniqueFunctionBase.html#a0166f36c59bf23f7a969796f3b160120">  187</a></span>&#160;  CallPtrT <a class="code" href="classllvm_1_1detail_1_1UniqueFunctionBase.html#a0166f36c59bf23f7a969796f3b160120">getCallPtr</a>()<span class="keyword"> const </span>{</div>
<div class="line"><a name="l00188"></a><span class="lineno">  188</span>&#160;    <span class="keywordflow">return</span> isTrivialCallback() ? getTrivialCallback()</div>
<div class="line"><a name="l00189"></a><span class="lineno">  189</span>&#160;                               : <a class="code" href="classllvm_1_1detail_1_1UniqueFunctionBase.html#a33790c30f9d9cc8b0974d22eb6648ec1">getNonTrivialCallbacks</a>()-&gt;CallPtr;</div>
<div class="line"><a name="l00190"></a><span class="lineno">  190</span>&#160;  }</div>
<div class="line"><a name="l00191"></a><span class="lineno">  191</span>&#160; </div>
<div class="line"><a name="l00192"></a><span class="lineno">  192</span>&#160;  <span class="comment">// These three functions are only const in the narrow sense. They return</span></div>
<div class="line"><a name="l00193"></a><span class="lineno">  193</span>&#160;  <span class="comment">// mutable pointers to function state.</span></div>
<div class="line"><a name="l00194"></a><span class="lineno">  194</span>&#160;  <span class="comment">// This allows unique_function&lt;T const&gt;::operator() to be const, even if the</span></div>
<div class="line"><a name="l00195"></a><span class="lineno">  195</span>&#160;  <span class="comment">// underlying functor may be internally mutable.</span></div>
<div class="line"><a name="l00196"></a><span class="lineno">  196</span>&#160;  <span class="comment">//</span></div>
<div class="line"><a name="l00197"></a><span class="lineno">  197</span>&#160;  <span class="comment">// const callers must ensure they&#39;re only used in const-correct ways.</span></div>
<div class="line"><a name="l00198"></a><span class="lineno"><a class="line" href="classllvm_1_1detail_1_1UniqueFunctionBase.html#a4de3d0fbcb5bf9bec73755b1b0e4810f">  198</a></span>&#160;  <span class="keywordtype">void</span> *<a class="code" href="classllvm_1_1detail_1_1UniqueFunctionBase.html#a4de3d0fbcb5bf9bec73755b1b0e4810f">getCalleePtr</a>()<span class="keyword"> const </span>{</div>
<div class="line"><a name="l00199"></a><span class="lineno">  199</span>&#160;    <span class="keywordflow">return</span> isInlineStorage() ? <a class="code" href="classllvm_1_1detail_1_1UniqueFunctionBase.html#a3587453289f2ead89a5b8b547e4c0810">getInlineStorage</a>() : <a class="code" href="classllvm_1_1detail_1_1UniqueFunctionBase.html#afc6639147fd23b870c9ed6e097176cac">getOutOfLineStorage</a>();</div>
<div class="line"><a name="l00200"></a><span class="lineno">  200</span>&#160;  }</div>
<div class="line"><a name="l00201"></a><span class="lineno"><a class="line" href="classllvm_1_1detail_1_1UniqueFunctionBase.html#a3587453289f2ead89a5b8b547e4c0810">  201</a></span>&#160;  <span class="keywordtype">void</span> *<a class="code" href="classllvm_1_1detail_1_1UniqueFunctionBase.html#a3587453289f2ead89a5b8b547e4c0810">getInlineStorage</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> &amp;StorageUnion.InlineStorage; }</div>
<div class="line"><a name="l00202"></a><span class="lineno"><a class="line" href="classllvm_1_1detail_1_1UniqueFunctionBase.html#afc6639147fd23b870c9ed6e097176cac">  202</a></span>&#160;  <span class="keywordtype">void</span> *<a class="code" href="classllvm_1_1detail_1_1UniqueFunctionBase.html#afc6639147fd23b870c9ed6e097176cac">getOutOfLineStorage</a>()<span class="keyword"> const </span>{</div>
<div class="line"><a name="l00203"></a><span class="lineno">  203</span>&#160;    <span class="keywordflow">return</span> StorageUnion.OutOfLineStorage.StoragePtr;</div>
<div class="line"><a name="l00204"></a><span class="lineno">  204</span>&#160;  }</div>
<div class="line"><a name="l00205"></a><span class="lineno">  205</span>&#160; </div>
<div class="line"><a name="l00206"></a><span class="lineno"><a class="line" href="classllvm_1_1detail_1_1UniqueFunctionBase.html#aa45b5add274f23456e6abc4451798225">  206</a></span>&#160;  <span class="keywordtype">size_t</span> <a class="code" href="classllvm_1_1detail_1_1UniqueFunctionBase.html#aa45b5add274f23456e6abc4451798225">getOutOfLineStorageSize</a>()<span class="keyword"> const </span>{</div>
<div class="line"><a name="l00207"></a><span class="lineno">  207</span>&#160;    <span class="keywordflow">return</span> StorageUnion.OutOfLineStorage.Size;</div>
<div class="line"><a name="l00208"></a><span class="lineno">  208</span>&#160;  }</div>
<div class="line"><a name="l00209"></a><span class="lineno"><a class="line" href="classllvm_1_1detail_1_1UniqueFunctionBase.html#ac2ee20db0af7f93b577dddb3e9637478">  209</a></span>&#160;  <span class="keywordtype">size_t</span> <a class="code" href="classllvm_1_1detail_1_1UniqueFunctionBase.html#ac2ee20db0af7f93b577dddb3e9637478">getOutOfLineStorageAlignment</a>()<span class="keyword"> const </span>{</div>
<div class="line"><a name="l00210"></a><span class="lineno">  210</span>&#160;    <span class="keywordflow">return</span> StorageUnion.OutOfLineStorage.Alignment;</div>
<div class="line"><a name="l00211"></a><span class="lineno">  211</span>&#160;  }</div>
<div class="line"><a name="l00212"></a><span class="lineno">  212</span>&#160; </div>
<div class="line"><a name="l00213"></a><span class="lineno"><a class="line" href="classllvm_1_1detail_1_1UniqueFunctionBase.html#a3f042ddd5a6cb8e0cee6575743d53ef7">  213</a></span>&#160;  <span class="keywordtype">void</span> <a class="code" href="classllvm_1_1detail_1_1UniqueFunctionBase.html#a3f042ddd5a6cb8e0cee6575743d53ef7">setOutOfLineStorage</a>(<span class="keywordtype">void</span> *<a class="code" href="TargetLibraryInfo_8cpp.html#aca185e6d0e9f423dbb24440206454872a11dbf501abf829b3ab7049c2d3a8a053">Ptr</a>, <span class="keywordtype">size_t</span> Size, <span class="keywordtype">size_t</span> Alignment) {</div>
<div class="line"><a name="l00214"></a><span class="lineno">  214</span>&#160;    StorageUnion.OutOfLineStorage = {<a class="code" href="TargetLibraryInfo_8cpp.html#aca185e6d0e9f423dbb24440206454872a11dbf501abf829b3ab7049c2d3a8a053">Ptr</a>, Size, Alignment};</div>
<div class="line"><a name="l00215"></a><span class="lineno">  215</span>&#160;  }</div>
<div class="line"><a name="l00216"></a><span class="lineno">  216</span>&#160; </div>
<div class="line"><a name="l00217"></a><span class="lineno">  217</span>&#160;  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> CalledAsT&gt;</div>
<div class="line"><a name="l00218"></a><span class="lineno"><a class="line" href="classllvm_1_1detail_1_1UniqueFunctionBase.html#aae031d43fe520ab13f26ed4e64d322fc">  218</a></span>&#160;  <span class="keyword">static</span> ReturnT <a class="code" href="classllvm_1_1detail_1_1UniqueFunctionBase.html#aae031d43fe520ab13f26ed4e64d322fc">CallImpl</a>(<span class="keywordtype">void</span> *CallableAddr,</div>
<div class="line"><a name="l00219"></a><span class="lineno">  219</span>&#160;                          AdjustedParamT&lt;ParamTs&gt;... Params) {</div>
<div class="line"><a name="l00220"></a><span class="lineno">  220</span>&#160;    <span class="keyword">auto</span> &amp;Func = *<span class="keyword">reinterpret_cast&lt;</span>CalledAsT *<span class="keyword">&gt;</span>(CallableAddr);</div>
<div class="line"><a name="l00221"></a><span class="lineno">  221</span>&#160;    <span class="keywordflow">return</span> Func(std::forward&lt;ParamTs&gt;(Params)...);</div>
<div class="line"><a name="l00222"></a><span class="lineno">  222</span>&#160;  }</div>
<div class="line"><a name="l00223"></a><span class="lineno">  223</span>&#160; </div>
<div class="line"><a name="l00224"></a><span class="lineno">  224</span>&#160;  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> CallableT&gt;</div>
<div class="line"><a name="l00225"></a><span class="lineno"><a class="line" href="classllvm_1_1detail_1_1UniqueFunctionBase.html#a7d9ae43014e0a34731a02793bae511d2">  225</a></span>&#160;  <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="classllvm_1_1detail_1_1UniqueFunctionBase.html#a7d9ae43014e0a34731a02793bae511d2">MoveImpl</a>(<span class="keywordtype">void</span> *LHSCallableAddr, <span class="keywordtype">void</span> *RHSCallableAddr) noexcept {</div>
<div class="line"><a name="l00226"></a><span class="lineno">  226</span>&#160;    <span class="keyword">new</span> (LHSCallableAddr)</div>
<div class="line"><a name="l00227"></a><span class="lineno">  227</span>&#160;        CallableT(<a class="code" href="lib_2Target_2ARM_2README_8txt.html#ad3a99906764c35b2694ae90fa57744a5">std::move</a>(*<span class="keyword">reinterpret_cast&lt;</span>CallableT *<span class="keyword">&gt;</span>(RHSCallableAddr)));</div>
<div class="line"><a name="l00228"></a><span class="lineno">  228</span>&#160;  }</div>
<div class="line"><a name="l00229"></a><span class="lineno">  229</span>&#160; </div>
<div class="line"><a name="l00230"></a><span class="lineno">  230</span>&#160;  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> CallableT&gt;</div>
<div class="line"><a name="l00231"></a><span class="lineno"><a class="line" href="classllvm_1_1detail_1_1UniqueFunctionBase.html#a849a2dcfcd3f773ce640d6a1c1df3f5f">  231</a></span>&#160;  <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="classllvm_1_1detail_1_1UniqueFunctionBase.html#a849a2dcfcd3f773ce640d6a1c1df3f5f">DestroyImpl</a>(<span class="keywordtype">void</span> *CallableAddr) noexcept {</div>
<div class="line"><a name="l00232"></a><span class="lineno">  232</span>&#160;    <span class="keyword">reinterpret_cast&lt;</span>CallableT *<span class="keyword">&gt;</span>(CallableAddr)-&gt;~CallableT();</div>
<div class="line"><a name="l00233"></a><span class="lineno">  233</span>&#160;  }</div>
<div class="line"><a name="l00234"></a><span class="lineno">  234</span>&#160; </div>
<div class="line"><a name="l00235"></a><span class="lineno">  235</span>&#160;  <span class="comment">// The pointers to call/move/destroy functions are determined for each</span></div>
<div class="line"><a name="l00236"></a><span class="lineno">  236</span>&#160;  <span class="comment">// callable type (and called-as type, which determines the overload chosen).</span></div>
<div class="line"><a name="l00237"></a><span class="lineno">  237</span>&#160;  <span class="comment">// (definitions are out-of-line).</span></div>
<div class="line"><a name="l00238"></a><span class="lineno">  238</span>&#160; </div>
<div class="line"><a name="l00239"></a><span class="lineno">  239</span>&#160;  <span class="comment">// By default, we need an object that contains all the different</span></div>
<div class="line"><a name="l00240"></a><span class="lineno">  240</span>&#160;  <span class="comment">// type erased behaviors needed. Create a static instance of the struct type</span></div>
<div class="line"><a name="l00241"></a><span class="lineno">  241</span>&#160;  <span class="comment">// here and each instance will contain a pointer to it.</span></div>
<div class="line"><a name="l00242"></a><span class="lineno">  242</span>&#160;  <span class="comment">// Wrap in a struct to avoid https://gcc.gnu.org/PR71954</span></div>
<div class="line"><a name="l00243"></a><span class="lineno">  243</span>&#160;  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> CallableT, <span class="keyword">typename</span> CalledAs, <span class="keyword">typename</span> Enable = <span class="keywordtype">void</span>&gt;</div>
<div class="line"><a name="l00244"></a><span class="lineno"><a class="line" href="structllvm_1_1detail_1_1UniqueFunctionBase_1_1CallbacksHolder.html">  244</a></span>&#160;  <span class="keyword">struct </span><a class="code" href="structllvm_1_1detail_1_1UniqueFunctionBase_1_1CallbacksHolder.html">CallbacksHolder</a> {</div>
<div class="line"><a name="l00245"></a><span class="lineno"><a class="line" href="structllvm_1_1detail_1_1UniqueFunctionBase_1_1CallbacksHolder.html#a7bddc8b1812fb9623d9046e91a767914">  245</a></span>&#160;    <span class="keyword">static</span> NonTrivialCallbacks <a class="code" href="structllvm_1_1detail_1_1UniqueFunctionBase_1_1CallbacksHolder.html#a7bddc8b1812fb9623d9046e91a767914">Callbacks</a>;</div>
<div class="line"><a name="l00246"></a><span class="lineno">  246</span>&#160;  };</div>
<div class="line"><a name="l00247"></a><span class="lineno">  247</span>&#160;  <span class="comment">// See if we can create a trivial callback. We need the callable to be</span></div>
<div class="line"><a name="l00248"></a><span class="lineno">  248</span>&#160;  <span class="comment">// trivially moved and trivially destroyed so that we don&#39;t have to store</span></div>
<div class="line"><a name="l00249"></a><span class="lineno">  249</span>&#160;  <span class="comment">// type erased callbacks for those operations.</span></div>
<div class="line"><a name="l00250"></a><span class="lineno">  250</span>&#160;  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> CallableT, <span class="keyword">typename</span> CalledAs&gt;</div>
<div class="line"><a name="l00251"></a><span class="lineno"><a class="line" href="structllvm_1_1detail_1_1UniqueFunctionBase_1_1CallbacksHolder_3_01CallableT_00_01CalledAs_00_01E600272d61ae725b030f18ba3284cb420.html">  251</a></span>&#160;  <span class="keyword">struct </span><a class="code" href="structllvm_1_1detail_1_1UniqueFunctionBase_1_1CallbacksHolder.html">CallbacksHolder</a>&lt;CallableT, <a class="code" href="structllvm_1_1detail_1_1UniqueFunctionBase_1_1CalledAs.html">CalledAs</a>, <a class="code" href="namespacellvm_1_1detail.html#a5e379eb0e8afa7d6acbceca9906572ac">EnableIfTrivial</a>&lt;CallableT&gt;&gt; {</div>
<div class="line"><a name="l00252"></a><span class="lineno"><a class="line" href="structllvm_1_1detail_1_1UniqueFunctionBase_1_1CallbacksHolder_3_01CallableT_00_01CalledAs_00_01E600272d61ae725b030f18ba3284cb420.html#a9fb32c2b52e0428024234887e9e9467a">  252</a></span>&#160;    <span class="keyword">static</span> TrivialCallback <a class="code" href="structllvm_1_1detail_1_1UniqueFunctionBase_1_1CallbacksHolder_3_01CallableT_00_01CalledAs_00_01E600272d61ae725b030f18ba3284cb420.html#a9fb32c2b52e0428024234887e9e9467a">Callbacks</a>;</div>
<div class="line"><a name="l00253"></a><span class="lineno">  253</span>&#160;  };</div>
<div class="line"><a name="l00254"></a><span class="lineno">  254</span>&#160; </div>
<div class="line"><a name="l00255"></a><span class="lineno">  255</span>&#160;  <span class="comment">// A simple tag type so the call-as type to be passed to the constructor.</span></div>
<div class="line"><a name="l00256"></a><span class="lineno"><a class="line" href="structllvm_1_1detail_1_1UniqueFunctionBase_1_1CalledAs.html">  256</a></span>&#160;  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">struct </span><a class="code" href="structllvm_1_1detail_1_1UniqueFunctionBase_1_1CalledAs.html">CalledAs</a> {};</div>
<div class="line"><a name="l00257"></a><span class="lineno">  257</span>&#160; </div>
<div class="line"><a name="l00258"></a><span class="lineno">  258</span>&#160;  <span class="comment">// Essentially the &quot;main&quot; unique_function constructor, but subclasses</span></div>
<div class="line"><a name="l00259"></a><span class="lineno">  259</span>&#160;  <span class="comment">// provide the qualified type to be used for the call.</span></div>
<div class="line"><a name="l00260"></a><span class="lineno">  260</span>&#160;  <span class="comment">// (We always store a T, even if the call will use a pointer to const T).</span></div>
<div class="line"><a name="l00261"></a><span class="lineno">  261</span>&#160;  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> CallableT, <span class="keyword">typename</span> CalledAsT&gt;</div>
<div class="line"><a name="l00262"></a><span class="lineno"><a class="line" href="classllvm_1_1detail_1_1UniqueFunctionBase.html#a74463d3b6e49c6e6be3baf812d3f2699">  262</a></span>&#160;  <a class="code" href="classllvm_1_1detail_1_1UniqueFunctionBase.html#a74463d3b6e49c6e6be3baf812d3f2699">UniqueFunctionBase</a>(CallableT Callable, CalledAs&lt;CalledAsT&gt;) {</div>
<div class="line"><a name="l00263"></a><span class="lineno">  263</span>&#160;    <span class="keywordtype">bool</span> IsInlineStorage = <span class="keyword">true</span>;</div>
<div class="line"><a name="l00264"></a><span class="lineno">  264</span>&#160;    <span class="keywordtype">void</span> *CallableAddr = <a class="code" href="classllvm_1_1detail_1_1UniqueFunctionBase.html#a3587453289f2ead89a5b8b547e4c0810">getInlineStorage</a>();</div>
<div class="line"><a name="l00265"></a><span class="lineno">  265</span>&#160;    <span class="keywordflow">if</span> (<span class="keyword">sizeof</span>(CallableT) &gt; <a class="code" href="classllvm_1_1detail_1_1UniqueFunctionBase.html#afc8bea8bffe6f12ac46e3a44352f75eb">InlineStorageSize</a> ||</div>
<div class="line"><a name="l00266"></a><span class="lineno">  266</span>&#160;        <span class="keyword">alignof</span>(CallableT) &gt; <span class="keyword">alignof</span>(decltype(StorageUnion.InlineStorage))) {</div>
<div class="line"><a name="l00267"></a><span class="lineno">  267</span>&#160;      IsInlineStorage = <span class="keyword">false</span>;</div>
<div class="line"><a name="l00268"></a><span class="lineno">  268</span>&#160;      <span class="comment">// Allocate out-of-line storage. FIXME: Use an explicit alignment</span></div>
<div class="line"><a name="l00269"></a><span class="lineno">  269</span>&#160;      <span class="comment">// parameter in C++17 mode.</span></div>
<div class="line"><a name="l00270"></a><span class="lineno">  270</span>&#160;      <span class="keyword">auto</span> Size = <span class="keyword">sizeof</span>(CallableT);</div>
<div class="line"><a name="l00271"></a><span class="lineno">  271</span>&#160;      <span class="keyword">auto</span> Alignment = <span class="keyword">alignof</span>(CallableT);</div>
<div class="line"><a name="l00272"></a><span class="lineno">  272</span>&#160;      CallableAddr = <a class="code" href="namespacellvm.html#a69fae8413f8fd4cea02237fe8b0c00ed">allocate_buffer</a>(Size, Alignment);</div>
<div class="line"><a name="l00273"></a><span class="lineno">  273</span>&#160;      <a class="code" href="classllvm_1_1detail_1_1UniqueFunctionBase.html#a3f042ddd5a6cb8e0cee6575743d53ef7">setOutOfLineStorage</a>(CallableAddr, Size, Alignment);</div>
<div class="line"><a name="l00274"></a><span class="lineno">  274</span>&#160;    }</div>
<div class="line"><a name="l00275"></a><span class="lineno">  275</span>&#160; </div>
<div class="line"><a name="l00276"></a><span class="lineno">  276</span>&#160;    <span class="comment">// Now move into the storage.</span></div>
<div class="line"><a name="l00277"></a><span class="lineno">  277</span>&#160;    <span class="keyword">new</span> (CallableAddr) CallableT(<a class="code" href="lib_2Target_2ARM_2README_8txt.html#ad3a99906764c35b2694ae90fa57744a5">std::move</a>(Callable));</div>
<div class="line"><a name="l00278"></a><span class="lineno">  278</span>&#160;    CallbackAndInlineFlag.setPointerAndInt(</div>
<div class="line"><a name="l00279"></a><span class="lineno">  279</span>&#160;        &amp;<a class="code" href="structllvm_1_1detail_1_1UniqueFunctionBase_1_1CallbacksHolder.html#a7bddc8b1812fb9623d9046e91a767914">CallbacksHolder&lt;CallableT, CalledAsT&gt;::Callbacks</a>, IsInlineStorage);</div>
<div class="line"><a name="l00280"></a><span class="lineno">  280</span>&#160;  }</div>
<div class="line"><a name="l00281"></a><span class="lineno">  281</span>&#160; </div>
<div class="line"><a name="l00282"></a><span class="lineno"><a class="line" href="classllvm_1_1detail_1_1UniqueFunctionBase.html#a288074261a390b844e1bb895827aae96">  282</a></span>&#160;  <a class="code" href="classllvm_1_1detail_1_1UniqueFunctionBase.html#a288074261a390b844e1bb895827aae96">~UniqueFunctionBase</a>() {</div>
<div class="line"><a name="l00283"></a><span class="lineno">  283</span>&#160;    <span class="keywordflow">if</span> (!CallbackAndInlineFlag.getPointer())</div>
<div class="line"><a name="l00284"></a><span class="lineno">  284</span>&#160;      <span class="keywordflow">return</span>;</div>
<div class="line"><a name="l00285"></a><span class="lineno">  285</span>&#160; </div>
<div class="line"><a name="l00286"></a><span class="lineno">  286</span>&#160;    <span class="comment">// Cache this value so we don&#39;t re-check it after type-erased operations.</span></div>
<div class="line"><a name="l00287"></a><span class="lineno">  287</span>&#160;    <span class="keywordtype">bool</span> IsInlineStorage = isInlineStorage();</div>
<div class="line"><a name="l00288"></a><span class="lineno">  288</span>&#160; </div>
<div class="line"><a name="l00289"></a><span class="lineno">  289</span>&#160;    <span class="keywordflow">if</span> (!isTrivialCallback())</div>
<div class="line"><a name="l00290"></a><span class="lineno">  290</span>&#160;      <a class="code" href="classllvm_1_1detail_1_1UniqueFunctionBase.html#a33790c30f9d9cc8b0974d22eb6648ec1">getNonTrivialCallbacks</a>()-&gt;DestroyPtr(</div>
<div class="line"><a name="l00291"></a><span class="lineno">  291</span>&#160;          IsInlineStorage ? <a class="code" href="classllvm_1_1detail_1_1UniqueFunctionBase.html#a3587453289f2ead89a5b8b547e4c0810">getInlineStorage</a>() : <a class="code" href="classllvm_1_1detail_1_1UniqueFunctionBase.html#afc6639147fd23b870c9ed6e097176cac">getOutOfLineStorage</a>());</div>
<div class="line"><a name="l00292"></a><span class="lineno">  292</span>&#160; </div>
<div class="line"><a name="l00293"></a><span class="lineno">  293</span>&#160;    <span class="keywordflow">if</span> (!IsInlineStorage)</div>
<div class="line"><a name="l00294"></a><span class="lineno">  294</span>&#160;      <a class="code" href="namespacellvm.html#a6dd1aab3f9fa498fd6196a06fadbd984">deallocate_buffer</a>(<a class="code" href="classllvm_1_1detail_1_1UniqueFunctionBase.html#afc6639147fd23b870c9ed6e097176cac">getOutOfLineStorage</a>(), <a class="code" href="classllvm_1_1detail_1_1UniqueFunctionBase.html#aa45b5add274f23456e6abc4451798225">getOutOfLineStorageSize</a>(),</div>
<div class="line"><a name="l00295"></a><span class="lineno">  295</span>&#160;                        <a class="code" href="classllvm_1_1detail_1_1UniqueFunctionBase.html#ac2ee20db0af7f93b577dddb3e9637478">getOutOfLineStorageAlignment</a>());</div>
<div class="line"><a name="l00296"></a><span class="lineno">  296</span>&#160;  }</div>
<div class="line"><a name="l00297"></a><span class="lineno">  297</span>&#160; </div>
<div class="line"><a name="l00298"></a><span class="lineno"><a class="line" href="classllvm_1_1detail_1_1UniqueFunctionBase.html#ad6d450e33cf5fff1101a1e8daabcd2b3">  298</a></span>&#160;  <a class="code" href="classllvm_1_1detail_1_1UniqueFunctionBase.html#ad6d450e33cf5fff1101a1e8daabcd2b3">UniqueFunctionBase</a>(<a class="code" href="classllvm_1_1detail_1_1UniqueFunctionBase.html">UniqueFunctionBase</a> &amp;&amp;<a class="code" href="X86PartialReduction_8cpp.html#a87b8bfbbe9d8f7146d7f20a5fb42efd0">RHS</a>) noexcept {</div>
<div class="line"><a name="l00299"></a><span class="lineno">  299</span>&#160;    <span class="comment">// Copy the callback and inline flag.</span></div>
<div class="line"><a name="l00300"></a><span class="lineno">  300</span>&#160;    CallbackAndInlineFlag = <a class="code" href="X86PartialReduction_8cpp.html#a87b8bfbbe9d8f7146d7f20a5fb42efd0">RHS</a>.CallbackAndInlineFlag;</div>
<div class="line"><a name="l00301"></a><span class="lineno">  301</span>&#160; </div>
<div class="line"><a name="l00302"></a><span class="lineno">  302</span>&#160;    <span class="comment">// If the RHS is empty, just copying the above is sufficient.</span></div>
<div class="line"><a name="l00303"></a><span class="lineno">  303</span>&#160;    <span class="keywordflow">if</span> (!<a class="code" href="X86PartialReduction_8cpp.html#a87b8bfbbe9d8f7146d7f20a5fb42efd0">RHS</a>)</div>
<div class="line"><a name="l00304"></a><span class="lineno">  304</span>&#160;      <span class="keywordflow">return</span>;</div>
<div class="line"><a name="l00305"></a><span class="lineno">  305</span>&#160; </div>
<div class="line"><a name="l00306"></a><span class="lineno">  306</span>&#160;    <span class="keywordflow">if</span> (!isInlineStorage()) {</div>
<div class="line"><a name="l00307"></a><span class="lineno">  307</span>&#160;      <span class="comment">// The out-of-line case is easiest to move.</span></div>
<div class="line"><a name="l00308"></a><span class="lineno">  308</span>&#160;      StorageUnion.OutOfLineStorage = <a class="code" href="X86PartialReduction_8cpp.html#a87b8bfbbe9d8f7146d7f20a5fb42efd0">RHS</a>.StorageUnion.OutOfLineStorage;</div>
<div class="line"><a name="l00309"></a><span class="lineno">  309</span>&#160;    } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (isTrivialCallback()) {</div>
<div class="line"><a name="l00310"></a><span class="lineno">  310</span>&#160;      <span class="comment">// Move is trivial, just memcpy the bytes across.</span></div>
<div class="line"><a name="l00311"></a><span class="lineno">  311</span>&#160;      <a class="code" href="lib_2Target_2ARM_2README_8txt.html#ae2bb081d94f22e64ca6bc4bd58512a93">memcpy</a>(<a class="code" href="classllvm_1_1detail_1_1UniqueFunctionBase.html#a3587453289f2ead89a5b8b547e4c0810">getInlineStorage</a>(), <a class="code" href="X86PartialReduction_8cpp.html#a87b8bfbbe9d8f7146d7f20a5fb42efd0">RHS</a>.getInlineStorage(), <a class="code" href="classllvm_1_1detail_1_1UniqueFunctionBase.html#afc8bea8bffe6f12ac46e3a44352f75eb">InlineStorageSize</a>);</div>
<div class="line"><a name="l00312"></a><span class="lineno">  312</span>&#160;    } <span class="keywordflow">else</span> {</div>
<div class="line"><a name="l00313"></a><span class="lineno">  313</span>&#160;      <span class="comment">// Non-trivial move, so dispatch to a type-erased implementation.</span></div>
<div class="line"><a name="l00314"></a><span class="lineno">  314</span>&#160;      <a class="code" href="classllvm_1_1detail_1_1UniqueFunctionBase.html#a33790c30f9d9cc8b0974d22eb6648ec1">getNonTrivialCallbacks</a>()-&gt;MovePtr(<a class="code" href="classllvm_1_1detail_1_1UniqueFunctionBase.html#a3587453289f2ead89a5b8b547e4c0810">getInlineStorage</a>(),</div>
<div class="line"><a name="l00315"></a><span class="lineno">  315</span>&#160;                                        <a class="code" href="X86PartialReduction_8cpp.html#a87b8bfbbe9d8f7146d7f20a5fb42efd0">RHS</a>.getInlineStorage());</div>
<div class="line"><a name="l00316"></a><span class="lineno">  316</span>&#160;    }</div>
<div class="line"><a name="l00317"></a><span class="lineno">  317</span>&#160; </div>
<div class="line"><a name="l00318"></a><span class="lineno">  318</span>&#160;    <span class="comment">// Clear the old callback and inline flag to get back to as-if-null.</span></div>
<div class="line"><a name="l00319"></a><span class="lineno">  319</span>&#160;    <a class="code" href="X86PartialReduction_8cpp.html#a87b8bfbbe9d8f7146d7f20a5fb42efd0">RHS</a>.CallbackAndInlineFlag = {};</div>
<div class="line"><a name="l00320"></a><span class="lineno">  320</span>&#160; </div>
<div class="line"><a name="l00321"></a><span class="lineno">  321</span>&#160;<span class="preprocessor">#ifndef NDEBUG</span></div>
<div class="line"><a name="l00322"></a><span class="lineno">  322</span>&#160;    <span class="comment">// In debug builds, we also scribble across the rest of the storage.</span></div>
<div class="line"><a name="l00323"></a><span class="lineno">  323</span>&#160;    memset(<a class="code" href="X86PartialReduction_8cpp.html#a87b8bfbbe9d8f7146d7f20a5fb42efd0">RHS</a>.getInlineStorage(), 0xAD, <a class="code" href="classllvm_1_1detail_1_1UniqueFunctionBase.html#afc8bea8bffe6f12ac46e3a44352f75eb">InlineStorageSize</a>);</div>
<div class="line"><a name="l00324"></a><span class="lineno">  324</span>&#160;<span class="preprocessor">#endif</span></div>
<div class="line"><a name="l00325"></a><span class="lineno">  325</span>&#160;  }</div>
<div class="line"><a name="l00326"></a><span class="lineno">  326</span>&#160; </div>
<div class="line"><a name="l00327"></a><span class="lineno"><a class="line" href="classllvm_1_1detail_1_1UniqueFunctionBase.html#a06c5bcbb18fc88bba5b8ebd1d545f7cf">  327</a></span>&#160;  <a class="code" href="classllvm_1_1detail_1_1UniqueFunctionBase.html">UniqueFunctionBase</a> &amp;<a class="code" href="classllvm_1_1detail_1_1UniqueFunctionBase.html#a06c5bcbb18fc88bba5b8ebd1d545f7cf">operator=</a>(<a class="code" href="classllvm_1_1detail_1_1UniqueFunctionBase.html">UniqueFunctionBase</a> &amp;&amp;<a class="code" href="X86PartialReduction_8cpp.html#a87b8bfbbe9d8f7146d7f20a5fb42efd0">RHS</a>) noexcept {</div>
<div class="line"><a name="l00328"></a><span class="lineno">  328</span>&#160;    <span class="keywordflow">if</span> (<span class="keyword">this</span> == &amp;<a class="code" href="X86PartialReduction_8cpp.html#a87b8bfbbe9d8f7146d7f20a5fb42efd0">RHS</a>)</div>
<div class="line"><a name="l00329"></a><span class="lineno">  329</span>&#160;      <span class="keywordflow">return</span> *<span class="keyword">this</span>;</div>
<div class="line"><a name="l00330"></a><span class="lineno">  330</span>&#160; </div>
<div class="line"><a name="l00331"></a><span class="lineno">  331</span>&#160;    <span class="comment">// Because we don&#39;t try to provide any exception safety guarantees we can</span></div>
<div class="line"><a name="l00332"></a><span class="lineno">  332</span>&#160;    <span class="comment">// implement move assignment very simply by first destroying the current</span></div>
<div class="line"><a name="l00333"></a><span class="lineno">  333</span>&#160;    <span class="comment">// object and then move-constructing over top of it.</span></div>
<div class="line"><a name="l00334"></a><span class="lineno">  334</span>&#160;    this-&gt;<a class="code" href="classllvm_1_1detail_1_1UniqueFunctionBase.html#a288074261a390b844e1bb895827aae96">~UniqueFunctionBase</a>();</div>
<div class="line"><a name="l00335"></a><span class="lineno">  335</span>&#160;    <span class="keyword">new</span> (<span class="keyword">this</span>) <a class="code" href="classllvm_1_1detail_1_1UniqueFunctionBase.html#a2701d4eee17002ff6595f7fcd47d9aef">UniqueFunctionBase</a>(<a class="code" href="lib_2Target_2ARM_2README_8txt.html#ad3a99906764c35b2694ae90fa57744a5">std::move</a>(<a class="code" href="X86PartialReduction_8cpp.html#a87b8bfbbe9d8f7146d7f20a5fb42efd0">RHS</a>));</div>
<div class="line"><a name="l00336"></a><span class="lineno">  336</span>&#160;    <span class="keywordflow">return</span> *<span class="keyword">this</span>;</div>
<div class="line"><a name="l00337"></a><span class="lineno">  337</span>&#160;  }</div>
<div class="line"><a name="l00338"></a><span class="lineno">  338</span>&#160; </div>
<div class="line"><a name="l00339"></a><span class="lineno">  339</span>&#160;  <a class="code" href="classllvm_1_1detail_1_1UniqueFunctionBase.html#a2701d4eee17002ff6595f7fcd47d9aef">UniqueFunctionBase</a>() = <span class="keywordflow">default</span>;</div>
<div class="line"><a name="l00340"></a><span class="lineno">  340</span>&#160; </div>
<div class="line"><a name="l00341"></a><span class="lineno">  341</span>&#160;<span class="keyword">public</span>:</div>
<div class="line"><a name="l00342"></a><span class="lineno"><a class="line" href="classllvm_1_1detail_1_1UniqueFunctionBase.html#a5d8012ddf85c38c162988f27aff7bc7f">  342</a></span>&#160;  <span class="keyword">explicit</span> <span class="keyword">operator</span> bool()<span class="keyword"> const </span>{</div>
<div class="line"><a name="l00343"></a><span class="lineno">  343</span>&#160;    <span class="keywordflow">return</span> (<span class="keywordtype">bool</span>)CallbackAndInlineFlag.getPointer();</div>
<div class="line"><a name="l00344"></a><span class="lineno">  344</span>&#160;  }</div>
<div class="line"><a name="l00345"></a><span class="lineno">  345</span>&#160;};</div>
<div class="line"><a name="l00346"></a><span class="lineno">  346</span>&#160; </div>
<div class="line"><a name="l00347"></a><span class="lineno">  347</span>&#160;<span class="keyword">template</span> &lt;<span class="keyword">typename</span> R, <span class="keyword">typename</span>... <a class="code" href="README-SSE_8txt.html#a63d206a063eefcdf8c318ded97b65020">P</a>&gt;</div>
<div class="line"><a name="l00348"></a><span class="lineno">  348</span>&#160;<span class="keyword">template</span> &lt;<span class="keyword">typename</span> CallableT, <span class="keyword">typename</span> CalledAsT, <span class="keyword">typename</span> Enable&gt;</div>
<div class="line"><a name="l00349"></a><span class="lineno">  349</span>&#160;<span class="keyword">typename</span> UniqueFunctionBase&lt;R, <a class="code" href="README-SSE_8txt.html#a63d206a063eefcdf8c318ded97b65020">P</a>...&gt;::NonTrivialCallbacks UniqueFunctionBase&lt;</div>
<div class="line"><a name="l00350"></a><span class="lineno">  350</span>&#160;    R, <a class="code" href="README-SSE_8txt.html#a63d206a063eefcdf8c318ded97b65020">P</a>...&gt;::CallbacksHolder&lt;CallableT, CalledAsT, Enable&gt;::Callbacks = {</div>
<div class="line"><a name="l00351"></a><span class="lineno">  351</span>&#160;    &amp;CallImpl&lt;CalledAsT&gt;, &amp;MoveImpl&lt;CallableT&gt;, &amp;DestroyImpl&lt;CallableT&gt;};</div>
<div class="line"><a name="l00352"></a><span class="lineno">  352</span>&#160; </div>
<div class="line"><a name="l00353"></a><span class="lineno">  353</span>&#160;<span class="keyword">template</span> &lt;<span class="keyword">typename</span> R, <span class="keyword">typename</span>... <a class="code" href="README-SSE_8txt.html#a63d206a063eefcdf8c318ded97b65020">P</a>&gt;</div>
<div class="line"><a name="l00354"></a><span class="lineno">  354</span>&#160;<span class="keyword">template</span> &lt;<span class="keyword">typename</span> CallableT, <span class="keyword">typename</span> CalledAsT&gt;</div>
<div class="line"><a name="l00355"></a><span class="lineno">  355</span>&#160;<span class="keyword">typename</span> UniqueFunctionBase&lt;R, <a class="code" href="README-SSE_8txt.html#a63d206a063eefcdf8c318ded97b65020">P</a>...&gt;::TrivialCallback</div>
<div class="line"><a name="l00356"></a><span class="lineno">  356</span>&#160;    UniqueFunctionBase&lt;R, <a class="code" href="README-SSE_8txt.html#a63d206a063eefcdf8c318ded97b65020">P</a>...&gt;::CallbacksHolder&lt;</div>
<div class="line"><a name="l00357"></a><span class="lineno">  357</span>&#160;        CallableT, CalledAsT, EnableIfTrivial&lt;CallableT&gt;&gt;::Callbacks{</div>
<div class="line"><a name="l00358"></a><span class="lineno">  358</span>&#160;        &amp;CallImpl&lt;CalledAsT&gt;};</div>
<div class="line"><a name="l00359"></a><span class="lineno">  359</span>&#160; </div>
<div class="line"><a name="l00360"></a><span class="lineno">  360</span>&#160;} <span class="comment">// namespace detail</span></div>
<div class="line"><a name="l00361"></a><span class="lineno">  361</span>&#160; </div>
<div class="line"><a name="l00362"></a><span class="lineno">  362</span>&#160;<span class="keyword">template</span> &lt;<span class="keyword">typename</span> <a class="code" href="namespacellvm_1_1RISCVFenceField.html#a147be9e9780c1e33363ea572d4c7b25fa1835091d83e0e052cd1a32c99b2be731">R</a>, <span class="keyword">typename</span>... <a class="code" href="README-SSE_8txt.html#a63d206a063eefcdf8c318ded97b65020">P</a>&gt;</div>
<div class="line"><a name="l00363"></a><span class="lineno"><a class="line" href="classllvm_1_1unique__function_3_01R_07P_8_8_8_08_4.html">  363</a></span>&#160;<span class="keyword">class </span><a class="code" href="classllvm_1_1unique__function.html">unique_function</a>&lt;<a class="code" href="namespacellvm_1_1RISCVFenceField.html#a147be9e9780c1e33363ea572d4c7b25fa1835091d83e0e052cd1a32c99b2be731">R</a>(<a class="code" href="README-SSE_8txt.html#a63d206a063eefcdf8c318ded97b65020">P</a>...)&gt; : <span class="keyword">public</span> <a class="code" href="classllvm_1_1detail_1_1UniqueFunctionBase.html">detail::UniqueFunctionBase</a>&lt;R, P...&gt; {</div>
<div class="line"><a name="l00364"></a><span class="lineno">  364</span>&#160;  <span class="keyword">using</span> <a class="code" href="classllvm_1_1detail_1_1UniqueFunctionBase.html">Base</a> = <a class="code" href="classllvm_1_1detail_1_1UniqueFunctionBase.html">detail::UniqueFunctionBase</a>&lt;R, <a class="code" href="README-SSE_8txt.html#a63d206a063eefcdf8c318ded97b65020">P</a>...&gt;;</div>
<div class="line"><a name="l00365"></a><span class="lineno">  365</span>&#160; </div>
<div class="line"><a name="l00366"></a><span class="lineno">  366</span>&#160;<span class="keyword">public</span>:</div>
<div class="line"><a name="l00367"></a><span class="lineno">  367</span>&#160;  <a class="code" href="classllvm_1_1unique__function.html">unique_function</a>() = <span class="keywordflow">default</span>;</div>
<div class="line"><a name="l00368"></a><span class="lineno"><a class="line" href="classllvm_1_1unique__function_3_01R_07P_8_8_8_08_4.html#ad9c327569d1e967871ab24adbc385009">  368</a></span>&#160;  <a class="code" href="classllvm_1_1unique__function_3_01R_07P_8_8_8_08_4.html#ad9c327569d1e967871ab24adbc385009">unique_function</a>(std::nullptr_t) {}</div>
<div class="line"><a name="l00369"></a><span class="lineno">  369</span>&#160;  <a class="code" href="classllvm_1_1unique__function.html">unique_function</a>(<a class="code" href="classllvm_1_1unique__function.html">unique_function</a> &amp;&amp;) = <span class="keywordflow">default</span>;</div>
<div class="line"><a name="l00370"></a><span class="lineno">  370</span>&#160;  <a class="code" href="classllvm_1_1unique__function.html">unique_function</a>(<span class="keyword">const</span> <a class="code" href="classllvm_1_1unique__function.html">unique_function</a> &amp;) = <span class="keyword">delete</span>;</div>
<div class="line"><a name="l00371"></a><span class="lineno">  371</span>&#160;  <a class="code" href="classllvm_1_1unique__function.html">unique_function</a> &amp;operator=(<a class="code" href="classllvm_1_1unique__function.html">unique_function</a> &amp;&amp;) = <span class="keywordflow">default</span>;</div>
<div class="line"><a name="l00372"></a><span class="lineno">  372</span>&#160;  <a class="code" href="classllvm_1_1unique__function.html">unique_function</a> &amp;operator=(<span class="keyword">const</span> <a class="code" href="classllvm_1_1unique__function.html">unique_function</a> &amp;) = <span class="keyword">delete</span>;</div>
<div class="line"><a name="l00373"></a><span class="lineno">  373</span>&#160; </div>
<div class="line"><a name="l00374"></a><span class="lineno">  374</span>&#160;  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> CallableT&gt;</div>
<div class="line"><a name="l00375"></a><span class="lineno"><a class="line" href="classllvm_1_1unique__function_3_01R_07P_8_8_8_08_4.html#a545b1f13a02cc090f382b2263f5c8a53">  375</a></span>&#160;  <a class="code" href="classllvm_1_1unique__function_3_01R_07P_8_8_8_08_4.html#a545b1f13a02cc090f382b2263f5c8a53">unique_function</a>(</div>
<div class="line"><a name="l00376"></a><span class="lineno">  376</span>&#160;      CallableT Callable,</div>
<div class="line"><a name="l00377"></a><span class="lineno">  377</span>&#160;      <a class="code" href="namespacellvm_1_1detail.html#adda4c37ee77c163c1daf9fa242bd9408">detail::EnableUnlessSameType&lt;CallableT, unique_function&gt;</a> * = <span class="keyword">nullptr</span>,</div>
<div class="line"><a name="l00378"></a><span class="lineno">  378</span>&#160;      <a class="code" href="namespacellvm_1_1detail.html#a29ac72f534b5279feda1e95d06c4adbe">detail::EnableIfCallable&lt;CallableT, R, P...&gt;</a> * = <span class="keyword">nullptr</span>)</div>
<div class="line"><a name="l00379"></a><span class="lineno">  379</span>&#160;      : <a class="code" href="classllvm_1_1detail_1_1UniqueFunctionBase.html">Base</a>(<a class="code" href="namespacestd.html">std</a>::forward&lt;CallableT&gt;(Callable),</div>
<div class="line"><a name="l00380"></a><span class="lineno">  380</span>&#160;             typename <a class="code" href="classllvm_1_1detail_1_1UniqueFunctionBase.html">Base</a>::template CalledAs&lt;CallableT&gt;{}) {}</div>
<div class="line"><a name="l00381"></a><span class="lineno">  381</span>&#160; </div>
<div class="line"><a name="l00382"></a><span class="lineno"><a class="line" href="classllvm_1_1unique__function_3_01R_07P_8_8_8_08_4.html#a9db879718460106d106e4d1d512adeea">  382</a></span>&#160;  R <a class="code" href="classllvm_1_1unique__function_3_01R_07P_8_8_8_08_4.html#a9db879718460106d106e4d1d512adeea">operator()</a>(<a class="code" href="README-SSE_8txt.html#a63d206a063eefcdf8c318ded97b65020">P</a>... Params) {</div>
<div class="line"><a name="l00383"></a><span class="lineno">  383</span>&#160;    <span class="keywordflow">return</span> this-&gt;getCallPtr()(this-&gt;getCalleePtr(), Params...);</div>
<div class="line"><a name="l00384"></a><span class="lineno">  384</span>&#160;  }</div>
<div class="line"><a name="l00385"></a><span class="lineno">  385</span>&#160;};</div>
<div class="line"><a name="l00386"></a><span class="lineno">  386</span>&#160; </div>
<div class="line"><a name="l00387"></a><span class="lineno">  387</span>&#160;<span class="keyword">template</span> &lt;<span class="keyword">typename</span> R, <span class="keyword">typename</span>... <a class="code" href="README-SSE_8txt.html#a63d206a063eefcdf8c318ded97b65020">P</a>&gt;</div>
<div class="line"><a name="l00388"></a><span class="lineno"><a class="line" href="classllvm_1_1unique__function_3_01R_07P_8_8_8_08_01const_01_4.html">  388</a></span>&#160;<span class="keyword">class </span><a class="code" href="classllvm_1_1unique__function.html">unique_function</a>&lt;<a class="code" href="namespacellvm_1_1RISCVFenceField.html#a147be9e9780c1e33363ea572d4c7b25fa1835091d83e0e052cd1a32c99b2be731">R</a>(<a class="code" href="README-SSE_8txt.html#a63d206a063eefcdf8c318ded97b65020">P</a>...) <a class="code" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a>&gt;</div>
<div class="line"><a name="l00389"></a><span class="lineno">  389</span>&#160;    : <span class="keyword">public</span> <a class="code" href="classllvm_1_1detail_1_1UniqueFunctionBase.html">detail::UniqueFunctionBase</a>&lt;R, P...&gt; {</div>
<div class="line"><a name="l00390"></a><span class="lineno">  390</span>&#160;  <span class="keyword">using</span> <a class="code" href="classllvm_1_1detail_1_1UniqueFunctionBase.html">Base</a> = <a class="code" href="classllvm_1_1detail_1_1UniqueFunctionBase.html">detail::UniqueFunctionBase</a>&lt;R, <a class="code" href="README-SSE_8txt.html#a63d206a063eefcdf8c318ded97b65020">P</a>...&gt;;</div>
<div class="line"><a name="l00391"></a><span class="lineno">  391</span>&#160; </div>
<div class="line"><a name="l00392"></a><span class="lineno">  392</span>&#160;<span class="keyword">public</span>:</div>
<div class="line"><a name="l00393"></a><span class="lineno">  393</span>&#160;  <a class="code" href="classllvm_1_1unique__function.html">unique_function</a>() = <span class="keywordflow">default</span>;</div>
<div class="line"><a name="l00394"></a><span class="lineno"><a class="line" href="classllvm_1_1unique__function_3_01R_07P_8_8_8_08_01const_01_4.html#a39a45cfca860a2b5b097fe5213bfa298">  394</a></span>&#160;  <a class="code" href="classllvm_1_1unique__function_3_01R_07P_8_8_8_08_01const_01_4.html#a39a45cfca860a2b5b097fe5213bfa298">unique_function</a>(std::nullptr_t) {}</div>
<div class="line"><a name="l00395"></a><span class="lineno">  395</span>&#160;  <a class="code" href="classllvm_1_1unique__function.html">unique_function</a>(<a class="code" href="classllvm_1_1unique__function.html">unique_function</a> &amp;&amp;) = <span class="keywordflow">default</span>;</div>
<div class="line"><a name="l00396"></a><span class="lineno">  396</span>&#160;  <a class="code" href="classllvm_1_1unique__function.html">unique_function</a>(<span class="keyword">const</span> <a class="code" href="classllvm_1_1unique__function.html">unique_function</a> &amp;) = <span class="keyword">delete</span>;</div>
<div class="line"><a name="l00397"></a><span class="lineno">  397</span>&#160;  <a class="code" href="classllvm_1_1unique__function.html">unique_function</a> &amp;operator=(<a class="code" href="classllvm_1_1unique__function.html">unique_function</a> &amp;&amp;) = <span class="keywordflow">default</span>;</div>
<div class="line"><a name="l00398"></a><span class="lineno">  398</span>&#160;  <a class="code" href="classllvm_1_1unique__function.html">unique_function</a> &amp;operator=(<span class="keyword">const</span> <a class="code" href="classllvm_1_1unique__function.html">unique_function</a> &amp;) = <span class="keyword">delete</span>;</div>
<div class="line"><a name="l00399"></a><span class="lineno">  399</span>&#160; </div>
<div class="line"><a name="l00400"></a><span class="lineno">  400</span>&#160;  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> CallableT&gt;</div>
<div class="line"><a name="l00401"></a><span class="lineno"><a class="line" href="classllvm_1_1unique__function_3_01R_07P_8_8_8_08_01const_01_4.html#aec7783fd5f7e9ca0b6b0b35e8ded1de1">  401</a></span>&#160;  <a class="code" href="classllvm_1_1unique__function_3_01R_07P_8_8_8_08_01const_01_4.html#aec7783fd5f7e9ca0b6b0b35e8ded1de1">unique_function</a>(</div>
<div class="line"><a name="l00402"></a><span class="lineno">  402</span>&#160;      CallableT Callable,</div>
<div class="line"><a name="l00403"></a><span class="lineno">  403</span>&#160;      <a class="code" href="namespacellvm_1_1detail.html#adda4c37ee77c163c1daf9fa242bd9408">detail::EnableUnlessSameType&lt;CallableT, unique_function&gt;</a> * = <span class="keyword">nullptr</span>,</div>
<div class="line"><a name="l00404"></a><span class="lineno">  404</span>&#160;      <a class="code" href="namespacellvm_1_1detail.html#a29ac72f534b5279feda1e95d06c4adbe">detail::EnableIfCallable&lt;const CallableT, R, P...&gt;</a> * = <span class="keyword">nullptr</span>)</div>
<div class="line"><a name="l00405"></a><span class="lineno">  405</span>&#160;      : <a class="code" href="classllvm_1_1detail_1_1UniqueFunctionBase.html">Base</a>(<a class="code" href="namespacestd.html">std</a>::forward&lt;CallableT&gt;(Callable),</div>
<div class="line"><a name="l00406"></a><span class="lineno">  406</span>&#160;             typename <a class="code" href="classllvm_1_1detail_1_1UniqueFunctionBase.html">Base</a>::template CalledAs&lt;<a class="code" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> CallableT&gt;{}) {}</div>
<div class="line"><a name="l00407"></a><span class="lineno">  407</span>&#160; </div>
<div class="line"><a name="l00408"></a><span class="lineno"><a class="line" href="classllvm_1_1unique__function_3_01R_07P_8_8_8_08_01const_01_4.html#abf99cbdddb3f5145af41723b1edaed76">  408</a></span>&#160;  R <a class="code" href="classllvm_1_1unique__function_3_01R_07P_8_8_8_08_01const_01_4.html#abf99cbdddb3f5145af41723b1edaed76">operator()</a>(<a class="code" href="README-SSE_8txt.html#a63d206a063eefcdf8c318ded97b65020">P</a>... Params)<span class="keyword"> const </span>{</div>
<div class="line"><a name="l00409"></a><span class="lineno">  409</span>&#160;    <span class="keywordflow">return</span> this-&gt;getCallPtr()(this-&gt;getCalleePtr(), Params...);</div>
<div class="line"><a name="l00410"></a><span class="lineno">  410</span>&#160;  }</div>
<div class="line"><a name="l00411"></a><span class="lineno">  411</span>&#160;};</div>
<div class="line"><a name="l00412"></a><span class="lineno">  412</span>&#160; </div>
<div class="line"><a name="l00413"></a><span class="lineno">  413</span>&#160;} <span class="comment">// end namespace llvm</span></div>
<div class="line"><a name="l00414"></a><span class="lineno">  414</span>&#160; </div>
<div class="line"><a name="l00415"></a><span class="lineno">  415</span>&#160;<span class="preprocessor">#endif // LLVM_ADT_FUNCTIONEXTRAS_H</span></div>
</div><!-- fragment --></div><!-- contents -->
<div class="ttc" id="anamespacellvm_1_1Check_html_a067ee17412e800f03802fa9517685732a3450a9712780ac26b071f9da4288a396"><div class="ttname"><a href="namespacellvm_1_1Check.html#a067ee17412e800f03802fa9517685732a3450a9712780ac26b071f9da4288a396">llvm::Check::Size</a></div><div class="ttdeci">@ Size</div><div class="ttdef"><b>Definition:</b> <a href="FileCheck_8h_source.html#l00077">FileCheck.h:77</a></div></div>
<div class="ttc" id="aclassllvm_1_1detail_1_1UniqueFunctionBase_html_aa45b5add274f23456e6abc4451798225"><div class="ttname"><a href="classllvm_1_1detail_1_1UniqueFunctionBase.html#aa45b5add274f23456e6abc4451798225">llvm::detail::UniqueFunctionBase::getOutOfLineStorageSize</a></div><div class="ttdeci">size_t getOutOfLineStorageSize() const</div><div class="ttdef"><b>Definition:</b> <a href="FunctionExtras_8h_source.html#l00206">FunctionExtras.h:206</a></div></div>
<div class="ttc" id="aclassllvm_1_1detail_1_1UniqueFunctionBase_html_a7d9ae43014e0a34731a02793bae511d2"><div class="ttname"><a href="classllvm_1_1detail_1_1UniqueFunctionBase.html#a7d9ae43014e0a34731a02793bae511d2">llvm::detail::UniqueFunctionBase::MoveImpl</a></div><div class="ttdeci">static void MoveImpl(void *LHSCallableAddr, void *RHSCallableAddr) noexcept</div><div class="ttdef"><b>Definition:</b> <a href="FunctionExtras_8h_source.html#l00225">FunctionExtras.h:225</a></div></div>
<div class="ttc" id="anamespacellvm_html"><div class="ttname"><a href="namespacellvm.html">llvm</a></div><div class="ttdoc">This is an optimization pass for GlobalISel generic memory operations.</div><div class="ttdef"><b>Definition:</b> <a href="AddressRanges_8h_source.html#l00018">AddressRanges.h:18</a></div></div>
<div class="ttc" id="aclassllvm_1_1unique__function_html"><div class="ttname"><a href="classllvm_1_1unique__function.html">llvm::unique_function</a></div><div class="ttdoc">unique_function is a type-erasing functor similar to std::function.</div><div class="ttdef"><b>Definition:</b> <a href="FunctionExtras_8h_source.html#l00056">FunctionExtras.h:56</a></div></div>
<div class="ttc" id="aREADME-SSE_8txt_html_a63d206a063eefcdf8c318ded97b65020"><div class="ttname"><a href="README-SSE_8txt.html#a63d206a063eefcdf8c318ded97b65020">P</a></div><div class="ttdeci">This currently compiles esp xmm0 movsd esp eax eax esp ret We should use not the dag combiner This is because dagcombine2 needs to be able to see through the X86ISD::Wrapper which DAGCombine can t really do The code for turning x load into a single vector load is target independent and should be moved to the dag combiner The code for turning x load into a vector load can only handle a direct load from a global or a direct load from the stack It should be generalized to handle any load from P</div><div class="ttdef"><b>Definition:</b> <a href="README-SSE_8txt_source.html#l00411">README-SSE.txt:411</a></div></div>
<div class="ttc" id="aclassllvm_1_1detail_1_1UniqueFunctionBase_html_a4de3d0fbcb5bf9bec73755b1b0e4810f"><div class="ttname"><a href="classllvm_1_1detail_1_1UniqueFunctionBase.html#a4de3d0fbcb5bf9bec73755b1b0e4810f">llvm::detail::UniqueFunctionBase::getCalleePtr</a></div><div class="ttdeci">void * getCalleePtr() const</div><div class="ttdef"><b>Definition:</b> <a href="FunctionExtras_8h_source.html#l00198">FunctionExtras.h:198</a></div></div>
<div class="ttc" id="aclassllvm_1_1detail_1_1UniqueFunctionBase_html_a33790c30f9d9cc8b0974d22eb6648ec1"><div class="ttname"><a href="classllvm_1_1detail_1_1UniqueFunctionBase.html#a33790c30f9d9cc8b0974d22eb6648ec1">llvm::detail::UniqueFunctionBase::getNonTrivialCallbacks</a></div><div class="ttdeci">NonTrivialCallbacks * getNonTrivialCallbacks() const</div><div class="ttdef"><b>Definition:</b> <a href="FunctionExtras_8h_source.html#l00182">FunctionExtras.h:182</a></div></div>
<div class="ttc" id="anamespacellvm_html_a69fae8413f8fd4cea02237fe8b0c00ed"><div class="ttname"><a href="namespacellvm.html#a69fae8413f8fd4cea02237fe8b0c00ed">llvm::allocate_buffer</a></div><div class="ttdeci">LLVM_ATTRIBUTE_RETURNS_NONNULL LLVM_ATTRIBUTE_RETURNS_NOALIAS void * allocate_buffer(size_t Size, size_t Alignment)</div><div class="ttdoc">Allocate a buffer of memory with the given size and alignment.</div><div class="ttdef"><b>Definition:</b> <a href="MemAlloc_8cpp_source.html#l00015">MemAlloc.cpp:15</a></div></div>
<div class="ttc" id="astructllvm_1_1detail_1_1UniqueFunctionBase_1_1CalledAs_html"><div class="ttname"><a href="structllvm_1_1detail_1_1UniqueFunctionBase_1_1CalledAs.html">llvm::detail::UniqueFunctionBase::CalledAs</a></div><div class="ttdef"><b>Definition:</b> <a href="FunctionExtras_8h_source.html#l00256">FunctionExtras.h:256</a></div></div>
<div class="ttc" id="aclassllvm_1_1detail_1_1UniqueFunctionBase_html_afc6639147fd23b870c9ed6e097176cac"><div class="ttname"><a href="classllvm_1_1detail_1_1UniqueFunctionBase.html#afc6639147fd23b870c9ed6e097176cac">llvm::detail::UniqueFunctionBase::getOutOfLineStorage</a></div><div class="ttdeci">void * getOutOfLineStorage() const</div><div class="ttdef"><b>Definition:</b> <a href="FunctionExtras_8h_source.html#l00202">FunctionExtras.h:202</a></div></div>
<div class="ttc" id="aclassllvm_1_1unique__function_3_01R_07P_8_8_8_08_01const_01_4_html_aec7783fd5f7e9ca0b6b0b35e8ded1de1"><div class="ttname"><a href="classllvm_1_1unique__function_3_01R_07P_8_8_8_08_01const_01_4.html#aec7783fd5f7e9ca0b6b0b35e8ded1de1">llvm::unique_function&lt; R(P...) const &gt;::unique_function</a></div><div class="ttdeci">unique_function(CallableT Callable, detail::EnableUnlessSameType&lt; CallableT, unique_function &gt; *=nullptr, detail::EnableIfCallable&lt; const CallableT, R, P... &gt; *=nullptr)</div><div class="ttdef"><b>Definition:</b> <a href="FunctionExtras_8h_source.html#l00401">FunctionExtras.h:401</a></div></div>
<div class="ttc" id="anamespacellvm_html_a6dd1aab3f9fa498fd6196a06fadbd984"><div class="ttname"><a href="namespacellvm.html#a6dd1aab3f9fa498fd6196a06fadbd984">llvm::deallocate_buffer</a></div><div class="ttdeci">void deallocate_buffer(void *Ptr, size_t Size, size_t Alignment)</div><div class="ttdoc">Deallocate a buffer of memory with the given size and alignment.</div><div class="ttdef"><b>Definition:</b> <a href="MemAlloc_8cpp_source.html#l00024">MemAlloc.cpp:24</a></div></div>
<div class="ttc" id="astructllvm_1_1detail_1_1UniqueFunctionBase_1_1IsSizeLessThanThresholdT_html"><div class="ttname"><a href="structllvm_1_1detail_1_1UniqueFunctionBase_1_1IsSizeLessThanThresholdT.html">llvm::detail::UniqueFunctionBase::IsSizeLessThanThresholdT</a></div><div class="ttdef"><b>Definition:</b> <a href="FunctionExtras_8h_source.html#l00084">FunctionExtras.h:84</a></div></div>
<div class="ttc" id="aMips16ISelLowering_8cpp_html_a0acb682b8260ab1c60b918599864e2e5"><div class="ttname"><a href="Mips16ISelLowering_8cpp.html#a0acb682b8260ab1c60b918599864e2e5">T</a></div><div class="ttdeci">#define T</div><div class="ttdef"><b>Definition:</b> <a href="Mips16ISelLowering_8cpp_source.html#l00341">Mips16ISelLowering.cpp:341</a></div></div>
<div class="ttc" id="anamespacellvm_1_1MipsISD_html_a422daf9aa810935178671306b651d69ba366e1eac31eeb1a1892d62ccfc0c8cf8"><div class="ttname"><a href="namespacellvm_1_1MipsISD.html#a422daf9aa810935178671306b651d69ba366e1eac31eeb1a1892d62ccfc0c8cf8">llvm::MipsISD::Ret</a></div><div class="ttdeci">@ Ret</div><div class="ttdef"><b>Definition:</b> <a href="MipsISelLowering_8h_source.html#l00119">MipsISelLowering.h:119</a></div></div>
<div class="ttc" id="aX86PartialReduction_8cpp_html_a87b8bfbbe9d8f7146d7f20a5fb42efd0"><div class="ttname"><a href="X86PartialReduction_8cpp.html#a87b8bfbbe9d8f7146d7f20a5fb42efd0">RHS</a></div><div class="ttdeci">Value * RHS</div><div class="ttdef"><b>Definition:</b> <a href="X86PartialReduction_8cpp_source.html#l00076">X86PartialReduction.cpp:76</a></div></div>
<div class="ttc" id="anamespacellvm_1_1RISCVFenceField_html_a147be9e9780c1e33363ea572d4c7b25fa1835091d83e0e052cd1a32c99b2be731"><div class="ttname"><a href="namespacellvm_1_1RISCVFenceField.html#a147be9e9780c1e33363ea572d4c7b25fa1835091d83e0e052cd1a32c99b2be731">llvm::RISCVFenceField::R</a></div><div class="ttdeci">@ R</div><div class="ttdef"><b>Definition:</b> <a href="RISCVBaseInfo_8h_source.html#l00278">RISCVBaseInfo.h:278</a></div></div>
<div class="ttc" id="aPointerIntPair_8h_html"><div class="ttname"><a href="PointerIntPair_8h.html">PointerIntPair.h</a></div></div>
<div class="ttc" id="aclassllvm_1_1detail_1_1UniqueFunctionBase_html_aae031d43fe520ab13f26ed4e64d322fc"><div class="ttname"><a href="classllvm_1_1detail_1_1UniqueFunctionBase.html#aae031d43fe520ab13f26ed4e64d322fc">llvm::detail::UniqueFunctionBase::CallImpl</a></div><div class="ttdeci">static ReturnT CallImpl(void *CallableAddr, AdjustedParamT&lt; ParamTs &gt;... Params)</div><div class="ttdef"><b>Definition:</b> <a href="FunctionExtras_8h_source.html#l00218">FunctionExtras.h:218</a></div></div>
<div class="ttc" id="astructllvm_1_1detail_1_1UniqueFunctionBase_1_1CallbacksHolder_3_01CallableT_00_01CalledAs_00_01E600272d61ae725b030f18ba3284cb420_html_a9fb32c2b52e0428024234887e9e9467a"><div class="ttname"><a href="structllvm_1_1detail_1_1UniqueFunctionBase_1_1CallbacksHolder_3_01CallableT_00_01CalledAs_00_01E600272d61ae725b030f18ba3284cb420.html#a9fb32c2b52e0428024234887e9e9467a">llvm::detail::UniqueFunctionBase::CallbacksHolder&lt; CallableT, CalledAs, EnableIfTrivial&lt; CallableT &gt; &gt;::Callbacks</a></div><div class="ttdeci">static TrivialCallback Callbacks</div><div class="ttdef"><b>Definition:</b> <a href="FunctionExtras_8h_source.html#l00252">FunctionExtras.h:252</a></div></div>
<div class="ttc" id="anamespacellvm_1_1detail_html_adda4c37ee77c163c1daf9fa242bd9408"><div class="ttname"><a href="namespacellvm_1_1detail.html#adda4c37ee77c163c1daf9fa242bd9408">llvm::detail::EnableUnlessSameType</a></div><div class="ttdeci">std::enable_if_t&lt;!std::is_same&lt; remove_cvref_t&lt; CallableT &gt;, ThisT &gt;::value &gt; EnableUnlessSameType</div><div class="ttdef"><b>Definition:</b> <a href="FunctionExtras_8h_source.html#l00066">FunctionExtras.h:66</a></div></div>
<div class="ttc" id="aclassllvm_1_1detail_1_1UniqueFunctionBase_html_a3f042ddd5a6cb8e0cee6575743d53ef7"><div class="ttname"><a href="classllvm_1_1detail_1_1UniqueFunctionBase.html#a3f042ddd5a6cb8e0cee6575743d53ef7">llvm::detail::UniqueFunctionBase::setOutOfLineStorage</a></div><div class="ttdeci">void setOutOfLineStorage(void *Ptr, size_t Size, size_t Alignment)</div><div class="ttdef"><b>Definition:</b> <a href="FunctionExtras_8h_source.html#l00213">FunctionExtras.h:213</a></div></div>
<div class="ttc" id="aclassllvm_1_1detail_1_1UniqueFunctionBase_html_afc8bea8bffe6f12ac46e3a44352f75eb"><div class="ttname"><a href="classllvm_1_1detail_1_1UniqueFunctionBase.html#afc8bea8bffe6f12ac46e3a44352f75eb">llvm::detail::UniqueFunctionBase::InlineStorageSize</a></div><div class="ttdeci">static constexpr size_t InlineStorageSize</div><div class="ttdef"><b>Definition:</b> <a href="FunctionExtras_8h_source.html#l00081">FunctionExtras.h:81</a></div></div>
<div class="ttc" id="aSTLForwardCompat_8h_html"><div class="ttname"><a href="STLForwardCompat_8h.html">STLForwardCompat.h</a></div></div>
<div class="ttc" id="aclassllvm_1_1detail_1_1UniqueFunctionBase_html_a3587453289f2ead89a5b8b547e4c0810"><div class="ttname"><a href="classllvm_1_1detail_1_1UniqueFunctionBase.html#a3587453289f2ead89a5b8b547e4c0810">llvm::detail::UniqueFunctionBase::getInlineStorage</a></div><div class="ttdeci">void * getInlineStorage() const</div><div class="ttdef"><b>Definition:</b> <a href="FunctionExtras_8h_source.html#l00201">FunctionExtras.h:201</a></div></div>
<div class="ttc" id="aclassllvm_1_1detail_1_1UniqueFunctionBase_html_a2701d4eee17002ff6595f7fcd47d9aef"><div class="ttname"><a href="classllvm_1_1detail_1_1UniqueFunctionBase.html#a2701d4eee17002ff6595f7fcd47d9aef">llvm::detail::UniqueFunctionBase::UniqueFunctionBase</a></div><div class="ttdeci">UniqueFunctionBase()=default</div></div>
<div class="ttc" id="aclassllvm_1_1detail_1_1UniqueFunctionBase_html_ad6d450e33cf5fff1101a1e8daabcd2b3"><div class="ttname"><a href="classllvm_1_1detail_1_1UniqueFunctionBase.html#ad6d450e33cf5fff1101a1e8daabcd2b3">llvm::detail::UniqueFunctionBase::UniqueFunctionBase</a></div><div class="ttdeci">UniqueFunctionBase(UniqueFunctionBase &amp;&amp;RHS) noexcept</div><div class="ttdef"><b>Definition:</b> <a href="FunctionExtras_8h_source.html#l00298">FunctionExtras.h:298</a></div></div>
<div class="ttc" id="aMemAlloc_8h_html"><div class="ttname"><a href="MemAlloc_8h.html">MemAlloc.h</a></div></div>
<div class="ttc" id="aREADME-X86-64_8txt_html_aac3add0badd5c39bebc02df0b5d9bdcf"><div class="ttname"><a href="README-X86-64_8txt.html#aac3add0badd5c39bebc02df0b5d9bdcf">type</a></div><div class="ttdeci">AMD64 Optimization Manual has some nice information about optimizing integer multiplication by a constant How much of it applies to Intel s X86 implementation There are definite trade offs to xmm0 cvttss2siq rdx jb L3 subss xmm0 rax cvttss2siq rdx xorq rdx rax ret instead of xmm1 cvttss2siq rcx movaps xmm2 subss xmm2 cvttss2siq rax rdx xorq rax ucomiss xmm0 cmovb rax ret Seems like the jb branch has high likelihood of being taken It would have saved a few instructions It s not possible to reference and DH registers in an instruction requiring REX prefix divb and mulb both produce results in AH If isel emits a CopyFromReg which gets turned into a movb and that can be allocated a r8b r15b To get around isel emits a CopyFromReg from AX and then right shift it down by and truncate it It s not pretty but it works We need some register allocation magic to make the hack go which would often require a callee saved register Callees usually need to keep this value live for most of their body so it doesn t add a significant burden on them We currently implement this in however this is suboptimal because it means that it would be quite awkward to implement the optimization for callers A better implementation would be to relax the LLVM IR rules for sret arguments to allow a function with an sret argument to have a non void return type</div><div class="ttdef"><b>Definition:</b> <a href="README-X86-64_8txt_source.html#l00070">README-X86-64.txt:70</a></div></div>
<div class="ttc" id="aAArch64PromoteConstant_8cpp_html_a90f8350fecae261c25be85d38b451bff"><div class="ttname"><a href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></div><div class="ttdeci">aarch64 promote const</div><div class="ttdef"><b>Definition:</b> <a href="AArch64PromoteConstant_8cpp_source.html#l00232">AArch64PromoteConstant.cpp:232</a></div></div>
<div class="ttc" id="alib_2Target_2ARM_2README_8txt_html_ad3a99906764c35b2694ae90fa57744a5"><div class="ttname"><a href="lib_2Target_2ARM_2README_8txt.html#ad3a99906764c35b2694ae90fa57744a5">move</a></div><div class="ttdeci">compiles ldr LCPI1_0 ldr ldr mov lsr tst moveq r1 ldr LCPI1_1 and r0 bx lr It would be better to do something like to fold the shift into the conditional move</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2ARM_2README_8txt_source.html#l00546">README.txt:546</a></div></div>
<div class="ttc" id="aclassllvm_1_1detail_1_1UniqueFunctionBase_html_a06c5bcbb18fc88bba5b8ebd1d545f7cf"><div class="ttname"><a href="classllvm_1_1detail_1_1UniqueFunctionBase.html#a06c5bcbb18fc88bba5b8ebd1d545f7cf">llvm::detail::UniqueFunctionBase::operator=</a></div><div class="ttdeci">UniqueFunctionBase &amp; operator=(UniqueFunctionBase &amp;&amp;RHS) noexcept</div><div class="ttdef"><b>Definition:</b> <a href="FunctionExtras_8h_source.html#l00327">FunctionExtras.h:327</a></div></div>
<div class="ttc" id="astructllvm_1_1is__trivially__move__constructible_html"><div class="ttname"><a href="structllvm_1_1is__trivially__move__constructible.html">llvm::is_trivially_move_constructible</a></div><div class="ttdoc">An implementation of std::is_trivially_move_constructible since we have users with STLs that don't ye...</div><div class="ttdef"><b>Definition:</b> <a href="type__traits_8h_source.html#l00109">type_traits.h:109</a></div></div>
<div class="ttc" id="anamespacellvm_1_1detail_html_a29ac72f534b5279feda1e95d06c4adbe"><div class="ttname"><a href="namespacellvm_1_1detail.html#a29ac72f534b5279feda1e95d06c4adbe">llvm::detail::EnableIfCallable</a></div><div class="ttdeci">std::enable_if_t&lt; std::disjunction&lt; std::is_void&lt; Ret &gt;, std::is_same&lt; decltype(std::declval&lt; CallableT &gt;()(std::declval&lt; Params &gt;()...)), Ret &gt;, std::is_same&lt; const decltype(std::declval&lt; CallableT &gt;()(std::declval&lt; Params &gt;()...)), Ret &gt;, std::is_convertible&lt; decltype(std::declval&lt; CallableT &gt;()(std::declval&lt; Params &gt;()...)), Ret &gt; &gt;::value &gt; EnableIfCallable</div><div class="ttdef"><b>Definition:</b> <a href="FunctionExtras_8h_source.html#l00077">FunctionExtras.h:77</a></div></div>
<div class="ttc" id="aclassllvm_1_1unique__function_3_01R_07P_8_8_8_08_01const_01_4_html_abf99cbdddb3f5145af41723b1edaed76"><div class="ttname"><a href="classllvm_1_1unique__function_3_01R_07P_8_8_8_08_01const_01_4.html#abf99cbdddb3f5145af41723b1edaed76">llvm::unique_function&lt; R(P...) const &gt;::operator()</a></div><div class="ttdeci">R operator()(P... Params) const</div><div class="ttdef"><b>Definition:</b> <a href="FunctionExtras_8h_source.html#l00408">FunctionExtras.h:408</a></div></div>
<div class="ttc" id="aclassllvm_1_1unique__function_3_01R_07P_8_8_8_08_4_html_a9db879718460106d106e4d1d512adeea"><div class="ttname"><a href="classllvm_1_1unique__function_3_01R_07P_8_8_8_08_4.html#a9db879718460106d106e4d1d512adeea">llvm::unique_function&lt; R(P...)&gt;::operator()</a></div><div class="ttdeci">R operator()(P... Params)</div><div class="ttdef"><b>Definition:</b> <a href="FunctionExtras_8h_source.html#l00382">FunctionExtras.h:382</a></div></div>
<div class="ttc" id="aclassllvm_1_1detail_1_1UniqueFunctionBase_html_a74463d3b6e49c6e6be3baf812d3f2699"><div class="ttname"><a href="classllvm_1_1detail_1_1UniqueFunctionBase.html#a74463d3b6e49c6e6be3baf812d3f2699">llvm::detail::UniqueFunctionBase::UniqueFunctionBase</a></div><div class="ttdeci">UniqueFunctionBase(CallableT Callable, CalledAs&lt; CalledAsT &gt;)</div><div class="ttdef"><b>Definition:</b> <a href="FunctionExtras_8h_source.html#l00262">FunctionExtras.h:262</a></div></div>
<div class="ttc" id="alib_2Target_2ARM_2README_8txt_html_ae2bb081d94f22e64ca6bc4bd58512a93"><div class="ttname"><a href="lib_2Target_2ARM_2README_8txt.html#ae2bb081d94f22e64ca6bc4bd58512a93">memcpy</a></div><div class="ttdeci">&lt;%struct.s * &gt; cast struct s *S to sbyte *&lt; sbyte * &gt; sbyte uint cast struct s *agg result to sbyte *&lt; sbyte * &gt; sbyte uint cast struct s *memtmp to sbyte *&lt; sbyte * &gt; sbyte uint ret void llc ends up issuing two memcpy or custom lower memcpy(of small size) to be ldmia/stmia. I think option 2 is better but the current register allocator cannot allocate a chunk of registers at a time. A feasible temporary solution is to use specific physical registers at the lowering time for small(&lt;</div></div>
<div class="ttc" id="aPointerUnion_8h_html"><div class="ttname"><a href="PointerUnion_8h.html">PointerUnion.h</a></div></div>
<div class="ttc" id="aTargetLibraryInfo_8cpp_html_aca185e6d0e9f423dbb24440206454872a11dbf501abf829b3ab7049c2d3a8a053"><div class="ttname"><a href="TargetLibraryInfo_8cpp.html#aca185e6d0e9f423dbb24440206454872a11dbf501abf829b3ab7049c2d3a8a053">Ptr</a></div><div class="ttdeci">@ Ptr</div><div class="ttdef"><b>Definition:</b> <a href="TargetLibraryInfo_8cpp_source.html#l00062">TargetLibraryInfo.cpp:62</a></div></div>
<div class="ttc" id="aclassllvm_1_1detail_1_1UniqueFunctionBase_html"><div class="ttname"><a href="classllvm_1_1detail_1_1UniqueFunctionBase.html">llvm::detail::UniqueFunctionBase</a></div><div class="ttdef"><b>Definition:</b> <a href="FunctionExtras_8h_source.html#l00079">FunctionExtras.h:79</a></div></div>
<div class="ttc" id="aclassllvm_1_1detail_1_1UniqueFunctionBase_html_a07d0691a7b2fa04f00be55fca6cbade5"><div class="ttname"><a href="classllvm_1_1detail_1_1UniqueFunctionBase.html#a07d0691a7b2fa04f00be55fca6cbade5">llvm::detail::UniqueFunctionBase::CallPtr</a></div><div class="ttdeci">struct IsSizeLessThanThresholdT&lt; T, std::enable_if_t&lt; sizeof(T)&lt;=2 *sizeof(void *)&gt; &gt; :std::true_type {};template&lt; typename T &gt; struct AdjustedParamTBase { static_assert(!std::is_reference&lt; T &gt;::value, &quot;references should be handled by template specialization&quot;);using type=std::conditional_t&lt; llvm::is_trivially_copy_constructible&lt; T &gt;::value &amp;&amp;llvm::is_trivially_move_constructible&lt; T &gt;::value &amp;&amp;IsSizeLessThanThresholdT&lt; T &gt;::value, T, T &amp; &gt;;};template&lt; typename T &gt; struct AdjustedParamTBase&lt; T &amp; &gt; { using type=T &amp;;};template&lt; typename T &gt; struct AdjustedParamTBase&lt; T &amp;&amp; &gt; { using type=T &amp;;};template&lt; typename T &gt; using AdjustedParamT=typename AdjustedParamTBase&lt; T &gt;::type;using CallPtrT=ReturnT(*)(void *CallableAddr, AdjustedParamT&lt; ParamTs &gt;... Params);using MovePtrT=void(*)(void *LHSCallableAddr, void *RHSCallableAddr);using DestroyPtrT=void(*)(void *CallableAddr);struct alignas(8) TrivialCallback { CallPtrT CallPtr;};struct alignas(8) NonTrivialCallbacks { CallPtrT CallPtr;MovePtrT MovePtr;DestroyPtrT DestroyPtr;};using CallbackPointerUnionT=PointerUnion&lt; TrivialCallback *, NonTrivialCallbacks * &gt;;union StorageUnionT { struct OutOfLineStorageT { void *StoragePtr;size_t Size;size_t Alignment;} OutOfLineStorage;static_assert(sizeof(OutOfLineStorageT)&lt;=InlineStorageSize, &quot;Should always use all of the out-of-line storage for inline storage!&quot;);mutable std::aligned_storage_t&lt; InlineStorageSize, alignof(void *)&gt; InlineStorage;} StorageUnion;PointerIntPair&lt; CallbackPointerUnionT, 1, bool &gt; CallbackAndInlineFlag;bool isInlineStorage() const { return CallbackAndInlineFlag.getInt();} bool isTrivialCallback() const { return CallbackAndInlineFlag.getPointer().template is&lt; TrivialCallback * &gt;();} CallPtrT getTrivialCallback() const { return CallbackAndInlineFlag.getPointer().template get&lt; TrivialCallback * &gt;() -&gt; CallPtr</div><div class="ttdef"><b>Definition:</b> <a href="FunctionExtras_8h_source.html#l00087">FunctionExtras.h:87</a></div></div>
<div class="ttc" id="astructllvm_1_1is__trivially__copy__constructible_html"><div class="ttname"><a href="structllvm_1_1is__trivially__copy__constructible.html">llvm::is_trivially_copy_constructible</a></div><div class="ttdoc">An implementation of std::is_trivially_copy_constructible since we have users with STLs that don't ye...</div><div class="ttdef"><b>Definition:</b> <a href="type__traits_8h_source.html#l00098">type_traits.h:98</a></div></div>
<div class="ttc" id="astructllvm_1_1detail_1_1UniqueFunctionBase_1_1CallbacksHolder_html"><div class="ttname"><a href="structllvm_1_1detail_1_1UniqueFunctionBase_1_1CallbacksHolder.html">llvm::detail::UniqueFunctionBase::CallbacksHolder</a></div><div class="ttdef"><b>Definition:</b> <a href="FunctionExtras_8h_source.html#l00244">FunctionExtras.h:244</a></div></div>
<div class="ttc" id="aclassllvm_1_1unique__function_3_01R_07P_8_8_8_08_4_html_a545b1f13a02cc090f382b2263f5c8a53"><div class="ttname"><a href="classllvm_1_1unique__function_3_01R_07P_8_8_8_08_4.html#a545b1f13a02cc090f382b2263f5c8a53">llvm::unique_function&lt; R(P...)&gt;::unique_function</a></div><div class="ttdeci">unique_function(CallableT Callable, detail::EnableUnlessSameType&lt; CallableT, unique_function &gt; *=nullptr, detail::EnableIfCallable&lt; CallableT, R, P... &gt; *=nullptr)</div><div class="ttdef"><b>Definition:</b> <a href="FunctionExtras_8h_source.html#l00375">FunctionExtras.h:375</a></div></div>
<div class="ttc" id="anamespacestd_html"><div class="ttname"><a href="namespacestd.html">std</a></div><div class="ttdef"><b>Definition:</b> <a href="BitVector_8h_source.html#l00851">BitVector.h:851</a></div></div>
<div class="ttc" id="atype__traits_8h_html"><div class="ttname"><a href="type__traits_8h.html">type_traits.h</a></div></div>
<div class="ttc" id="aclassllvm_1_1unique__function_3_01R_07P_8_8_8_08_4_html_ad9c327569d1e967871ab24adbc385009"><div class="ttname"><a href="classllvm_1_1unique__function_3_01R_07P_8_8_8_08_4.html#ad9c327569d1e967871ab24adbc385009">llvm::unique_function&lt; R(P...)&gt;::unique_function</a></div><div class="ttdeci">unique_function(std::nullptr_t)</div><div class="ttdef"><b>Definition:</b> <a href="FunctionExtras_8h_source.html#l00368">FunctionExtras.h:368</a></div></div>
<div class="ttc" id="aclassllvm_1_1detail_1_1UniqueFunctionBase_html_a849a2dcfcd3f773ce640d6a1c1df3f5f"><div class="ttname"><a href="classllvm_1_1detail_1_1UniqueFunctionBase.html#a849a2dcfcd3f773ce640d6a1c1df3f5f">llvm::detail::UniqueFunctionBase::DestroyImpl</a></div><div class="ttdeci">static void DestroyImpl(void *CallableAddr) noexcept</div><div class="ttdef"><b>Definition:</b> <a href="FunctionExtras_8h_source.html#l00231">FunctionExtras.h:231</a></div></div>
<div class="ttc" id="astructllvm_1_1detail_1_1UniqueFunctionBase_1_1CallbacksHolder_html_a7bddc8b1812fb9623d9046e91a767914"><div class="ttname"><a href="structllvm_1_1detail_1_1UniqueFunctionBase_1_1CallbacksHolder.html#a7bddc8b1812fb9623d9046e91a767914">llvm::detail::UniqueFunctionBase::CallbacksHolder::Callbacks</a></div><div class="ttdeci">static NonTrivialCallbacks Callbacks</div><div class="ttdef"><b>Definition:</b> <a href="FunctionExtras_8h_source.html#l00245">FunctionExtras.h:245</a></div></div>
<div class="ttc" id="aclassllvm_1_1detail_1_1UniqueFunctionBase_html_a0166f36c59bf23f7a969796f3b160120"><div class="ttname"><a href="classllvm_1_1detail_1_1UniqueFunctionBase.html#a0166f36c59bf23f7a969796f3b160120">llvm::detail::UniqueFunctionBase::getCallPtr</a></div><div class="ttdeci">CallPtrT getCallPtr() const</div><div class="ttdef"><b>Definition:</b> <a href="FunctionExtras_8h_source.html#l00187">FunctionExtras.h:187</a></div></div>
<div class="ttc" id="aclassllvm_1_1detail_1_1UniqueFunctionBase_html_ac2ee20db0af7f93b577dddb3e9637478"><div class="ttname"><a href="classllvm_1_1detail_1_1UniqueFunctionBase.html#ac2ee20db0af7f93b577dddb3e9637478">llvm::detail::UniqueFunctionBase::getOutOfLineStorageAlignment</a></div><div class="ttdeci">size_t getOutOfLineStorageAlignment() const</div><div class="ttdef"><b>Definition:</b> <a href="FunctionExtras_8h_source.html#l00209">FunctionExtras.h:209</a></div></div>
<div class="ttc" id="anamespacellvm_1_1detail_html_a5e379eb0e8afa7d6acbceca9906572ac"><div class="ttname"><a href="namespacellvm_1_1detail.html#a5e379eb0e8afa7d6acbceca9906572ac">llvm::detail::EnableIfTrivial</a></div><div class="ttdeci">std::enable_if_t&lt; llvm::is_trivially_move_constructible&lt; T &gt;::value &amp;&amp;std::is_trivially_destructible&lt; T &gt;::value &gt; EnableIfTrivial</div><div class="ttdef"><b>Definition:</b> <a href="FunctionExtras_8h_source.html#l00063">FunctionExtras.h:63</a></div></div>
<div class="ttc" id="aclassllvm_1_1unique__function_3_01R_07P_8_8_8_08_01const_01_4_html_a39a45cfca860a2b5b097fe5213bfa298"><div class="ttname"><a href="classllvm_1_1unique__function_3_01R_07P_8_8_8_08_01const_01_4.html#a39a45cfca860a2b5b097fe5213bfa298">llvm::unique_function&lt; R(P...) const &gt;::unique_function</a></div><div class="ttdeci">unique_function(std::nullptr_t)</div><div class="ttdef"><b>Definition:</b> <a href="FunctionExtras_8h_source.html#l00394">FunctionExtras.h:394</a></div></div>
<div class="ttc" id="aclassllvm_1_1detail_1_1UniqueFunctionBase_html_a288074261a390b844e1bb895827aae96"><div class="ttname"><a href="classllvm_1_1detail_1_1UniqueFunctionBase.html#a288074261a390b844e1bb895827aae96">llvm::detail::UniqueFunctionBase::~UniqueFunctionBase</a></div><div class="ttdeci">~UniqueFunctionBase()</div><div class="ttdef"><b>Definition:</b> <a href="FunctionExtras_8h_source.html#l00282">FunctionExtras.h:282</a></div></div>
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Aug 7 2023 09:40:09 for LLVM by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
