<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>LLVM: include/llvm/Demangle/StringView.h Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">LLVM
   &#160;<span id="projectnumber">17.0.0git</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_d44c64559bbebec7f509842c48db8b23.html">include</a></li><li class="navelem"><a class="el" href="dir_dcde91663b8816e1e2311938ccd8f690.html">llvm</a></li><li class="navelem"><a class="el" href="dir_ae9b4aaab5ddeccec40141a6cf910669.html">Demangle</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">StringView.h</div>  </div>
</div><!--header-->
<div class="contents">
<a href="StringView_8h.html">Go to the documentation of this file.</a><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;<span class="comment">//===--- StringView.h ----------------*- mode:c++;eval:(read-only-mode) -*-===//</span></div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;<span class="comment">//       Do not edit! See README.txt.</span></div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;<span class="comment">// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.</span></div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;<span class="comment">// See https://llvm.org/LICENSE.txt for license information.</span></div>
<div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;<span class="comment">// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception</span></div>
<div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;<span class="comment">//</span></div>
<div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;<span class="comment">//===----------------------------------------------------------------------===//</span></div>
<div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;<span class="comment">//</span></div>
<div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;<span class="comment">// FIXME: Use std::string_view instead when we support C++17.</span></div>
<div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;<span class="comment">// There are two copies of this file in the source tree.  The one under</span></div>
<div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;<span class="comment">// libcxxabi is the original and the one under llvm is the copy.  Use</span></div>
<div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;<span class="comment">// cp-to-llvm.sh to update the copy.  See README.txt for more details.</span></div>
<div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;<span class="comment">//</span></div>
<div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;<span class="comment">//===----------------------------------------------------------------------===//</span></div>
<div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160; </div>
<div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160;<span class="preprocessor">#ifndef DEMANGLE_STRINGVIEW_H</span></div>
<div class="line"><a name="l00017"></a><span class="lineno">   17</span>&#160;<span class="preprocessor">#define DEMANGLE_STRINGVIEW_H</span></div>
<div class="line"><a name="l00018"></a><span class="lineno">   18</span>&#160; </div>
<div class="line"><a name="l00019"></a><span class="lineno">   19</span>&#160;<span class="preprocessor">#include &quot;<a class="code" href="DemangleConfig_8h.html">DemangleConfig.h</a>&quot;</span></div>
<div class="line"><a name="l00020"></a><span class="lineno">   20</span>&#160;<span class="preprocessor">#include &lt;cassert&gt;</span></div>
<div class="line"><a name="l00021"></a><span class="lineno">   21</span>&#160;<span class="preprocessor">#include &lt;cstring&gt;</span></div>
<div class="line"><a name="l00022"></a><span class="lineno">   22</span>&#160; </div>
<div class="line"><a name="l00023"></a><span class="lineno">   23</span>&#160;<a class="code" href="DemangleConfig_8h.html#ad82d307eb10a0e447f4b254f0af7dde7">DEMANGLE_NAMESPACE_BEGIN</a></div>
<div class="line"><a name="l00024"></a><span class="lineno">   24</span>&#160; </div>
<div class="line"><a name="l00025"></a><span class="lineno"><a class="line" href="classStringView.html">   25</a></span>&#160;<span class="keyword">class </span><a class="code" href="classStringView.html">StringView</a> {</div>
<div class="line"><a name="l00026"></a><span class="lineno">   26</span>&#160;  <span class="keyword">const</span> <span class="keywordtype">char</span> *First;</div>
<div class="line"><a name="l00027"></a><span class="lineno">   27</span>&#160;  <span class="keyword">const</span> <span class="keywordtype">char</span> *Last;</div>
<div class="line"><a name="l00028"></a><span class="lineno">   28</span>&#160; </div>
<div class="line"><a name="l00029"></a><span class="lineno">   29</span>&#160;<span class="keyword">public</span>:</div>
<div class="line"><a name="l00030"></a><span class="lineno"><a class="line" href="classStringView.html#a7b7e9d4488195df865a0dae09338702e">   30</a></span>&#160;  <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">size_t</span> <a class="code" href="classStringView.html#a7b7e9d4488195df865a0dae09338702e">npos</a> = ~size_t(0);</div>
<div class="line"><a name="l00031"></a><span class="lineno">   31</span>&#160; </div>
<div class="line"><a name="l00032"></a><span class="lineno">   32</span>&#160;  <span class="keyword">template</span> &lt;<span class="keywordtype">size_t</span> N&gt;</div>
<div class="line"><a name="l00033"></a><span class="lineno"><a class="line" href="classStringView.html#ac6b0c8dc91ff0f53ceb554091519b5ac">   33</a></span>&#160;  <a class="code" href="classStringView.html#ac6b0c8dc91ff0f53ceb554091519b5ac">StringView</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> (&amp;Str)[<a class="code" href="regcomp_8c.html#a0240ac851181b84ac374872dc5434ee4">N</a>]) : <a class="code" href="lib_2Target_2README_8txt.html#ab24db72f7bd10b13351812874015861b">First</a>(Str), Last(Str + <a class="code" href="regcomp_8c.html#a0240ac851181b84ac374872dc5434ee4">N</a> - 1) {}</div>
<div class="line"><a name="l00034"></a><span class="lineno"><a class="line" href="classStringView.html#a0160a9a200781152345163439bb90b38">   34</a></span>&#160;  <a class="code" href="classStringView.html#a0160a9a200781152345163439bb90b38">StringView</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *First_, <span class="keyword">const</span> <span class="keywordtype">char</span> *Last_)</div>
<div class="line"><a name="l00035"></a><span class="lineno">   35</span>&#160;      : <a class="code" href="lib_2Target_2README_8txt.html#ab24db72f7bd10b13351812874015861b">First</a>(First_), Last(Last_) {}</div>
<div class="line"><a name="l00036"></a><span class="lineno"><a class="line" href="classStringView.html#ab4be372359105725591143c73b28c73e">   36</a></span>&#160;  <a class="code" href="classStringView.html#ab4be372359105725591143c73b28c73e">StringView</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *First_, <span class="keywordtype">size_t</span> Len)</div>
<div class="line"><a name="l00037"></a><span class="lineno">   37</span>&#160;      : <a class="code" href="lib_2Target_2README_8txt.html#ab24db72f7bd10b13351812874015861b">First</a>(First_), Last(First_ + Len) {}</div>
<div class="line"><a name="l00038"></a><span class="lineno"><a class="line" href="classStringView.html#a70ff79f8b666f2d777a54950c1dabb4b">   38</a></span>&#160;  <a class="code" href="classStringView.html#a70ff79f8b666f2d777a54950c1dabb4b">StringView</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *Str) : <a class="code" href="lib_2Target_2README_8txt.html#ab24db72f7bd10b13351812874015861b">First</a>(Str), Last(Str + <a class="code" href="namespacestd.html">std</a>::strlen(Str)) {}</div>
<div class="line"><a name="l00039"></a><span class="lineno"><a class="line" href="classStringView.html#a185f13d8300330e0f206f0ac8a27f824">   39</a></span>&#160;  <a class="code" href="classStringView.html#a185f13d8300330e0f206f0ac8a27f824">StringView</a>() : <a class="code" href="lib_2Target_2README_8txt.html#ab24db72f7bd10b13351812874015861b">First</a>(nullptr), Last(nullptr) {}</div>
<div class="line"><a name="l00040"></a><span class="lineno">   40</span>&#160; </div>
<div class="line"><a name="l00041"></a><span class="lineno"><a class="line" href="classStringView.html#a7862563af6397ffdffe88f619ce93390">   41</a></span>&#160;  <a class="code" href="classStringView.html">StringView</a> <a class="code" href="classStringView.html#a7862563af6397ffdffe88f619ce93390">substr</a>(<span class="keywordtype">size_t</span> Pos, <span class="keywordtype">size_t</span> Len = <a class="code" href="classStringView.html#a7b7e9d4488195df865a0dae09338702e">npos</a>)<span class="keyword"> const </span>{</div>
<div class="line"><a name="l00042"></a><span class="lineno">   42</span>&#160;    <a class="code" href="SILowerControlFlow_8cpp.html#a4868c5d81c5ccc98c47aeab6244346a0">assert</a>(Pos &lt;= <a class="code" href="classStringView.html#abcc0f1dfe0a436e90525248bc19a5b73">size</a>());</div>
<div class="line"><a name="l00043"></a><span class="lineno">   43</span>&#160;    <span class="keywordflow">if</span> (Len &gt; <a class="code" href="classStringView.html#abcc0f1dfe0a436e90525248bc19a5b73">size</a>() - Pos)</div>
<div class="line"><a name="l00044"></a><span class="lineno">   44</span>&#160;      Len = <a class="code" href="classStringView.html#abcc0f1dfe0a436e90525248bc19a5b73">size</a>() - Pos;</div>
<div class="line"><a name="l00045"></a><span class="lineno">   45</span>&#160;    <span class="keywordflow">return</span> <a class="code" href="classStringView.html#a185f13d8300330e0f206f0ac8a27f824">StringView</a>(<a class="code" href="classStringView.html#ae8fa8baca6ed81993c3a4833854937a0">begin</a>() + Pos, Len);</div>
<div class="line"><a name="l00046"></a><span class="lineno">   46</span>&#160;  }</div>
<div class="line"><a name="l00047"></a><span class="lineno">   47</span>&#160; </div>
<div class="line"><a name="l00048"></a><span class="lineno"><a class="line" href="classStringView.html#af632623580840d68b2fcea9fd6504533">   48</a></span>&#160;  <span class="keywordtype">size_t</span> <a class="code" href="classStringView.html#af632623580840d68b2fcea9fd6504533">find</a>(<span class="keywordtype">char</span> <a class="code" href="README__ALTIVEC_8txt.html#a9aacd9146afe44bf656cd664e2a88c8c">C</a>, <span class="keywordtype">size_t</span> <a class="code" href="BlockVerifier_8cpp.html#ae45c7d73c0ff5d177b59153ffae77f84">From</a> = 0)<span class="keyword"> const </span>{</div>
<div class="line"><a name="l00049"></a><span class="lineno">   49</span>&#160;    <span class="comment">// Avoid calling memchr with nullptr.</span></div>
<div class="line"><a name="l00050"></a><span class="lineno">   50</span>&#160;    <span class="keywordflow">if</span> (<a class="code" href="BlockVerifier_8cpp.html#ae45c7d73c0ff5d177b59153ffae77f84">From</a> &lt; <a class="code" href="classStringView.html#abcc0f1dfe0a436e90525248bc19a5b73">size</a>()) {</div>
<div class="line"><a name="l00051"></a><span class="lineno">   51</span>&#160;      <span class="comment">// Just forward to memchr, which is faster than a hand-rolled loop.</span></div>
<div class="line"><a name="l00052"></a><span class="lineno">   52</span>&#160;      <span class="keywordflow">if</span> (<span class="keyword">const</span> <span class="keywordtype">void</span> *<a class="code" href="README-SSE_8txt.html#a63d206a063eefcdf8c318ded97b65020">P</a> = ::memchr(<a class="code" href="lib_2Target_2README_8txt.html#ab24db72f7bd10b13351812874015861b">First</a> + <a class="code" href="BlockVerifier_8cpp.html#ae45c7d73c0ff5d177b59153ffae77f84">From</a>, <a class="code" href="README__ALTIVEC_8txt.html#a9aacd9146afe44bf656cd664e2a88c8c">C</a>, <a class="code" href="classStringView.html#abcc0f1dfe0a436e90525248bc19a5b73">size</a>() - <a class="code" href="BlockVerifier_8cpp.html#ae45c7d73c0ff5d177b59153ffae77f84">From</a>))</div>
<div class="line"><a name="l00053"></a><span class="lineno">   53</span>&#160;        <span class="keywordflow">return</span> size_t(<span class="keyword">static_cast&lt;</span><span class="keyword">const </span><span class="keywordtype">char</span> *<span class="keyword">&gt;</span>(<a class="code" href="README-SSE_8txt.html#a63d206a063eefcdf8c318ded97b65020">P</a>) - <a class="code" href="lib_2Target_2README_8txt.html#ab24db72f7bd10b13351812874015861b">First</a>);</div>
<div class="line"><a name="l00054"></a><span class="lineno">   54</span>&#160;    }</div>
<div class="line"><a name="l00055"></a><span class="lineno">   55</span>&#160;    <span class="keywordflow">return</span> <a class="code" href="classStringView.html#a7b7e9d4488195df865a0dae09338702e">npos</a>;</div>
<div class="line"><a name="l00056"></a><span class="lineno">   56</span>&#160;  }</div>
<div class="line"><a name="l00057"></a><span class="lineno">   57</span>&#160; </div>
<div class="line"><a name="l00058"></a><span class="lineno"><a class="line" href="classStringView.html#a934c67d07c59bf2f3f5e3018e1e56b53">   58</a></span>&#160;  <a class="code" href="classStringView.html">StringView</a> <a class="code" href="classStringView.html#a934c67d07c59bf2f3f5e3018e1e56b53">dropFront</a>(<span class="keywordtype">size_t</span> <a class="code" href="regcomp_8c.html#a0240ac851181b84ac374872dc5434ee4">N</a> = 1)<span class="keyword"> const </span>{</div>
<div class="line"><a name="l00059"></a><span class="lineno">   59</span>&#160;    <span class="keywordflow">if</span> (<a class="code" href="regcomp_8c.html#a0240ac851181b84ac374872dc5434ee4">N</a> &gt;= <a class="code" href="classStringView.html#abcc0f1dfe0a436e90525248bc19a5b73">size</a>())</div>
<div class="line"><a name="l00060"></a><span class="lineno">   60</span>&#160;      <a class="code" href="regcomp_8c.html#a0240ac851181b84ac374872dc5434ee4">N</a> = <a class="code" href="classStringView.html#abcc0f1dfe0a436e90525248bc19a5b73">size</a>();</div>
<div class="line"><a name="l00061"></a><span class="lineno">   61</span>&#160;    <span class="keywordflow">return</span> <a class="code" href="classStringView.html#a185f13d8300330e0f206f0ac8a27f824">StringView</a>(<a class="code" href="lib_2Target_2README_8txt.html#ab24db72f7bd10b13351812874015861b">First</a> + <a class="code" href="regcomp_8c.html#a0240ac851181b84ac374872dc5434ee4">N</a>, Last);</div>
<div class="line"><a name="l00062"></a><span class="lineno">   62</span>&#160;  }</div>
<div class="line"><a name="l00063"></a><span class="lineno">   63</span>&#160; </div>
<div class="line"><a name="l00064"></a><span class="lineno"><a class="line" href="classStringView.html#a1a45a4e6becbee87f654ec5024c2b432">   64</a></span>&#160;  <a class="code" href="classStringView.html">StringView</a> <a class="code" href="classStringView.html#a1a45a4e6becbee87f654ec5024c2b432">dropBack</a>(<span class="keywordtype">size_t</span> <a class="code" href="regcomp_8c.html#a0240ac851181b84ac374872dc5434ee4">N</a> = 1)<span class="keyword"> const </span>{</div>
<div class="line"><a name="l00065"></a><span class="lineno">   65</span>&#160;    <span class="keywordflow">if</span> (<a class="code" href="regcomp_8c.html#a0240ac851181b84ac374872dc5434ee4">N</a> &gt;= <a class="code" href="classStringView.html#abcc0f1dfe0a436e90525248bc19a5b73">size</a>())</div>
<div class="line"><a name="l00066"></a><span class="lineno">   66</span>&#160;      <a class="code" href="regcomp_8c.html#a0240ac851181b84ac374872dc5434ee4">N</a> = <a class="code" href="classStringView.html#abcc0f1dfe0a436e90525248bc19a5b73">size</a>();</div>
<div class="line"><a name="l00067"></a><span class="lineno">   67</span>&#160;    <span class="keywordflow">return</span> <a class="code" href="classStringView.html#a185f13d8300330e0f206f0ac8a27f824">StringView</a>(<a class="code" href="lib_2Target_2README_8txt.html#ab24db72f7bd10b13351812874015861b">First</a>, Last - <a class="code" href="regcomp_8c.html#a0240ac851181b84ac374872dc5434ee4">N</a>);</div>
<div class="line"><a name="l00068"></a><span class="lineno">   68</span>&#160;  }</div>
<div class="line"><a name="l00069"></a><span class="lineno">   69</span>&#160; </div>
<div class="line"><a name="l00070"></a><span class="lineno"><a class="line" href="classStringView.html#a359fe9ffc3eb7a64aa6f42aa8d373151">   70</a></span>&#160;  <span class="keywordtype">char</span> <a class="code" href="classStringView.html#a359fe9ffc3eb7a64aa6f42aa8d373151">front</a>()<span class="keyword"> const </span>{</div>
<div class="line"><a name="l00071"></a><span class="lineno">   71</span>&#160;    <a class="code" href="SILowerControlFlow_8cpp.html#a4868c5d81c5ccc98c47aeab6244346a0">assert</a>(!<a class="code" href="classStringView.html#ae65a04775aac67a1e107b451d0451bc6">empty</a>());</div>
<div class="line"><a name="l00072"></a><span class="lineno">   72</span>&#160;    <span class="keywordflow">return</span> *<a class="code" href="classStringView.html#ae8fa8baca6ed81993c3a4833854937a0">begin</a>();</div>
<div class="line"><a name="l00073"></a><span class="lineno">   73</span>&#160;  }</div>
<div class="line"><a name="l00074"></a><span class="lineno">   74</span>&#160; </div>
<div class="line"><a name="l00075"></a><span class="lineno"><a class="line" href="classStringView.html#a98a29f9ba7e329b7a445e17ddffeb0fa">   75</a></span>&#160;  <span class="keywordtype">char</span> <a class="code" href="classStringView.html#a98a29f9ba7e329b7a445e17ddffeb0fa">back</a>()<span class="keyword"> const </span>{</div>
<div class="line"><a name="l00076"></a><span class="lineno">   76</span>&#160;    <a class="code" href="SILowerControlFlow_8cpp.html#a4868c5d81c5ccc98c47aeab6244346a0">assert</a>(!<a class="code" href="classStringView.html#ae65a04775aac67a1e107b451d0451bc6">empty</a>());</div>
<div class="line"><a name="l00077"></a><span class="lineno">   77</span>&#160;    <span class="keywordflow">return</span> *(<a class="code" href="classStringView.html#a7f2ffb885adbde9d847c15600469c2bb">end</a>() - 1);</div>
<div class="line"><a name="l00078"></a><span class="lineno">   78</span>&#160;  }</div>
<div class="line"><a name="l00079"></a><span class="lineno">   79</span>&#160; </div>
<div class="line"><a name="l00080"></a><span class="lineno"><a class="line" href="classStringView.html#a7319efa03001871969255b9b7760136a">   80</a></span>&#160;  <span class="keywordtype">char</span> <a class="code" href="classStringView.html#a7319efa03001871969255b9b7760136a">popFront</a>() {</div>
<div class="line"><a name="l00081"></a><span class="lineno">   81</span>&#160;    <a class="code" href="SILowerControlFlow_8cpp.html#a4868c5d81c5ccc98c47aeab6244346a0">assert</a>(!<a class="code" href="classStringView.html#ae65a04775aac67a1e107b451d0451bc6">empty</a>());</div>
<div class="line"><a name="l00082"></a><span class="lineno">   82</span>&#160;    <span class="keywordflow">return</span> *<a class="code" href="lib_2Target_2README_8txt.html#ab24db72f7bd10b13351812874015861b">First</a>++;</div>
<div class="line"><a name="l00083"></a><span class="lineno">   83</span>&#160;  }</div>
<div class="line"><a name="l00084"></a><span class="lineno">   84</span>&#160; </div>
<div class="line"><a name="l00085"></a><span class="lineno"><a class="line" href="classStringView.html#a6c08589e09d7bb55cf1c1c8674ddb473">   85</a></span>&#160;  <span class="keywordtype">bool</span> <a class="code" href="classStringView.html#a6c08589e09d7bb55cf1c1c8674ddb473">consumeFront</a>(<span class="keywordtype">char</span> <a class="code" href="README__ALTIVEC_8txt.html#a9aacd9146afe44bf656cd664e2a88c8c">C</a>) {</div>
<div class="line"><a name="l00086"></a><span class="lineno">   86</span>&#160;    <span class="keywordflow">if</span> (!<a class="code" href="classStringView.html#a45dbb689c358805d44b8ce233582fa95">startsWith</a>(<a class="code" href="README__ALTIVEC_8txt.html#a9aacd9146afe44bf656cd664e2a88c8c">C</a>))</div>
<div class="line"><a name="l00087"></a><span class="lineno">   87</span>&#160;      <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><a name="l00088"></a><span class="lineno">   88</span>&#160;    *<span class="keyword">this</span> = <a class="code" href="classStringView.html#a934c67d07c59bf2f3f5e3018e1e56b53">dropFront</a>(1);</div>
<div class="line"><a name="l00089"></a><span class="lineno">   89</span>&#160;    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line"><a name="l00090"></a><span class="lineno">   90</span>&#160;  }</div>
<div class="line"><a name="l00091"></a><span class="lineno">   91</span>&#160; </div>
<div class="line"><a name="l00092"></a><span class="lineno"><a class="line" href="classStringView.html#ac6a261495b8a876756bd5554efc7a80f">   92</a></span>&#160;  <span class="keywordtype">bool</span> <a class="code" href="classStringView.html#ac6a261495b8a876756bd5554efc7a80f">consumeFront</a>(<a class="code" href="classStringView.html">StringView</a> <a class="code" href="lib_2Target_2ARM_2README_8txt.html#a1b45f45820a60c09244a87eb59824aec">S</a>) {</div>
<div class="line"><a name="l00093"></a><span class="lineno">   93</span>&#160;    <span class="keywordflow">if</span> (!<a class="code" href="classStringView.html#a45dbb689c358805d44b8ce233582fa95">startsWith</a>(<a class="code" href="lib_2Target_2ARM_2README_8txt.html#a1b45f45820a60c09244a87eb59824aec">S</a>))</div>
<div class="line"><a name="l00094"></a><span class="lineno">   94</span>&#160;      <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><a name="l00095"></a><span class="lineno">   95</span>&#160;    *<span class="keyword">this</span> = <a class="code" href="classStringView.html#a934c67d07c59bf2f3f5e3018e1e56b53">dropFront</a>(<a class="code" href="lib_2Target_2ARM_2README_8txt.html#a1b45f45820a60c09244a87eb59824aec">S</a>.size());</div>
<div class="line"><a name="l00096"></a><span class="lineno">   96</span>&#160;    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line"><a name="l00097"></a><span class="lineno">   97</span>&#160;  }</div>
<div class="line"><a name="l00098"></a><span class="lineno">   98</span>&#160; </div>
<div class="line"><a name="l00099"></a><span class="lineno"><a class="line" href="classStringView.html#a45dbb689c358805d44b8ce233582fa95">   99</a></span>&#160;  <span class="keywordtype">bool</span> <a class="code" href="classStringView.html#a45dbb689c358805d44b8ce233582fa95">startsWith</a>(<span class="keywordtype">char</span> <a class="code" href="README__ALTIVEC_8txt.html#a9aacd9146afe44bf656cd664e2a88c8c">C</a>)<span class="keyword"> const </span>{ <span class="keywordflow">return</span> !<a class="code" href="classStringView.html#ae65a04775aac67a1e107b451d0451bc6">empty</a>() &amp;&amp; *<a class="code" href="classStringView.html#ae8fa8baca6ed81993c3a4833854937a0">begin</a>() == <a class="code" href="README__ALTIVEC_8txt.html#a9aacd9146afe44bf656cd664e2a88c8c">C</a>; }</div>
<div class="line"><a name="l00100"></a><span class="lineno">  100</span>&#160; </div>
<div class="line"><a name="l00101"></a><span class="lineno"><a class="line" href="classStringView.html#aed7c7638f6c0cbcac746e912805f7f39">  101</a></span>&#160;  <span class="keywordtype">bool</span> <a class="code" href="classStringView.html#aed7c7638f6c0cbcac746e912805f7f39">startsWith</a>(<a class="code" href="classStringView.html">StringView</a> Str)<span class="keyword"> const </span>{</div>
<div class="line"><a name="l00102"></a><span class="lineno">  102</span>&#160;    <span class="keywordflow">if</span> (Str.size() &gt; <a class="code" href="classStringView.html#abcc0f1dfe0a436e90525248bc19a5b73">size</a>())</div>
<div class="line"><a name="l00103"></a><span class="lineno">  103</span>&#160;      <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><a name="l00104"></a><span class="lineno">  104</span>&#160;    <span class="keywordflow">return</span> std::strncmp(Str.begin(), <a class="code" href="classStringView.html#ae8fa8baca6ed81993c3a4833854937a0">begin</a>(), Str.size()) == 0;</div>
<div class="line"><a name="l00105"></a><span class="lineno">  105</span>&#160;  }</div>
<div class="line"><a name="l00106"></a><span class="lineno">  106</span>&#160; </div>
<div class="line"><a name="l00107"></a><span class="lineno"><a class="line" href="classStringView.html#ab17adafca67f1ce7a532a32b6f866fbc">  107</a></span>&#160;  <span class="keyword">const</span> <span class="keywordtype">char</span> &amp;<a class="code" href="classStringView.html#ab17adafca67f1ce7a532a32b6f866fbc">operator[]</a>(<span class="keywordtype">size_t</span> Idx)<span class="keyword"> const </span>{ <span class="keywordflow">return</span> *(<a class="code" href="classStringView.html#ae8fa8baca6ed81993c3a4833854937a0">begin</a>() + Idx); }</div>
<div class="line"><a name="l00108"></a><span class="lineno">  108</span>&#160; </div>
<div class="line"><a name="l00109"></a><span class="lineno"><a class="line" href="classStringView.html#ae8fa8baca6ed81993c3a4833854937a0">  109</a></span>&#160;  <span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="classStringView.html#ae8fa8baca6ed81993c3a4833854937a0">begin</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> <a class="code" href="lib_2Target_2README_8txt.html#ab24db72f7bd10b13351812874015861b">First</a>; }</div>
<div class="line"><a name="l00110"></a><span class="lineno"><a class="line" href="classStringView.html#a7f2ffb885adbde9d847c15600469c2bb">  110</a></span>&#160;  <span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="classStringView.html#a7f2ffb885adbde9d847c15600469c2bb">end</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> Last; }</div>
<div class="line"><a name="l00111"></a><span class="lineno"><a class="line" href="classStringView.html#abcc0f1dfe0a436e90525248bc19a5b73">  111</a></span>&#160;  <span class="keywordtype">size_t</span> <a class="code" href="classStringView.html#abcc0f1dfe0a436e90525248bc19a5b73">size</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> <span class="keyword">static_cast&lt;</span><span class="keywordtype">size_t</span><span class="keyword">&gt;</span>(Last - <a class="code" href="lib_2Target_2README_8txt.html#ab24db72f7bd10b13351812874015861b">First</a>); }</div>
<div class="line"><a name="l00112"></a><span class="lineno"><a class="line" href="classStringView.html#ae65a04775aac67a1e107b451d0451bc6">  112</a></span>&#160;  <span class="keywordtype">bool</span> <a class="code" href="classStringView.html#ae65a04775aac67a1e107b451d0451bc6">empty</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> <a class="code" href="lib_2Target_2README_8txt.html#ab24db72f7bd10b13351812874015861b">First</a> == Last; }</div>
<div class="line"><a name="l00113"></a><span class="lineno">  113</span>&#160;};</div>
<div class="line"><a name="l00114"></a><span class="lineno">  114</span>&#160; </div>
<div class="line"><a name="l00115"></a><span class="lineno"><a class="line" href="StringView_8h.html#af54699e6e7069b1dfd9a3ea29fe822c0">  115</a></span>&#160;<span class="keyword">inline</span> <span class="keywordtype">bool</span> <a class="code" href="StringView_8h.html#af54699e6e7069b1dfd9a3ea29fe822c0">operator==</a>(<span class="keyword">const</span> <a class="code" href="classStringView.html">StringView</a> &amp;<a class="code" href="X86PartialReduction_8cpp.html#a9e1483f7215664a2315c53c3558d9a8d">LHS</a>, <span class="keyword">const</span> <a class="code" href="classStringView.html">StringView</a> &amp;<a class="code" href="X86PartialReduction_8cpp.html#a87b8bfbbe9d8f7146d7f20a5fb42efd0">RHS</a>) {</div>
<div class="line"><a name="l00116"></a><span class="lineno">  116</span>&#160;  <span class="keywordflow">return</span> <a class="code" href="X86PartialReduction_8cpp.html#a9e1483f7215664a2315c53c3558d9a8d">LHS</a>.size() == <a class="code" href="X86PartialReduction_8cpp.html#a87b8bfbbe9d8f7146d7f20a5fb42efd0">RHS</a>.size() &amp;&amp;</div>
<div class="line"><a name="l00117"></a><span class="lineno">  117</span>&#160;         std::strncmp(<a class="code" href="X86PartialReduction_8cpp.html#a9e1483f7215664a2315c53c3558d9a8d">LHS</a>.begin(), <a class="code" href="X86PartialReduction_8cpp.html#a87b8bfbbe9d8f7146d7f20a5fb42efd0">RHS</a>.begin(), <a class="code" href="X86PartialReduction_8cpp.html#a9e1483f7215664a2315c53c3558d9a8d">LHS</a>.size()) == 0;</div>
<div class="line"><a name="l00118"></a><span class="lineno">  118</span>&#160;}</div>
<div class="line"><a name="l00119"></a><span class="lineno">  119</span>&#160; </div>
<div class="line"><a name="l00120"></a><span class="lineno">  120</span>&#160;<a class="code" href="DemangleConfig_8h.html#aacd584e2ac8072e41efbd2f3c2e439ca">DEMANGLE_NAMESPACE_END</a></div>
<div class="line"><a name="l00121"></a><span class="lineno">  121</span>&#160; </div>
<div class="line"><a name="l00122"></a><span class="lineno">  122</span>&#160;<span class="preprocessor">#endif</span></div>
</div><!-- fragment --></div><!-- contents -->
<div class="ttc" id="alib_2Target_2PowerPC_2README_8txt_html_acac11578b87ac8c909bd20b9b44bf833"><div class="ttname"><a href="lib_2Target_2PowerPC_2README_8txt.html#acac11578b87ac8c909bd20b9b44bf833">z</a></div><div class="ttdeci">return z</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2PowerPC_2README_8txt_source.html#l00014">README.txt:14</a></div></div>
<div class="ttc" id="ainclude_2llvm_2Demangle_2README_8txt_html_acfa57666867e724427e90fa9fcd4b7e5"><div class="ttname"><a href="include_2llvm_2Demangle_2README_8txt.html#acfa57666867e724427e90fa9fcd4b7e5">libcxxabi</a></div><div class="ttdeci">Itanium Name Demangler i e convert the string _Z1fv into and both[sub] projects need to demangle but neither can depend on each other *libcxxabi needs the demangler to implement which is part of the itanium ABI spec *LLVM needs a copy for a bunch of and cannot rely on the system s __cxa_demangle because it a might not be and b may not be up to date on the latest language features The copy of the demangler in LLVM has some extra stuff that aren t needed in which depend on the shared generic components Despite these we want to keep the core generic demangling library identical between both copies to simplify development and testing If you re working on the generic then do the work first in libcxxabi</div><div class="ttdef"><b>Definition:</b> <a href="include_2llvm_2Demangle_2README_8txt_source.html#l00037">README.txt:37</a></div></div>
<div class="ttc" id="alib_2Target_2README_8txt_html_acb559820d9ca11295b4500f179ef6392"><div class="ttname"><a href="lib_2Target_2README_8txt.html#acb559820d9ca11295b4500f179ef6392">i</a></div><div class="ttdeci">i</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2README_8txt_source.html#l00029">README.txt:29</a></div></div>
<div class="ttc" id="alib_2Target_2X86_2README_8txt_html_ab46c1c4c9c1cd7db194c31d43b8af4ad"><div class="ttname"><a href="lib_2Target_2X86_2README_8txt.html#ab46c1c4c9c1cd7db194c31d43b8af4ad">xmm2</a></div><div class="ttdeci">gets compiled into this on rsp movaps rsp movaps rsp movaps rsp movaps rsp movaps rsp movaps xmm2</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2X86_2README_8txt_source.html#l01120">README.txt:1120</a></div></div>
<div class="ttc" id="alib_2Target_2X86_2README_8txt_html_add5265f3bdd9738639088b5de33893c7"><div class="ttname"><a href="lib_2Target_2X86_2README_8txt.html#add5265f3bdd9738639088b5de33893c7">algorithm</a></div><div class="ttdeci">Improvements to the multiply shift add algorithm</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2X86_2README_8txt_source.html#l00010">README.txt:10</a></div></div>
<div class="ttc" id="alib_2Target_2PowerPC_2README_8txt_html_aac8caf7db71f9293d235982e85c8dc0c"><div class="ttname"><a href="lib_2Target_2PowerPC_2README_8txt.html#aac8caf7db71f9293d235982e85c8dc0c">LCPI1_1</a></div><div class="ttdeci">cond_true lis lo16() lo16() lo16() LCPI1_1(r2) fsub f0</div></div>
<div class="ttc" id="alib_2Target_2X86_2README_8txt_html_ae7022af3b0e34d6d665e97dd6058f713"><div class="ttname"><a href="lib_2Target_2X86_2README_8txt.html#ae7022af3b0e34d6d665e97dd6058f713">xmm1</a></div><div class="ttdeci">esp eax movl ecx ecx cvtsi2ss xmm0 eax cvtsi2ss xmm1 xmm0 addss xmm1</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2X86_2README_8txt_source.html#l00305">README.txt:305</a></div></div>
<div class="ttc" id="alib_2Target_2X86_2README_8txt_html_a764aaba0155acb3385163d522ef291e1"><div class="ttname"><a href="lib_2Target_2X86_2README_8txt.html#a764aaba0155acb3385163d522ef291e1">L5</a></div><div class="ttdeci">to esp esp setne al movzbw ax esp setg cl movzbw cx cmove cx cl jne LBB1_2 esp which is much esp edx eax decl edx jle L7 L5</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2X86_2README_8txt_source.html#l00656">README.txt:656</a></div></div>
<div class="ttc" id="alib_2Target_2X86_2README_8txt_html_a9a315d042512705500b545a6c6acb2bd"><div class="ttname"><a href="lib_2Target_2X86_2README_8txt.html#a9a315d042512705500b545a6c6acb2bd">set</a></div><div class="ttdeci">We currently generate a but we really shouldn eax ecx xorl edx divl ecx eax divl ecx movl eax ret A similar code sequence works for division We currently compile i32 v2 eax eax jo LBB1_2 atomic and others It is also currently not done for read modify write instructions It is also current not done if the OF or CF flags are needed The shift operators have the complication that when the shift count is EFLAGS is not set</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2X86_2README_8txt_source.html#l01277">README.txt:1277</a></div></div>
<div class="ttc" id="alib_2Target_2PowerPC_2README_8txt_html_aaee9cd8bdb0f101dc457f5aaa16a32cd"><div class="ttname"><a href="lib_2Target_2PowerPC_2README_8txt.html#aaee9cd8bdb0f101dc457f5aaa16a32cd">f0</a></div><div class="ttdeci">We f0</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2PowerPC_2README_8txt_source.html#l00076">README.txt:76</a></div></div>
<div class="ttc" id="aCOFFEmitter_8cpp_html_a22d45f704c4ada710d51c88aeb831ef5"><div class="ttname"><a href="COFFEmitter_8cpp.html#a22d45f704c4ada710d51c88aeb831ef5">zeros</a></div><div class="ttdeci">zeros_impl&lt; sizeof(T)&gt; zeros(const T &amp;)</div><div class="ttdef"><b>Definition:</b> <a href="COFFEmitter_8cpp_source.html#l00340">COFFEmitter.cpp:340</a></div></div>
<div class="ttc" id="alib_2CodeGen_2README_8txt_html_aef5d17e051fef5a3522d1486506517cb"><div class="ttname"><a href="lib_2CodeGen_2README_8txt.html#aef5d17e051fef5a3522d1486506517cb">noreg</a></div><div class="ttdeci">Common register allocation spilling lr str ldr sxth r3 ldr mla r4 can lr mov lr str ldr sxth r3 mla r4 and then merge mul and lr str ldr sxth r3 mla r4 It also increase the likelihood the store may become dead bb27 noreg</div><div class="ttdef"><b>Definition:</b> <a href="lib_2CodeGen_2README_8txt_source.html#l00036">README.txt:36</a></div></div>
<div class="ttc" id="alib_2Target_2ARM_2README_8txt_html_a307e4ed3fc3a19c7f966256d60fe229f"><div class="ttname"><a href="lib_2Target_2ARM_2README_8txt.html#a307e4ed3fc3a19c7f966256d60fe229f">behavior</a></div><div class="ttdeci">should just be implemented with a CLZ instruction Since there are other e that share this behavior</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2ARM_2README_8txt_source.html#l00709">README.txt:709</a></div></div>
<div class="ttc" id="aRelocation_8txt_html_a7d6a42b5e611ba278973ae2d22527175"><div class="ttname"><a href="Relocation_8txt.html#a7d6a42b5e611ba278973ae2d22527175">ABI</a></div><div class="ttdeci">Generic address nodes are lowered to some combination of target independent and machine specific ABI</div><div class="ttdef"><b>Definition:</b> <a href="Relocation_8txt_source.html#l00034">Relocation.txt:34</a></div></div>
<div class="ttc" id="alib_2Target_2ARM_2README_8txt_html_aa660bb6aec19f6cb361a36080a776dfb"><div class="ttname"><a href="lib_2Target_2ARM_2README_8txt.html#aa660bb6aec19f6cb361a36080a776dfb">is</a></div><div class="ttdeci">should just be implemented with a CLZ instruction Since there are other e that share this it would be best to implement this in a target independent as zero is the default value for the binary encoder e add r0 add r5 Register operands should be distinct That is</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2ARM_2README_8txt_source.html#l00725">README.txt:725</a></div></div>
<div class="ttc" id="alib_2Target_2README_8txt_html_a86a8d7c35fb9eeb53412ca9bca388e99"><div class="ttname"><a href="lib_2Target_2README_8txt.html#a86a8d7c35fb9eeb53412ca9bca388e99">as</a></div><div class="ttdeci">compiles conv shl5 shl ret i32 or10 it would be better as</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2README_8txt_source.html#l00615">README.txt:615</a></div></div>
<div class="ttc" id="alib_2Target_2X86_2README_8txt_html_adedeae97594f529f238e0b07c49d5446"><div class="ttname"><a href="lib_2Target_2X86_2README_8txt.html#adedeae97594f529f238e0b07c49d5446">ecx</a></div><div class="ttdeci">Instead of the following for memset char edx edx edx It might be better to generate eax movl edx movl edx movw edx when we can spare a register It reduces code size Evaluate what the best way to codegen sdiv C is For we currently get ret i32 Y eax movl ecx ecx ecx addl ecx</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2X86_2README_8txt_source.html#l00147">README.txt:147</a></div></div>
<div class="ttc" id="alib_2Target_2PowerPC_2README_8txt_html_a18707df5631fe001a8bb4bdcabd49b99"><div class="ttname"><a href="lib_2Target_2PowerPC_2README_8txt.html#a18707df5631fe001a8bb4bdcabd49b99">produces</a></div><div class="ttdeci">entry stw r5 blr GCC produces</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2PowerPC_2README_8txt_source.html#l00174">README.txt:174</a></div></div>
<div class="ttc" id="alib_2Target_2README_8txt_html_ab3a565d6137879762c72e84859593753"><div class="ttname"><a href="lib_2Target_2README_8txt.html#ab3a565d6137879762c72e84859593753">then</a></div><div class="ttdeci">RUN&lt; i32 &gt;&lt; i1 &gt; br i1 label then</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2README_8txt_source.html#l00338">README.txt:338</a></div></div>
<div class="ttc" id="alib_2Target_2ARM_2README_8txt_html_a04f7235e9b275db7f5f4dc933e52aac1"><div class="ttname"><a href="lib_2Target_2ARM_2README_8txt.html#a04f7235e9b275db7f5f4dc933e52aac1">targets</a></div><div class="ttdeci">should just be implemented with a CLZ instruction Since there are other targets</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2ARM_2README_8txt_source.html#l00709">README.txt:709</a></div></div>
<div class="ttc" id="aclassStringView_html_a185f13d8300330e0f206f0ac8a27f824"><div class="ttname"><a href="classStringView.html#a185f13d8300330e0f206f0ac8a27f824">StringView::StringView</a></div><div class="ttdeci">StringView()</div><div class="ttdef"><b>Definition:</b> <a href="StringView_8h_source.html#l00039">StringView.h:39</a></div></div>
<div class="ttc" id="anamespacellvm_1_1binaryformat_html_ab355a2b14b4cc35373b4526fbfab894dae1876e1602335f6a4e50b3c18cd836da"><div class="ttname"><a href="namespacellvm_1_1binaryformat.html#ab355a2b14b4cc35373b4526fbfab894dae1876e1602335f6a4e50b3c18cd836da">llvm::binaryformat::last</a></div><div class="ttdeci">@ last</div><div class="ttdef"><b>Definition:</b> <a href="Swift_8h_source.html#l00019">Swift.h:19</a></div></div>
<div class="ttc" id="aREADME-SSE_8txt_html_afe62d3b93da0f864d7f9b2e0c3bfd820"><div class="ttname"><a href="README-SSE_8txt.html#afe62d3b93da0f864d7f9b2e0c3bfd820">right</a></div><div class="ttdeci">the custom lowered code happens to be right</div><div class="ttdef"><b>Definition:</b> <a href="README-SSE_8txt_source.html#l00480">README-SSE.txt:480</a></div></div>
<div class="ttc" id="aNVPTXISelLowering_8cpp_html_ae1a90b5d85643644483b2ca70da4d13faed3fa7a5efe80dad3ea3d86cc14be246"><div class="ttname"><a href="NVPTXISelLowering_8cpp.html#ae1a90b5d85643644483b2ca70da4d13faed3fa7a5efe80dad3ea3d86cc14be246">Signed</a></div><div class="ttdeci">@ Signed</div><div class="ttdef"><b>Definition:</b> <a href="NVPTXISelLowering_8cpp_source.html#l04884">NVPTXISelLowering.cpp:4884</a></div></div>
<div class="ttc" id="alib_2Target_2X86_2README_8txt_html_ae6a03db7c9e76cfd0ea4bc4b6b61d721"><div class="ttname"><a href="lib_2Target_2X86_2README_8txt.html#ae6a03db7c9e76cfd0ea4bc4b6b61d721">readnone</a></div><div class="ttdeci">We generate the following IR with i32 b nounwind readnone</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2X86_2README_8txt_source.html#l01443">README.txt:1443</a></div></div>
<div class="ttc" id="alib_2Target_2X86_2README_8txt_html_aba6e923f3877e516d943bebd87faeb58"><div class="ttname"><a href="lib_2Target_2X86_2README_8txt.html#aba6e923f3877e516d943bebd87faeb58">tmp553554</a></div><div class="ttdeci">&lt; i32 &gt; tmp553554</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2X86_2README_8txt_source.html#l00560">README.txt:560</a></div></div>
<div class="ttc" id="aPartiallyInlineLibCalls_8cpp_html_ab87024c0be08cee548b6723f3e2e46a3"><div class="ttname"><a href="PartiallyInlineLibCalls_8cpp.html#ab87024c0be08cee548b6723f3e2e46a3">libcalls</a></div><div class="ttdeci">partially inline libcalls</div><div class="ttdef"><b>Definition:</b> <a href="PartiallyInlineLibCalls_8cpp_source.html#l00212">PartiallyInlineLibCalls.cpp:212</a></div></div>
<div class="ttc" id="alib_2Target_2README_8txt_html_a57fc0235d5ec99a5f41e390552569bca"><div class="ttname"><a href="lib_2Target_2README_8txt.html#a57fc0235d5ec99a5f41e390552569bca">comparisons</a></div><div class="ttdeci">The same transformation can work with an even modulo with the addition of a and shrink the compare RHS by the same amount Unless the target supports that transformation probably isn t worthwhile The transformation can also easily be made to work with non zero equality comparisons</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2README_8txt_source.html#l00685">README.txt:685</a></div></div>
<div class="ttc" id="alib_2Target_2README_8txt_html_aaa2e44d359fce36b146ac3b495596987"><div class="ttname"><a href="lib_2Target_2README_8txt.html#aaa2e44d359fce36b146ac3b495596987">GetHotKey</a></div><div class="ttdeci">THotKey GetHotKey()</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2README_8txt_source.html#l00470">README.txt:470</a></div></div>
<div class="ttc" id="alib_2Target_2WebAssembly_2README_8txt_html_a2ff42d8940320394fe7c9ebefd235621"><div class="ttname"><a href="lib_2Target_2WebAssembly_2README_8txt.html#a2ff42d8940320394fe7c9ebefd235621">constant</a></div><div class="ttdeci">we should consider alternate ways to model stack dependencies Lots of things could be done in WebAssemblyTargetTransformInfo cpp there are numerous optimization related hooks that can be overridden in WebAssemblyTargetLowering Instead of the OptimizeReturned which should consider preserving the returned attribute through to MachineInstrs and extending the MemIntrinsicResults pass to do this optimization on calls too That would also let the WebAssemblyPeephole pass clean up dead defs for such as it does for stores Consider implementing and or getMachineCombinerPatterns Find a clean way to fix the problem which leads to the Shrink Wrapping pass being run after the WebAssembly PEI pass When setting multiple variables to the same constant</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2WebAssembly_2README_8txt_source.html#l00091">README.txt:91</a></div></div>
<div class="ttc" id="alib_2CodeGen_2README_8txt_html_a7b73e61ac2c5cd9417af94d96b335473"><div class="ttname"><a href="lib_2CodeGen_2README_8txt.html#a7b73e61ac2c5cd9417af94d96b335473">requirement</a></div><div class="ttdeci">Common register allocation spilling lr str ldr sxth r3 ldr mla r4 can lr mov lr str ldr sxth r3 mla r4 and then merge mul and lr str ldr sxth r3 mla r4 It also increase the likelihood the store may become dead bb27 Successors according to LLVM ID Predecessors according to mbb&lt; bb27, 0x8b0a7c0 &gt; Note ADDri is not a two address instruction its result reg1037 is an operand of the PHI node in bb76 and its operand reg1039 is the result of the PHI node We should treat it as a two address code and make sure the ADDri is scheduled after any node that reads reg1039 Use info(i.e. register scavenger) to assign it a free register to allow reuse the collector could move the objects and invalidate the derived pointer This is bad enough in the first but safe points can crop up unpredictably **array_addr i32 n y store obj obj **nth_el If the i64 division is lowered to a then a safe point array and nth_el no longer point into the correct object The fix for this is to copy address calculations so that dependent pointers are never live across safe point boundaries But the loads cannot be copied like this if there was an intervening so may be hard to get right Only a concurrent mutator can trigger a collection at the libcall safe point So single threaded programs do not have this requirement</div><div class="ttdef"><b>Definition:</b> <a href="lib_2CodeGen_2README_8txt_source.html#l00136">README.txt:136</a></div></div>
<div class="ttc" id="anamespacellvm_html"><div class="ttname"><a href="namespacellvm.html">llvm</a></div><div class="ttdoc">This is an optimization pass for GlobalISel generic memory operations.</div><div class="ttdef"><b>Definition:</b> <a href="AddressRanges_8h_source.html#l00018">AddressRanges.h:18</a></div></div>
<div class="ttc" id="alib_2Target_2X86_2README_8txt_html_a57bc98fc9299817cd107f1ab3344ebcb"><div class="ttname"><a href="lib_2Target_2X86_2README_8txt.html#a57bc98fc9299817cd107f1ab3344ebcb">rcx</a></div><div class="ttdeci">gets compiled into this on rsp movaps rsp movaps rsp movaps rsp movaps rsp movaps rsp movaps rsp movaps rsp movaps rsp movq rsp movq rsp movq rcx</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2X86_2README_8txt_source.html#l01125">README.txt:1125</a></div></div>
<div class="ttc" id="aREADME__P9_8txt_html_af9ce2a43307dff54d7c53b165d8ed194"><div class="ttname"><a href="README__P9_8txt.html#af9ce2a43307dff54d7c53b165d8ed194">intrinsic</a></div><div class="ttdeci">QP Compare Ordered outs ins xscmpudp No intrinsic</div><div class="ttdef"><b>Definition:</b> <a href="README__P9_8txt_source.html#l00303">README_P9.txt:303</a></div></div>
<div class="ttc" id="alib_2Target_2X86_2README_8txt_html_ac88fe1d3a61b056a4f64fbbb156a62ff"><div class="ttname"><a href="lib_2Target_2X86_2README_8txt.html#ac88fe1d3a61b056a4f64fbbb156a62ff">M</a></div><div class="ttdeci">We currently emits eax Perhaps this is what we really should generate is Is imull three or four cycles eax eax The current instruction priority is based on pattern complexity The former is more complex because it folds a load so the latter will not be emitted Perhaps we should use AddedComplexity to give LEA32r a higher priority We should always try to match LEA first since the LEA matching code does some estimate to determine whether the match is profitable if we care more about code then imull is better It s two bytes shorter than movl leal On a Pentium M</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2X86_2README_8txt_source.html#l00252">README.txt:252</a></div></div>
<div class="ttc" id="alib_2Target_2README_8txt_html_a7883a95866b9432ce4d83316aa287800"><div class="ttname"><a href="lib_2Target_2README_8txt.html#a7883a95866b9432ce4d83316aa287800">eax</a></div><div class="ttdeci">Add support for conditional and other related patterns Instead eax eax je LBB16_2 eax edi eax movl eax</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2README_8txt_source.html#l00145">README.txt:145</a></div></div>
<div class="ttc" id="aREADME-SSE_8txt_html_a9ac32a0342c0b841550ee0c2412a245e"><div class="ttname"><a href="README-SSE_8txt.html#a9ac32a0342c0b841550ee0c2412a245e">c2</a></div><div class="ttdeci">This might compile to this xmm1 xorps xmm0 movss xmm0 ret Now consider if the code caused xmm1 to get spilled This might produce this xmm1 movaps c2(%esp) ... xorps %xmm0</div></div>
<div class="ttc" id="anamespacellvm_1_1ARM__AM_html_a76f5f9f36bbd9f03c844c5b565f239efa25f26a9f4d00c9ac425953111519c041"><div class="ttname"><a href="namespacellvm_1_1ARM__AM.html#a76f5f9f36bbd9f03c844c5b565f239efa25f26a9f4d00c9ac425953111519c041">llvm::ARM_AM::lsr</a></div><div class="ttdeci">@ lsr</div><div class="ttdef"><b>Definition:</b> <a href="ARMAddressingModes_8h_source.html#l00031">ARMAddressingModes.h:31</a></div></div>
<div class="ttc" id="alib_2Target_2X86_2README_8txt_html_ac88244f8b6df536108ccf9289bfef611"><div class="ttname"><a href="lib_2Target_2X86_2README_8txt.html#ac88244f8b6df536108ccf9289bfef611">subl</a></div><div class="ttdeci">subl</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2X86_2README_8txt_source.html#l00297">README.txt:297</a></div></div>
<div class="ttc" id="alib_2Target_2X86_2README_8txt_html_a159920e88406441690339840f79c4dc7"><div class="ttname"><a href="lib_2Target_2X86_2README_8txt.html#a159920e88406441690339840f79c4dc7">v2i32</a></div><div class="ttdeci">gets compiled into this on rsp movaps rsp movaps rsp movaps rsp movaps rsp movaps rsp movaps rsp movaps rsp movaps rsp movq rsp movq rsp movq rsp movq rsp movq rsp rax movq rsp rax movq rsp rsp rsp eax eax jbe LBB1_3 rcx rax movq rsp eax rsp ret ecx eax rcx movl rsp jmp LBB1_2 gcc rsp rax movq rsp rsp movq rsp rax movq rsp eax eax jb L6 rdx eax rsp ret p2align edx rdx eax movl rsp eax rsp ret and it gets compiled into this on ebp esp eax movl ebp eax movl ebp eax esp popl ebp ret gcc ebp eax popl ebp ret Teach tblgen not to check bitconvert source type in some cases This allows us to consolidate the following patterns in X86InstrMMX v2i32(MMX_MOVDQ2Qrr VR128:$src))&gt;</div></div>
<div class="ttc" id="alib_2Target_2X86_2README_8txt_html_a323692acb65210320385a6e18f40369f"><div class="ttname"><a href="lib_2Target_2X86_2README_8txt.html#a323692acb65210320385a6e18f40369f">LLVM</a></div><div class="ttdeci">Improvements to the multiply shift add e g in LLVM</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2X86_2README_8txt_source.html#l00011">README.txt:11</a></div></div>
<div class="ttc" id="aclassStringView_html_ab4be372359105725591143c73b28c73e"><div class="ttname"><a href="classStringView.html#ab4be372359105725591143c73b28c73e">StringView::StringView</a></div><div class="ttdeci">StringView(const char *First_, size_t Len)</div><div class="ttdef"><b>Definition:</b> <a href="StringView_8h_source.html#l00036">StringView.h:36</a></div></div>
<div class="ttc" id="alib_2Target_2ARM_2README_8txt_html_a278eff9ea60d876a0311cc3ea7253324"><div class="ttname"><a href="lib_2Target_2ARM_2README_8txt.html#a278eff9ea60d876a0311cc3ea7253324">use</a></div><div class="ttdeci">Should compile r2 movcc movcs str strb mov lr r1 movcs movcc mov lr r1 str mov mov cmp r1 movlo r2 str bx lr r0 mov mov cmp r0 movhs r2 mov r1 bx lr Some of the NEON intrinsics may be appropriate for more general use</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2ARM_2README_8txt_source.html#l00484">README.txt:484</a></div></div>
<div class="ttc" id="alib_2Target_2README_8txt_html_a7bb3d0e0971fc7e33522732d133f421b"><div class="ttname"><a href="lib_2Target_2README_8txt.html#a7bb3d0e0971fc7e33522732d133f421b">cmpl</a></div><div class="ttdeci">Add support for conditional and other related patterns Instead eax cmpl</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2README_8txt_source.html#l00135">README.txt:135</a></div></div>
<div class="ttc" id="anamespacellvm_1_1AArch64PACKey_html_abf4394f452bde3f544999858d71e4b46"><div class="ttname"><a href="namespacellvm_1_1AArch64PACKey.html#abf4394f452bde3f544999858d71e4b46">llvm::AArch64PACKey::ID</a></div><div class="ttdeci">ID</div><div class="ttdef"><b>Definition:</b> <a href="AArch64BaseInfo_8h_source.html#l00790">AArch64BaseInfo.h:790</a></div></div>
<div class="ttc" id="alib_2Target_2X86_2README_8txt_html_ac86babb598befe37e9063b005ccda6a0"><div class="ttname"><a href="lib_2Target_2X86_2README_8txt.html#ac86babb598befe37e9063b005ccda6a0">zero</a></div><div class="ttdeci">We currently generate a but we really shouldn eax ecx xorl edx divl ecx eax divl ecx movl eax ret A similar code sequence works for division We currently compile i32 v2 eax eax jo LBB1_2 atomic and others It is also currently not done for read modify write instructions It is also current not done if the OF or CF flags are needed The shift operators have the complication that when the shift count is zero</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2X86_2README_8txt_source.html#l01277">README.txt:1277</a></div></div>
<div class="ttc" id="aAMDGPURewriteUndefForPHI_8cpp_html_a2e83cb1bc3f5e8986cbd14575755a134"><div class="ttname"><a href="AMDGPURewriteUndefForPHI_8cpp.html#a2e83cb1bc3f5e8986cbd14575755a134">PHI</a></div><div class="ttdeci">Rewrite undef for PHI</div><div class="ttdef"><b>Definition:</b> <a href="AMDGPURewriteUndefForPHI_8cpp_source.html#l00101">AMDGPURewriteUndefForPHI.cpp:101</a></div></div>
<div class="ttc" id="aclassStringView_html_ab17adafca67f1ce7a532a32b6f866fbc"><div class="ttname"><a href="classStringView.html#ab17adafca67f1ce7a532a32b6f866fbc">StringView::operator[]</a></div><div class="ttdeci">const char &amp; operator[](size_t Idx) const</div><div class="ttdef"><b>Definition:</b> <a href="StringView_8h_source.html#l00107">StringView.h:107</a></div></div>
<div class="ttc" id="aHexagonBitSimplify_8cpp_html_aa56209f617200c772b32fea2947178a7"><div class="ttname"><a href="HexagonBitSimplify_8cpp.html#aa56209f617200c772b32fea2947178a7">simplify</a></div><div class="ttdeci">hexagon bit simplify</div><div class="ttdef"><b>Definition:</b> <a href="HexagonBitSimplify_8cpp_source.html#l00289">HexagonBitSimplify.cpp:289</a></div></div>
<div class="ttc" id="aREADME-FPStack_8txt_html_a9209b9930d4d7750a6b8b38b3b4ddd6a"><div class="ttname"><a href="README-FPStack_8txt.html#a9209b9930d4d7750a6b8b38b3b4ddd6a">ceil</a></div><div class="ttdeci">We have fiadd patterns now but the followings have the same cost and complexity We need a way to specify the later is more profitable def def The FP stackifier should handle simple permutates to reduce number of shuffle e g ceil</div><div class="ttdef"><b>Definition:</b> <a href="README-FPStack_8txt_source.html#l00054">README-FPStack.txt:54</a></div></div>
<div class="ttc" id="alib_2Target_2ARM_2README_8txt_html_af1e5dbd70beb16377795377a9dad57f1"><div class="ttname"><a href="lib_2Target_2ARM_2README_8txt.html#af1e5dbd70beb16377795377a9dad57f1">ldmia</a></div><div class="ttdeci">add sub stmia L5 ldr r0 bl L_printf $stub Instead of a ldmia</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2ARM_2README_8txt_source.html#l00204">README.txt:204</a></div></div>
<div class="ttc" id="aclassStringView_html_abcc0f1dfe0a436e90525248bc19a5b73"><div class="ttname"><a href="classStringView.html#abcc0f1dfe0a436e90525248bc19a5b73">StringView::size</a></div><div class="ttdeci">size_t size() const</div><div class="ttdef"><b>Definition:</b> <a href="StringView_8h_source.html#l00111">StringView.h:111</a></div></div>
<div class="ttc" id="alib_2Target_2WebAssembly_2README_8txt_html_acd5f99f9e89410e51fc09950e8dbc7dd"><div class="ttname"><a href="lib_2Target_2WebAssembly_2README_8txt.html#acd5f99f9e89410e51fc09950e8dbc7dd">see</a></div><div class="ttdeci">The object format emitted by the WebAssembly backed is documented see the home and packaging for producing WebAssembly applications that can run in browsers and other environments wasi sdk provides a more minimal C C SDK based on llvm and a libc based on for producing WebAssemmbly applictions that use the WASI ABI Rust provides WebAssembly support integrated into Cargo There are two main which provides a relatively minimal environment that has an emphasis on being native wasm32 unknown which uses Emscripten internally and provides standard C C filesystem GL and SDL bindings For more see</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2WebAssembly_2README_8txt_source.html#l00041">README.txt:41</a></div></div>
<div class="ttc" id="alib_2Target_2WebAssembly_2README_8txt_html_addff3c14ddc73604c2b24a17331cb5ce"><div class="ttname"><a href="lib_2Target_2WebAssembly_2README_8txt.html#addff3c14ddc73604c2b24a17331cb5ce">Similarly</a></div><div class="ttdeci">we should consider alternate ways to model stack dependencies Lots of things could be done in WebAssemblyTargetTransformInfo cpp Similarly</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2WebAssembly_2README_8txt_source.html#l00067">README.txt:67</a></div></div>
<div class="ttc" id="alib_2Target_2README_8txt_html_a1c73f662a0ce6b37b8203009d82287b1"><div class="ttname"><a href="lib_2Target_2README_8txt.html#a1c73f662a0ce6b37b8203009d82287b1">return</a></div><div class="ttdeci">return</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2README_8txt_source.html#l00242">README.txt:242</a></div></div>
<div class="ttc" id="alib_2Target_2X86_2README_8txt_html_a2c653d3e8d977702e9175ef0fa5dd653"><div class="ttname"><a href="lib_2Target_2X86_2README_8txt.html#a2c653d3e8d977702e9175ef0fa5dd653">tmp6</a></div><div class="ttdeci">&lt; i32 &gt; tmp6</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2X86_2README_8txt_source.html#l01446">README.txt:1446</a></div></div>
<div class="ttc" id="alib_2Target_2X86_2README_8txt_html_a57d0df36879c90c8fa1b9e0d5ad54a26"><div class="ttname"><a href="lib_2Target_2X86_2README_8txt.html#a57d0df36879c90c8fa1b9e0d5ad54a26">Note</a></div><div class="ttdeci">We currently emits eax Perhaps this is what we really should generate is Is imull three or four cycles Note</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2X86_2README_8txt_source.html#l00239">README.txt:239</a></div></div>
<div class="ttc" id="astructManglingParser_html"><div class="ttname"><a href="structManglingParser.html">ManglingParser</a></div><div class="ttdef"><b>Definition:</b> <a href="ItaniumDemangle_8h_source.html#l05493">ItaniumDemangle.h:5493</a></div></div>
<div class="ttc" id="alib_2Target_2X86_2README_8txt_html_a2d3ea32e0eb9ad0ca0f9ec10b03c3242"><div class="ttname"><a href="lib_2Target_2X86_2README_8txt.html#a2d3ea32e0eb9ad0ca0f9ec10b03c3242">tmp2</a></div><div class="ttdeci">&lt; i1 &gt; br i1 tmp2</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2X86_2README_8txt_source.html#l00976">README.txt:976</a></div></div>
<div class="ttc" id="alib_2Target_2X86_2README_8txt_html_a6aa909653c5e66375cfb9ed8eb6678f4"><div class="ttname"><a href="lib_2Target_2X86_2README_8txt.html#a6aa909653c5e66375cfb9ed8eb6678f4">xmm7</a></div><div class="ttdeci">gets compiled into this on rsp movaps xmm7</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2X86_2README_8txt_source.html#l01115">README.txt:1115</a></div></div>
<div class="ttc" id="aAMDGPUReplaceLDSUseWithPointer_8cpp_html_a9c3943160b95cc42ca8f6e04e6d4e9b6"><div class="ttname"><a href="AMDGPUReplaceLDSUseWithPointer_8cpp.html#a9c3943160b95cc42ca8f6e04e6d4e9b6">pointer</a></div><div class="ttdeci">Replace within non kernel function use of LDS with pointer</div><div class="ttdef"><b>Definition:</b> <a href="AMDGPUReplaceLDSUseWithPointer_8cpp_source.html#l00631">AMDGPUReplaceLDSUseWithPointer.cpp:631</a></div></div>
<div class="ttc" id="aREADME-SSE_8txt_html_a63d206a063eefcdf8c318ded97b65020"><div class="ttname"><a href="README-SSE_8txt.html#a63d206a063eefcdf8c318ded97b65020">P</a></div><div class="ttdeci">This currently compiles esp xmm0 movsd esp eax eax esp ret We should use not the dag combiner This is because dagcombine2 needs to be able to see through the X86ISD::Wrapper which DAGCombine can t really do The code for turning x load into a single vector load is target independent and should be moved to the dag combiner The code for turning x load into a vector load can only handle a direct load from a global or a direct load from the stack It should be generalized to handle any load from P</div><div class="ttdef"><b>Definition:</b> <a href="README-SSE_8txt_source.html#l00411">README-SSE.txt:411</a></div></div>
<div class="ttc" id="aSROA_8cpp_html_a6990f15b9f29df6e8497b3e53875ccab"><div class="ttname"><a href="SROA_8cpp.html#a6990f15b9f29df6e8497b3e53875ccab">sroa</a></div><div class="ttdeci">sroa</div><div class="ttdef"><b>Definition:</b> <a href="SROA_8cpp_source.html#l05126">SROA.cpp:5126</a></div></div>
<div class="ttc" id="aARMTargetMachine_8cpp_html_a86b29362e5d8fbb0d516610e4f988b5e"><div class="ttname"><a href="ARMTargetMachine_8cpp.html#a86b29362e5d8fbb0d516610e4f988b5e">fix</a></div><div class="ttdeci">arm execution domain fix</div><div class="ttdef"><b>Definition:</b> <a href="ARMTargetMachine_8cpp_source.html#l00404">ARMTargetMachine.cpp:404</a></div></div>
<div class="ttc" id="alib_2Target_2X86_2README_8txt_html_a040c7fd7d0c3002e046ca7ad63fa93e7"><div class="ttname"><a href="lib_2Target_2X86_2README_8txt.html#a040c7fd7d0c3002e046ca7ad63fa93e7">change</a></div><div class="ttdeci">&lt; i32 &gt; br label bb114 eax ecx movl ebp subl ebp eax movl ebp subl ebp eax movl ebp subl ebp eax subl ecx movl ebp eax movl ebp eax movl ebp ebp This appears to be bad because the RA is not folding the store to the stack slot into the movl The above instructions could ebp ebp This seems like a cross between remat and spill folding This has redundant subtractions of eax from a stack slot ecx doesn t change</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2X86_2README_8txt_source.html#l00599">README.txt:599</a></div></div>
<div class="ttc" id="alib_2Target_2X86_2README_8txt_html_a7ef752243b47020180b1888bacb767d8"><div class="ttname"><a href="lib_2Target_2X86_2README_8txt.html#a7ef752243b47020180b1888bacb767d8">xorb</a></div><div class="ttdeci">Should compile edi setae al movzbl eax ret on instead of the rather stupid edi setb al xorb</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2X86_2README_8txt_source.html#l00545">README.txt:545</a></div></div>
<div class="ttc" id="alib_2Target_2X86_2README_8txt_html_a5ee7c8b78f243bc08fa7e1c26b8f3b98"><div class="ttname"><a href="lib_2Target_2X86_2README_8txt.html#a5ee7c8b78f243bc08fa7e1c26b8f3b98">ops</a></div><div class="ttdeci">We currently generate a but we really shouldn eax ecx xorl edx divl ecx eax divl ecx movl eax ret A similar code sequence works for division We currently compile i32 v2 eax eax jo LBB1_2 atomic ops</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2X86_2README_8txt_source.html#l01272">README.txt:1272</a></div></div>
<div class="ttc" id="alib_2Target_2ARM_2README_8txt_html_a06073fd284a21e842f0b772f63427475"><div class="ttname"><a href="lib_2Target_2ARM_2README_8txt.html#a06073fd284a21e842f0b772f63427475">stuff</a></div><div class="ttdeci">_bar mov r0 mov r1 fldd LCPI1_0 fmrrd d0 bl _foo fmdrr r5 fmsr r0 fsitod s2 faddd d0 fmrrd d0 ldmfd r0 mov r1 the copys to callee save registers and the fact they are only being used by the fmdrr instruction It would have been better had the fmdrr been scheduled before the call and place the result in a callee save DPR register The two mov ops would not have been necessary Calling convention related stuff</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2ARM_2README_8txt_source.html#l00181">README.txt:181</a></div></div>
<div class="ttc" id="alib_2Target_2ARM_2README_8txt_html_a3ebec767d878f6325649018816f5fbba"><div class="ttname"><a href="lib_2Target_2ARM_2README_8txt.html#a3ebec767d878f6325649018816f5fbba">minimum</a></div><div class="ttdeci">Should compile r2 movcc movcs str strb mov lr r1 movcs movcc mov lr r1 str mov mov cmp r1 movlo r2 str bx lr r0 mov mov cmp r0 movhs r2 mov r1 bx lr Some of the NEON intrinsics may be appropriate for more general either as target independent intrinsics or perhaps elsewhere in the ARM backend Some of them may also be lowered to target independent and perhaps some new SDNodes could be added For minimum</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2ARM_2README_8txt_source.html#l00489">README.txt:489</a></div></div>
<div class="ttc" id="aSMEABIPass_8cpp_html_a8f8f80d37794cde9472343e4487ba3eb"><div class="ttname"><a href="SMEABIPass_8cpp.html#a8f8f80d37794cde9472343e4487ba3eb">name</a></div><div class="ttdeci">static const char * name</div><div class="ttdef"><b>Definition:</b> <a href="SMEABIPass_8cpp_source.html#l00049">SMEABIPass.cpp:49</a></div></div>
<div class="ttc" id="alib_2CodeGen_2README_8txt_html_a98f559f710a7595ef874405005c1c2e7"><div class="ttname"><a href="lib_2CodeGen_2README_8txt.html#a98f559f710a7595ef874405005c1c2e7">store</a></div><div class="ttdeci">Common register allocation spilling lr str ldr sxth r3 ldr mla r4 can lr mov lr str ldr sxth r3 mla r4 and then merge mul and lr str ldr sxth r3 mla r4 It also increase the likelihood the store may become dead bb27 Successors according to LLVM ID Predecessors according to mbb&lt; bb27, 0x8b0a7c0 &gt; Note ADDri is not a two address instruction its result reg1037 is an operand of the PHI node in bb76 and its operand reg1039 is the result of the PHI node We should treat it as a two address code and make sure the ADDri is scheduled after any node that reads reg1039 Use info(i.e. register scavenger) to assign it a free register to allow reuse the collector could move the objects and invalidate the derived pointer This is bad enough in the first but safe points can crop up unpredictably **array_addr i32 n y store obj obj **nth_el If the i64 division is lowered to a then a safe point array and nth_el no longer point into the correct object The fix for this is to copy address calculations so that dependent pointers are never live across safe point boundaries But the loads cannot be copied like this if there was an intervening store</div><div class="ttdef"><b>Definition:</b> <a href="lib_2CodeGen_2README_8txt_source.html#l00133">README.txt:133</a></div></div>
<div class="ttc" id="aAArch64AdvSIMDScalarPass_8cpp_html_a1112b818386ec01ddfdf3a5d0024eb17"><div class="ttname"><a href="AArch64AdvSIMDScalarPass_8cpp.html#a1112b818386ec01ddfdf3a5d0024eb17">contains</a></div><div class="ttdeci">return AArch64::GPR64RegClass contains(Reg)</div></div>
<div class="ttc" id="alib_2Target_2WebAssembly_2README_8txt_html_a7b7fac825ca3992e8ac3d895f9ed59bc"><div class="ttname"><a href="lib_2Target_2WebAssembly_2README_8txt.html#a7b7fac825ca3992e8ac3d895f9ed59bc">br_if</a></div><div class="ttdeci">The object format emitted by the WebAssembly backed is documented see the home and packaging for producing WebAssembly applications that can run in browsers and other environments wasi sdk provides a more minimal C C SDK based on llvm and a libc based on for producing WebAssemmbly applictions that use the WASI ABI Rust provides WebAssembly support integrated into Cargo There are two main which provides a relatively minimal environment that has an emphasis on being native wasm32 unknown which uses Emscripten internally and provides standard C C filesystem GL and SDL bindings For more br_if</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2WebAssembly_2README_8txt_source.html#l00041">README.txt:41</a></div></div>
<div class="ttc" id="aREADME-SSE_8txt_html_a698e4bd87a8adc0c042ae6b6e10ee6e1"><div class="ttname"><a href="README-SSE_8txt.html#a698e4bd87a8adc0c042ae6b6e10ee6e1">double</a></div><div class="ttdeci">into xmm2 addss xmm2 xmm1 xmm3 addss xmm3 movaps xmm0 unpcklps xmm0 ret seems silly when it could just be one addps Expand libm rounding functions main should enable SSE DAZ mode and other fast SSE modes Think about doing i64 math in SSE regs on x86 This testcase should have no SSE instructions in and only one load from a constant double</div><div class="ttdef"><b>Definition:</b> <a href="README-SSE_8txt_source.html#l00085">README-SSE.txt:85</a></div></div>
<div class="ttc" id="aREADME__P9_8txt_html_ae0c693afc7628462bf28808b35f51a46"><div class="ttname"><a href="README__P9_8txt.html#ae0c693afc7628462bf28808b35f51a46">v2i64</a></div><div class="ttdeci">QP Compare Ordered outs ins xscmpudp No builtin are required Or llvm fcmp order unorder compare DP QP Compare builtin are required DP xscmp *dp write to VSX register Use int_ppc_vsx_xscmpeqdp int_ppc_vsx_xscmpgedp int_ppc_vsx_xscmpgtdp int_ppc_vsx_xscmpnedp v2i64</div><div class="ttdef"><b>Definition:</b> <a href="README__P9_8txt_source.html#l00323">README_P9.txt:323</a></div></div>
<div class="ttc" id="aREADME-SSE_8txt_html_a0cd314eb6ec4d97be014a36348d9dff0"><div class="ttname"><a href="README-SSE_8txt.html#a0cd314eb6ec4d97be014a36348d9dff0">uses</a></div><div class="ttdeci">This might compile to this xmm1 xorps xmm0 movss xmm0 ret Now consider if the code caused xmm1 to get spilled This might produce this xmm1 movaps xmm0 movaps xmm1 movss xmm0 ret since the reload is only used by these we could fold it into the uses</div><div class="ttdef"><b>Definition:</b> <a href="README-SSE_8txt_source.html#l00258">README-SSE.txt:258</a></div></div>
<div class="ttc" id="alib_2Target_2X86_2README_8txt_html_a5f3a4a73a2d3891f248fa72c8bb574d9"><div class="ttname"><a href="lib_2Target_2X86_2README_8txt.html#a5f3a4a73a2d3891f248fa72c8bb574d9">output</a></div><div class="ttdeci">Current output</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2X86_2README_8txt_source.html#l01350">README.txt:1350</a></div></div>
<div class="ttc" id="anamespacellvm_1_1tgtok_html_abbc5259d649363016626e2529fabe0c5a4a6621856674f376740a1ba6efd809e3"><div class="ttname"><a href="namespacellvm_1_1tgtok.html#abbc5259d649363016626e2529fabe0c5a4a6621856674f376740a1ba6efd809e3">llvm::tgtok::Code</a></div><div class="ttdeci">@ Code</div><div class="ttdef"><b>Definition:</b> <a href="TGLexer_8h_source.html#l00050">TGLexer.h:50</a></div></div>
<div class="ttc" id="anamespacellvm_1_1AMDGPU_1_1IsaInfo_html_ab6e8b39aa26af871d8ede5fa8c791ee6a521c36a31c2762741cf0f8890cbe05e3"><div class="ttname"><a href="namespacellvm_1_1AMDGPU_1_1IsaInfo.html#ab6e8b39aa26af871d8ede5fa8c791ee6a521c36a31c2762741cf0f8890cbe05e3">llvm::AMDGPU::IsaInfo::TargetIDSetting::On</a></div><div class="ttdeci">@ On</div></div>
<div class="ttc" id="aREADME__ALTIVEC_8txt_html_ab291f2e71eb00e9c419f00fec6d1f3c1"><div class="ttname"><a href="README__ALTIVEC_8txt.html#ab291f2e71eb00e9c419f00fec6d1f3c1">codegen</a></div><div class="ttdeci">Since we know that Vector is byte aligned and we know the element offset of we should change the load into a lve *x instead of doing a load store lve *x sequence Implement passing vectors by value into calls and receiving them as arguments GCC apparently tries to codegen</div><div class="ttdef"><b>Definition:</b> <a href="README__ALTIVEC_8txt_source.html#l00046">README_ALTIVEC.txt:46</a></div></div>
<div class="ttc" id="anamespacellvm_1_1PatternMatch_html_a944c25ac9b73b02a17a20a08a25b9b21"><div class="ttname"><a href="namespacellvm_1_1PatternMatch.html#a944c25ac9b73b02a17a20a08a25b9b21">llvm::PatternMatch::m_Add</a></div><div class="ttdeci">BinaryOp_match&lt; LHS, RHS, Instruction::Add &gt; m_Add(const LHS &amp;L, const RHS &amp;R)</div><div class="ttdef"><b>Definition:</b> <a href="PatternMatch_8h_source.html#l00979">PatternMatch.h:979</a></div></div>
<div class="ttc" id="aREADME-X86-64_8txt_html_ab21316e3d0016f226970e89fbda6bbb0"><div class="ttname"><a href="README-X86-64_8txt.html#ab21316e3d0016f226970e89fbda6bbb0">away</a></div><div class="ttdeci">AMD64 Optimization Manual has some nice information about optimizing integer multiplication by a constant How much of it applies to Intel s X86 implementation There are definite trade offs to xmm0 cvttss2siq rdx jb L3 subss xmm0 rax cvttss2siq rdx xorq rdx rax ret instead of xmm1 cvttss2siq rcx movaps xmm2 subss xmm2 cvttss2siq rax rdx xorq rax ucomiss xmm0 cmovb rax ret Seems like the jb branch has high likelihood of being taken It would have saved a few instructions It s not possible to reference and DH registers in an instruction requiring REX prefix divb and mulb both produce results in AH If isel emits a CopyFromReg which gets turned into a movb and that can be allocated a r8b r15b To get around isel emits a CopyFromReg from AX and then right shift it down by and truncate it It s not pretty but it works We need some register allocation magic to make the hack go away(e.g. putting additional constraints on the result of the movb). The x86-64 ABI for hidden-argument struct returns requires that the incoming value of %rdi be copied into %rax by the callee upon return. The idea is that it saves callers from having to remember this value</div></div>
<div class="ttc" id="alib_2Target_2WebAssembly_2README_8txt_html_a110bde0683a71b2e87c932061b4945c6"><div class="ttname"><a href="lib_2Target_2WebAssembly_2README_8txt.html#a110bde0683a71b2e87c932061b4945c6">tools</a></div><div class="ttdeci">The object format emitted by the WebAssembly backed is documented see the home tools</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2WebAssembly_2README_8txt_source.html#l00016">README.txt:16</a></div></div>
<div class="ttc" id="alib_2Target_2PowerPC_2README_8txt_html_a759f8c609f4dc275dcccf3482ba98014"><div class="ttname"><a href="lib_2Target_2PowerPC_2README_8txt.html#a759f8c609f4dc275dcccf3482ba98014">simpler</a></div><div class="ttdeci">entry mr r2 blr This could be reduced to the much simpler</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2PowerPC_2README_8txt_source.html#l00210">README.txt:210</a></div></div>
<div class="ttc" id="alib_2Target_2X86_2README_8txt_html_a4ee55ea8651e2fbdba6ad14df729c01b"><div class="ttname"><a href="lib_2Target_2X86_2README_8txt.html#a4ee55ea8651e2fbdba6ad14df729c01b">tmp623</a></div><div class="ttdeci">&lt; i32 &gt; tmp623</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2X86_2README_8txt_source.html#l00565">README.txt:565</a></div></div>
<div class="ttc" id="alib_2Target_2X86_2README_8txt_html_a5426a6427d8e6c6c80db1e8509a8916e"><div class="ttname"><a href="lib_2Target_2X86_2README_8txt.html#a5426a6427d8e6c6c80db1e8509a8916e">_test1</a></div><div class="ttdeci">Instead of the following for memset char edx edx edx It might be better to generate eax movl edx movl edx movw edx when we can spare a register It reduces code size Evaluate what the best way to codegen sdiv C is For we currently get ret i32 Y _test1</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2X86_2README_8txt_source.html#l00143">README.txt:143</a></div></div>
<div class="ttc" id="alib_2Target_2WebAssembly_2README_8txt_html_a22c839ac623ea2fed8f5ab84e2337c92"><div class="ttname"><a href="lib_2Target_2WebAssembly_2README_8txt.html#a22c839ac623ea2fed8f5ab84e2337c92">information</a></div><div class="ttdeci">The object format emitted by the WebAssembly backed is documented see the home and packaging for producing WebAssembly applications that can run in browsers and other environments wasi sdk provides a more minimal C C SDK based on llvm and a libc based on for producing WebAssemmbly applictions that use the WASI ABI Rust provides WebAssembly support integrated into Cargo There are two main which provides a relatively minimal environment that has an emphasis on being native wasm32 unknown which uses Emscripten internally and provides standard C C filesystem GL and SDL bindings For more information</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2WebAssembly_2README_8txt_source.html#l00029">README.txt:29</a></div></div>
<div class="ttc" id="aREADME-SSE_8txt_html_a1706b9d35a69e86ba5b6094f0b256ae0"><div class="ttname"><a href="README-SSE_8txt.html#a1706b9d35a69e86ba5b6094f0b256ae0">tmp5</a></div><div class="ttdeci">&lt; float &gt; tmp5</div><div class="ttdef"><b>Definition:</b> <a href="README-SSE_8txt_source.html#l00794">README-SSE.txt:794</a></div></div>
<div class="ttc" id="alib_2CodeGen_2README_8txt_html_a1b127ab267777f5141fea60180117243"><div class="ttname"><a href="lib_2CodeGen_2README_8txt.html#a1b127ab267777f5141fea60180117243">nth_el</a></div><div class="ttdeci">Common register allocation spilling lr str ldr sxth r3 ldr mla r4 can lr mov lr str ldr sxth r3 mla r4 and then merge mul and lr str ldr sxth r3 mla r4 It also increase the likelihood the store may become dead bb27 Successors according to LLVM ID Predecessors according to mbb&lt; bb27, 0x8b0a7c0 &gt; Note ADDri is not a two address instruction its result reg1037 is an operand of the PHI node in bb76 and its operand reg1039 is the result of the PHI node We should treat it as a two address code and make sure the ADDri is scheduled after any node that reads reg1039 Use info(i.e. register scavenger) to assign it a free register to allow reuse the collector could move the objects and invalidate the derived pointer This is bad enough in the first but safe points can crop up unpredictably **array_addr nth_el</div><div class="ttdef"><b>Definition:</b> <a href="lib_2CodeGen_2README_8txt_source.html#l00122">README.txt:122</a></div></div>
<div class="ttc" id="alib_2Target_2X86_2README_8txt_html_a64373601963f551587d536786657235f"><div class="ttname"><a href="lib_2Target_2X86_2README_8txt.html#a64373601963f551587d536786657235f">movzbl</a></div><div class="ttdeci">_test eax xmm0 eax xmm1 comiss xmm1 setae al movzbl ecx eax edx ecx cmove eax ret Note the movzbl</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2X86_2README_8txt_source.html#l00210">README.txt:210</a></div></div>
<div class="ttc" id="anamespacellvm_1_1SyncScope_html_a4f8fa2bf4e0acbf29065f51c8c3cad47af9706a2e196638078e8323bfd9ba17de"><div class="ttname"><a href="namespacellvm_1_1SyncScope.html#a4f8fa2bf4e0acbf29065f51c8c3cad47af9706a2e196638078e8323bfd9ba17de">llvm::SyncScope::System</a></div><div class="ttdeci">@ System</div><div class="ttdoc">Synchronized with respect to all concurrently executing threads.</div><div class="ttdef"><b>Definition:</b> <a href="LLVMContext_8h_source.html#l00057">LLVMContext.h:57</a></div></div>
<div class="ttc" id="aREADME__ALTIVEC_8txt_html_a1db0193cd0ce687eb4694b8ec0da7116"><div class="ttname"><a href="README__ALTIVEC_8txt.html#a1db0193cd0ce687eb4694b8ec0da7116">pool</a></div><div class="ttdeci">Implement PPCInstrInfo::isLoadFromStackSlot isStoreToStackSlot for vector to generate better spill code The first should be a single lvx from the constant pool</div><div class="ttdef"><b>Definition:</b> <a href="README__ALTIVEC_8txt_source.html#l00008">README_ALTIVEC.txt:8</a></div></div>
<div class="ttc" id="alib_2Target_2X86_2README_8txt_html_a16dd6a3a41e4981e4fb855ca1b53a73b"><div class="ttname"><a href="lib_2Target_2X86_2README_8txt.html#a16dd6a3a41e4981e4fb855ca1b53a73b">movsd</a></div><div class="ttdeci">For the entry BB esp pxor xmm0 movsd(%esp)</div></div>
<div class="ttc" id="alib_2Target_2X86_2README_8txt_html_a09c65fe6b8b0d95c3585bcfe405acad2"><div class="ttname"><a href="lib_2Target_2X86_2README_8txt.html#a09c65fe6b8b0d95c3585bcfe405acad2">however</a></div><div class="ttdeci">however</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2X86_2README_8txt_source.html#l00253">README.txt:253</a></div></div>
<div class="ttc" id="aHexagonStoreWidening_8cpp_html_a7d2c711a42f51c1f7b3ce3f8f560fa74"><div class="ttname"><a href="HexagonStoreWidening_8cpp.html#a7d2c711a42f51c1f7b3ce3f8f560fa74">stores</a></div><div class="ttdeci">hexagon widen stores</div><div class="ttdef"><b>Definition:</b> <a href="HexagonStoreWidening_8cpp_source.html#l00118">HexagonStoreWidening.cpp:118</a></div></div>
<div class="ttc" id="ainclude_2llvm_2Demangle_2README_8txt_html_a236b4f413809bd7297d3cc98b4854aa1"><div class="ttname"><a href="include_2llvm_2Demangle_2README_8txt.html#a236b4f413809bd7297d3cc98b4854aa1">Library</a></div><div class="ttdeci">Itanium Name Demangler Library</div><div class="ttdef"><b>Definition:</b> <a href="include_2llvm_2Demangle_2README_8txt_source.html#l00002">README.txt:2</a></div></div>
<div class="ttc" id="aREADME__P9_8txt_html_af514567e4b44d896f4eebc31c5e25362"><div class="ttname"><a href="README__P9_8txt.html#af514567e4b44d896f4eebc31c5e25362">outs</a></div><div class="ttdeci">So we should use XX3Form_Rcr to implement intrinsic Convert DP outs ins xscvdpsp No builtin are required Round &amp;Convert QP DP(dword[1] is set to zero) No builtin are required Round to Quad Precision because you need to assign rounding mode in instruction Provide builtin(set f128:$vT,(int_ppc_vsx_xsrqpi f128:$vB))(set f128 yields&lt; n x&lt; ty &gt; &gt;&lt; result &gt; yields&lt; ty &gt;&lt; result &gt; No builtin are required Load Store load store see def memrix16 in PPCInstrInfo td Load Store Vector load store outs ins lxsdx set load store with conversion from to outs ins lxsspx set load store outs ins lxsiwzx set PPClfiwzx outs</div><div class="ttdoc">This returns a reference to a raw_fd_ostream for standard output.</div><div class="ttdef"><b>Definition:</b> <a href="README__P9_8txt_source.html#l00537">README_P9.txt:537</a></div></div>
<div class="ttc" id="aDataLayout_8cpp_html_a974f64e92d8749b49b9179a0bf255b93"><div class="ttname"><a href="DataLayout_8cpp.html#a974f64e92d8749b49b9179a0bf255b93">split</a></div><div class="ttdeci">static Error split(StringRef Str, char Separator, std::pair&lt; StringRef, StringRef &gt; &amp;Split)</div><div class="ttdoc">Checked version of split, to ensure mandatory subparts.</div><div class="ttdef"><b>Definition:</b> <a href="DataLayout_8cpp_source.html#l00215">DataLayout.cpp:215</a></div></div>
<div class="ttc" id="alib_2Target_2README_8txt_html_af87ed8d71d4b08ae585a1fb4104e4399"><div class="ttname"><a href="lib_2Target_2README_8txt.html#af87ed8d71d4b08ae585a1fb4104e4399">integers</a></div><div class="ttdeci">into llvm powi allowing the code generator to produce balanced multiplication trees the intrinsic needs to be extended to support integers</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2README_8txt_source.html#l00054">README.txt:54</a></div></div>
<div class="ttc" id="alib_2Target_2ARM_2README_8txt_html_a91f4469a9d29e354421494afd4ba466d"><div class="ttname"><a href="lib_2Target_2ARM_2README_8txt.html#a91f4469a9d29e354421494afd4ba466d">to</a></div><div class="ttdeci">Should compile to</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2ARM_2README_8txt_source.html#l00449">README.txt:449</a></div></div>
<div class="ttc" id="alib_2Target_2X86_2README_8txt_html_a2ba85c98965b2b89bc453b60cbc800f8"><div class="ttname"><a href="lib_2Target_2X86_2README_8txt.html#a2ba85c98965b2b89bc453b60cbc800f8">Example</a></div><div class="ttdeci">it should cost the same as a move shift on any modern but it s a lot shorter Downside is that it puts more pressure on register allocation because it has fixed operands Example</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2X86_2README_8txt_source.html#l00928">README.txt:928</a></div></div>
<div class="ttc" id="alib_2Target_2X86_2README_8txt_html_abc38f81a544f9417a73f88b85da6cb34"><div class="ttname"><a href="lib_2Target_2X86_2README_8txt.html#abc38f81a544f9417a73f88b85da6cb34">xorl</a></div><div class="ttdeci">http eax xorl edx cl sete al setne dl sall eax sall edx But that requires good bit subreg support this might be better It s an extra but it s one instruction and doesn t stress bit subreg eax eax movl edx xorl</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2X86_2README_8txt_source.html#l00037">README.txt:37</a></div></div>
<div class="ttc" id="alib_2Target_2README_8txt_html_a8db36c82f32d6f6a4d35a00e55be03a8"><div class="ttname"><a href="lib_2Target_2README_8txt.html#a8db36c82f32d6f6a4d35a00e55be03a8">Shift</a></div><div class="ttdeci">bool Shift</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2README_8txt_source.html#l00468">README.txt:468</a></div></div>
<div class="ttc" id="alib_2Target_2PowerPC_2README_8txt_html_a30b0d04389af55063e2935553f66712a"><div class="ttname"><a href="lib_2Target_2PowerPC_2README_8txt.html#a30b0d04389af55063e2935553f66712a">cr7</a></div><div class="ttdeci">Should compile to something r4 addze r3 instead we r3 cmplw cr7</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2PowerPC_2README_8txt_source.html#l00025">README.txt:25</a></div></div>
<div class="ttc" id="alib_2Target_2README_8txt_html_a4b3c18dbe93e1ee705f5fc91af01ebcb"><div class="ttname"><a href="lib_2Target_2README_8txt.html#a4b3c18dbe93e1ee705f5fc91af01ebcb">hypot</a></div><div class="ttdeci">The legalization code for mul with overflow needs to be made more robust before this can be implemented though Get the C front end to expand hypot(x, y) -&gt; llvm.sqrt(x *x+y *y) when errno and precision don 't matter(ffastmath). Misc/mandel will like this. :) This isn 't safe in general, even on darwin. See the libm implementation of hypot for examples(which special case when x/y are exactly zero to get signed zeros etc right). On targets with expensive 64-bit multiply, we could LSR this:for(i=...</div></div>
<div class="ttc" id="alib_2Target_2README_8txt_html_a9fa9d8c22b30973a760ea3741f8aac45"><div class="ttname"><a href="lib_2Target_2README_8txt.html#a9fa9d8c22b30973a760ea3741f8aac45">calls</a></div><div class="ttdeci">into llvm powi calls</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2README_8txt_source.html#l00051">README.txt:51</a></div></div>
<div class="ttc" id="alib_2Target_2ARM_2README_8txt_html_aaa716085f72444f6347e76956ee4cf7d"><div class="ttname"><a href="lib_2Target_2ARM_2README_8txt.html#aaa716085f72444f6347e76956ee4cf7d">ip</a></div><div class="ttdeci">mov ip</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2ARM_2README_8txt_source.html#l00214">README.txt:214</a></div></div>
<div class="ttc" id="alib_2Target_2PowerPC_2README_8txt_html_aae9be2bd2adc2b61770a233ba3fc7fb0"><div class="ttname"><a href="lib_2Target_2PowerPC_2README_8txt.html#aae9be2bd2adc2b61770a233ba3fc7fb0">ha16</a></div><div class="ttdeci">We ha16(.CPI_X_0) lfd f0</div></div>
<div class="ttc" id="anamespacellvm_1_1sys_1_1path_html_a214ec2f04ffd92636ed4bd2717607a1d"><div class="ttname"><a href="namespacellvm_1_1sys_1_1path.html#a214ec2f04ffd92636ed4bd2717607a1d">llvm::sys::path::end</a></div><div class="ttdeci">const_iterator end(StringRef path)</div><div class="ttdoc">Get end iterator over path.</div><div class="ttdef"><b>Definition:</b> <a href="Path_8cpp_source.html#l00235">Path.cpp:235</a></div></div>
<div class="ttc" id="anamespacellvm_1_1remarks_html_aeb5853e98ae4d9ab7cb002879736527faca9e83a6c347b2bdf7f00ef202a331ad"><div class="ttname"><a href="namespacellvm_1_1remarks.html#aeb5853e98ae4d9ab7cb002879736527faca9e83a6c347b2bdf7f00ef202a331ad">llvm::remarks::Type::Missed</a></div><div class="ttdeci">@ Missed</div></div>
<div class="ttc" id="alib_2Target_2README_8txt_html_add71801b35be0fc55386370f571068fb"><div class="ttname"><a href="lib_2Target_2README_8txt.html#add71801b35be0fc55386370f571068fb">i8</a></div><div class="ttdeci">Clang compiles this i8</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2README_8txt_source.html#l00504">README.txt:504</a></div></div>
<div class="ttc" id="alib_2Target_2ARM_2README_8txt_html_a86bd01c89bf19da5edcd8fd83325d6f6"><div class="ttname"><a href="lib_2Target_2ARM_2README_8txt.html#a86bd01c89bf19da5edcd8fd83325d6f6">cpy</a></div><div class="ttdeci">void cpy(struct foo *a, struct foo *b)</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2ARM_2README_8txt_source.html#l00122">README.txt:122</a></div></div>
<div class="ttc" id="aPassBuilderBindings_8cpp_html_ad4d247df65c12507f447383be37d7ccb"><div class="ttname"><a href="PassBuilderBindings_8cpp.html#ad4d247df65c12507f447383be37d7ccb">PIC</a></div><div class="ttdeci">PassInstrumentationCallbacks PIC</div><div class="ttdef"><b>Definition:</b> <a href="PassBuilderBindings_8cpp_source.html#l00055">PassBuilderBindings.cpp:55</a></div></div>
<div class="ttc" id="aREADME__P9_8txt_html_a08427d89823ae59cd237475dde4e07e8"><div class="ttname"><a href="README__P9_8txt.html#a08427d89823ae59cd237475dde4e07e8">Integer</a></div><div class="ttdeci">So we should use XX3Form_Rcr to implement intrinsic Convert DP outs ins xscvdpsp No builtin are required Round &amp;Convert QP DP(dword[1] is set to zero) No builtin are required Round to Quad Precision Integer</div><div class="ttdef"><b>Definition:</b> <a href="README__P9_8txt_source.html#l00366">README_P9.txt:366</a></div></div>
<div class="ttc" id="alib_2Target_2X86_2README_8txt_html_aa38a636405ee581795ea6b3f4efdb400"><div class="ttname"><a href="lib_2Target_2X86_2README_8txt.html#aa38a636405ee581795ea6b3f4efdb400">shrl</a></div><div class="ttdeci">http eax xorl edx cl sete al setne dl sall eax sall edx But that requires good bit subreg support this might be better It s an extra but it s one instruction and doesn t stress bit subreg eax shrl</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2X86_2README_8txt_source.html#l00035">README.txt:35</a></div></div>
<div class="ttc" id="anamespacellvm_1_1AArch64ISD_html_a35ad1b8db0dfad0b69c9185c5fe24e19a1506f6dab9103c66c2463fdded31a599"><div class="ttname"><a href="namespacellvm_1_1AArch64ISD.html#a35ad1b8db0dfad0b69c9185c5fe24e19a1506f6dab9103c66c2463fdded31a599">llvm::AArch64ISD::CALL</a></div><div class="ttdeci">@ CALL</div><div class="ttdef"><b>Definition:</b> <a href="AArch64ISelLowering_8h_source.html#l00053">AArch64ISelLowering.h:53</a></div></div>
<div class="ttc" id="aREADME-SSE_8txt_html_a6c62ec3cb52530b4d5ac3891549b253e"><div class="ttname"><a href="README-SSE_8txt.html#a6c62ec3cb52530b4d5ac3891549b253e">know</a></div><div class="ttdeci">the custom lowered code happens to be but we shouldn t have to custom lower anything This is probably related to&lt; 2 x i64 &gt; ops being so bad LLVM currently generates stack realignment when it is not necessary needed The problem is that we need to know about stack alignment too before RA runs At that point we don t know</div><div class="ttdef"><b>Definition:</b> <a href="README-SSE_8txt_source.html#l00489">README-SSE.txt:489</a></div></div>
<div class="ttc" id="aclassStringView_html_ac6b0c8dc91ff0f53ceb554091519b5ac"><div class="ttname"><a href="classStringView.html#ac6b0c8dc91ff0f53ceb554091519b5ac">StringView::StringView</a></div><div class="ttdeci">StringView(const char(&amp;Str)[N])</div><div class="ttdef"><b>Definition:</b> <a href="StringView_8h_source.html#l00033">StringView.h:33</a></div></div>
<div class="ttc" id="aREADME__ALTIVEC_8txt_html_aa100c3ab24b9c0b6bc434846f615ec59"><div class="ttname"><a href="README__ALTIVEC_8txt.html#aa100c3ab24b9c0b6bc434846f615ec59">slot</a></div><div class="ttdeci">Since we know that Vector is byte aligned and we know the element offset of we should change the load into a lve *x instead of doing a load store lve *x sequence Implement passing vectors by value into calls and receiving them as arguments GCC apparently tries to then a load and vperm of Variable We need a way to teach tblgen that some operands of an intrinsic are required to be constants The verifier should enforce this constraint We currently codegen SCALAR_TO_VECTOR as a store of the scalar to a byte aligned stack slot</div><div class="ttdef"><b>Definition:</b> <a href="README__ALTIVEC_8txt_source.html#l00057">README_ALTIVEC.txt:57</a></div></div>
<div class="ttc" id="anamespacellvm_1_1WinEH_html_a1c8d8103d6b914c2ade85873cb97f6d9a19ba66c202fd06b553e4e1895204561d"><div class="ttname"><a href="namespacellvm_1_1WinEH.html#a1c8d8103d6b914c2ade85873cb97f6d9a19ba66c202fd06b553e4e1895204561d">llvm::WinEH::EncodingType::Itanium</a></div><div class="ttdeci">@ Itanium</div><div class="ttdoc">Windows CE ARM, PowerPC, SH3, SH4.</div></div>
<div class="ttc" id="alib_2CodeGen_2README_8txt_html_a230c75716e547f5cd219c22b802badbc"><div class="ttname"><a href="lib_2CodeGen_2README_8txt.html#a230c75716e547f5cd219c22b802badbc">copies</a></div><div class="ttdeci">Common register allocation spilling lr str ldr sxth r3 ldr mla r4 can lr mov lr str ldr sxth r3 mla r4 and then merge mul and lr str ldr sxth r3 mla r4 It also increase the likelihood the store may become dead bb27 Successors according to LLVM ID Predecessors according to mbb&lt; bb27, 0x8b0a7c0 &gt; Note ADDri is not a two address instruction its result reg1037 is an operand of the PHI node in bb76 and its operand reg1039 is the result of the PHI node We should treat it as a two address code and make sure the ADDri is scheduled after any node that reads reg1039 Use info(i.e. register scavenger) to assign it a free register to allow reuse the collector could move the objects and invalidate the derived pointer This is bad enough in the first but safe points can crop up unpredictably **array_addr i32 n y store obj obj **nth_el If the i64 division is lowered to a then a safe point array and nth_el no longer point into the correct object The fix for this is to copy address calculations so that dependent pointers are never live across safe point boundaries But the loads cannot be copied like this if there was an intervening so may be hard to get right Only a concurrent mutator can trigger a collection at the libcall safe point So single threaded programs do not have this even with a copying collector LLVM optimizations would probably undo a front end s careful work The ocaml frametable structure supports liveness information It would be good to support it The FIXME in ComputeCommonTailLength in BranchFolding cpp needs to be revisited The check is there to work around a misuse of directives in assembly It would be good to detect collector target compatibility instead of silently doing the wrong thing It would be really nice to be able to write patterns in td files for copies</div><div class="ttdef"><b>Definition:</b> <a href="lib_2CodeGen_2README_8txt_source.html#l00158">README.txt:158</a></div></div>
<div class="ttc" id="anamespacellvm_1_1AMDGPU_1_1Exp_html_af7592dc94276d1958420bcfb414b6998"><div class="ttname"><a href="namespacellvm_1_1AMDGPU_1_1Exp.html#af7592dc94276d1958420bcfb414b6998">llvm::AMDGPU::Exp::Target</a></div><div class="ttdeci">Target</div><div class="ttdef"><b>Definition:</b> <a href="SIDefines_8h_source.html#l00868">SIDefines.h:868</a></div></div>
<div class="ttc" id="alib_2Target_2README_8txt_html_a0487c20cd208795e5056725608b916d2"><div class="ttname"><a href="lib_2Target_2README_8txt.html#a0487c20cd208795e5056725608b916d2">ppc32</a></div><div class="ttdeci">This would be a win on ppc32</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2README_8txt_source.html#l00037">README.txt:37</a></div></div>
<div class="ttc" id="aMips16ISelLowering_8cpp_html_a0acb682b8260ab1c60b918599864e2e5"><div class="ttname"><a href="Mips16ISelLowering_8cpp.html#a0acb682b8260ab1c60b918599864e2e5">T</a></div><div class="ttdeci">#define T</div><div class="ttdef"><b>Definition:</b> <a href="Mips16ISelLowering_8cpp_source.html#l00341">Mips16ISelLowering.cpp:341</a></div></div>
<div class="ttc" id="aREADME__P9_8txt_html_a9679eda65da04e63b0fc49644be06685"><div class="ttname"><a href="README__P9_8txt.html#a9679eda65da04e63b0fc49644be06685">i1</a></div><div class="ttdeci">Decimal Convert From to National Zoned Signed int_ppc_altivec_bcdcfno i1</div><div class="ttdef"><b>Definition:</b> <a href="README__P9_8txt_source.html#l00147">README_P9.txt:147</a></div></div>
<div class="ttc" id="alib_2Target_2X86_2README_8txt_html_aaf6381f136d6cb9f13adbd90b1781923"><div class="ttname"><a href="lib_2Target_2X86_2README_8txt.html#aaf6381f136d6cb9f13adbd90b1781923">ret</a></div><div class="ttdeci">to esp esp setne al movzbw ax esp setg cl movzbw cx cmove cx cl jne LBB1_2 esp ret(also really horrible code on ppc). This is due to the expand code for 64-bit compares. GCC produces multiple branches</div></div>
<div class="ttc" id="alib_2Target_2ARM_2README_8txt_html_a21c585d620071635b2853253f8935a63"><div class="ttname"><a href="lib_2Target_2ARM_2README_8txt.html#a21c585d620071635b2853253f8935a63">comparison</a></div><div class="ttdeci">the resulting code requires compare and branches when and if the revised code is with conditional branches instead of More there is a byte word extend before each comparison</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2ARM_2README_8txt_source.html#l00401">README.txt:401</a></div></div>
<div class="ttc" id="alib_2Target_2README_8txt_html_ac84c84602925d003e65dd56b760ea692"><div class="ttname"><a href="lib_2Target_2README_8txt.html#ac84c84602925d003e65dd56b760ea692">a3</a></div><div class="ttdeci">This is blocked on not handling X *X *X which is the same number of multiplies and is because the *X has multiple uses Here s a simple X1 B ret i32 C Reassociate should handle the example in GCC a3</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2README_8txt_source.html#l00084">README.txt:84</a></div></div>
<div class="ttc" id="alib_2Target_2ARM_2README_8txt_html_af84fbbd129a1fbd3981dfbe6f607ddf4"><div class="ttname"><a href="lib_2Target_2ARM_2README_8txt.html#af84fbbd129a1fbd3981dfbe6f607ddf4">at</a></div><div class="ttdeci">compiles ldr LCPI1_0 ldr ldr mov lsr tst moveq r1 ldr LCPI1_1 and r0 bx lr It would be better to do something like to fold the shift into the conditional ldr LCPI1_0 ldr ldr tst movne lsr ldr LCPI1_1 and r0 bx lr it saves an instruction and a register It might be profitable to cse MOVi16 if there are lots of bit immediates with the same bottom half Robert Muth started working on an alternate jump table implementation that does not put the tables in line in the text This is more like the llvm default jump table implementation This might be useful sometime Several revisions of patches are on the mailing beginning at</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2ARM_2README_8txt_source.html#l00582">README.txt:582</a></div></div>
<div class="ttc" id="anamespacellvm_1_1sys_1_1fs_html_a592297dd80c13e993380e2bf972721ac"><div class="ttname"><a href="namespacellvm_1_1sys_1_1fs.html#a592297dd80c13e993380e2bf972721ac">llvm::sys::fs::access</a></div><div class="ttdeci">std::error_code access(const Twine &amp;Path, AccessMode Mode)</div><div class="ttdoc">Can the file be accessed?</div></div>
<div class="ttc" id="alib_2Target_2X86_2README_8txt_html_a78262111e7bde7f40b8169305b7c7316"><div class="ttname"><a href="lib_2Target_2X86_2README_8txt.html#a78262111e7bde7f40b8169305b7c7316">fh</a></div><div class="ttdeci">float fh</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2X86_2README_8txt_source.html#l00292">README.txt:292</a></div></div>
<div class="ttc" id="anamespacellvm_html_ab4d4bc901fedd8857f647dcc2c0d71de"><div class="ttname"><a href="namespacellvm.html#ab4d4bc901fedd8857f647dcc2c0d71de">llvm::max</a></div><div class="ttdeci">Expected&lt; ExpressionValue &gt; max(const ExpressionValue &amp;Lhs, const ExpressionValue &amp;Rhs)</div><div class="ttdef"><b>Definition:</b> <a href="FileCheck_8cpp_source.html#l00337">FileCheck.cpp:337</a></div></div>
<div class="ttc" id="anamespacellvm_html_a9a7b5c68c90f85baaedaa854cc5002cc"><div class="ttname"><a href="namespacellvm.html#a9a7b5c68c90f85baaedaa854cc5002cc">llvm::errs</a></div><div class="ttdeci">raw_fd_ostream &amp; errs()</div><div class="ttdoc">This returns a reference to a raw_ostream for standard error.</div><div class="ttdef"><b>Definition:</b> <a href="raw__ostream_8cpp_source.html#l00899">raw_ostream.cpp:899</a></div></div>
<div class="ttc" id="aHexagonLoopIdiomRecognition_8cpp_html_a9371465bee244384e16430065f3e1136"><div class="ttname"><a href="HexagonLoopIdiomRecognition_8cpp.html#a9371465bee244384e16430065f3e1136">idiom</a></div><div class="ttdeci">hexagon loop idiom</div><div class="ttdef"><b>Definition:</b> <a href="HexagonLoopIdiomRecognition_8cpp_source.html#l00283">HexagonLoopIdiomRecognition.cpp:283</a></div></div>
<div class="ttc" id="alib_2Target_2ARM_2README_8txt_html_a806885525dd4f77e8ef4f8b6bad2902d"><div class="ttname"><a href="lib_2Target_2ARM_2README_8txt.html#a806885525dd4f77e8ef4f8b6bad2902d">g</a></div><div class="ttdeci">should just be implemented with a CLZ instruction Since there are other e g</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2ARM_2README_8txt_source.html#l00709">README.txt:709</a></div></div>
<div class="ttc" id="alib_2Target_2X86_2README_8txt_html_a57cd747c070c3e61bf6dc6cdaff2978d"><div class="ttname"><a href="lib_2Target_2X86_2README_8txt.html#a57cd747c070c3e61bf6dc6cdaff2978d">tmp1</a></div><div class="ttdeci">urem i32 %X, 255 ret i32 %tmp1 } Currently it compiles to:... movl $2155905153, %ecx movl 8(%esp), %esi movl %esi, %eax mull %ecx ... This could be &quot;reassociated&quot; into:movl $2155905153, %eax movl 8(%esp), %ecx mull %ecx to avoid the copy. In fact, the existing two-address stuff would do this except that mul isn 't a commutative 2-addr instruction. I guess this has to be done at isel time based on the #uses to mul? Make sure the instruction which starts a loop does not cross a cacheline boundary. This requires knowning the exact length of each machine instruction. That is somewhat complicated, but doable. Example 256.bzip2:In the new trace, the hot loop has an instruction which crosses a cacheline boundary. In addition to potential cache misses, this can 't help decoding as I imagine there has to be some kind of complicated decoder reset and realignment to grab the bytes from the next cacheline. 532 532 0x3cfc movb(1809(%esp, %esi), %bl&lt;&lt;&lt;--- spans 2 64 byte lines 942 942 0x3d03 movl %dh,(1809(%esp, %esi) 937 937 0x3d0a incl %esi 3 3 0x3d0b cmpb %bl, %dl 27 27 0x3d0d jnz 0x000062db&lt; main+11707 &gt; In c99 mode, the preprocessor doesn 't like assembly comments like #TRUNCATE. This could be a single 16-bit load. int f(char *p) { if((p[0]==1) &amp;(p[1]==2)) return 1 tmp1</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2X86_2README_8txt_source.html#l00375">README.txt:375</a></div></div>
<div class="ttc" id="aX86PartialReduction_8cpp_html_a87b8bfbbe9d8f7146d7f20a5fb42efd0"><div class="ttname"><a href="X86PartialReduction_8cpp.html#a87b8bfbbe9d8f7146d7f20a5fb42efd0">RHS</a></div><div class="ttdeci">Value * RHS</div><div class="ttdef"><b>Definition:</b> <a href="X86PartialReduction_8cpp_source.html#l00076">X86PartialReduction.cpp:76</a></div></div>
<div class="ttc" id="alib_2Target_2WebAssembly_2README_8txt_html_aa7e4e4cac7bed5e87e675aa6b553d2d8"><div class="ttname"><a href="lib_2Target_2WebAssembly_2README_8txt.html#aa7e4e4cac7bed5e87e675aa6b553d2d8">pass</a></div><div class="ttdeci">we should consider alternate ways to model stack dependencies Lots of things could be done in WebAssemblyTargetTransformInfo cpp there are numerous optimization related hooks that can be overridden in WebAssemblyTargetLowering Instead of the OptimizeReturned pass</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2WebAssembly_2README_8txt_source.html#l00073">README.txt:73</a></div></div>
<div class="ttc" id="alib_2Target_2WebAssembly_2README_8txt_html_a3828c493031579f0c68587b19619f7e2"><div class="ttname"><a href="lib_2Target_2WebAssembly_2README_8txt.html#a3828c493031579f0c68587b19619f7e2">that</a></div><div class="ttdeci">we should consider alternate ways to model stack dependencies Lots of things could be done in WebAssemblyTargetTransformInfo cpp there are numerous optimization related hooks that can be overridden in WebAssemblyTargetLowering Instead of the OptimizeReturned which should consider preserving the returned attribute through to MachineInstrs and extending the MemIntrinsicResults pass to do this optimization on calls too That would also let the WebAssemblyPeephole pass clean up dead defs for such as it does for stores Consider implementing and or getMachineCombinerPatterns Find a clean way to fix the problem which leads to the Shrink Wrapping pass being run after the WebAssembly PEI pass When setting multiple variables to the same we currently get code like const It could be done with a smaller encoding like local tee $pop5 local $pop6 WebAssembly registers are implicitly initialized to zero Explicit zeroing is therefore often redundant and could be optimized away Small indices may use smaller encodings than large indices WebAssemblyRegColoring and or WebAssemblyRegRenumbering should sort registers according to their usage frequency to maximize the usage of smaller encodings Many cases of irreducible control flow could be transformed more optimally than via the transform in WebAssemblyFixIrreducibleControlFlow cpp It may also be worthwhile to do transforms before register particularly when duplicating to allow register coloring to be aware of the duplication WebAssemblyRegStackify could use AliasAnalysis to reorder loads and stores more aggressively WebAssemblyRegStackify is currently a greedy algorithm This means that</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2WebAssembly_2README_8txt_source.html#l00130">README.txt:130</a></div></div>
<div class="ttc" id="alib_2Target_2README_8txt_html_a2b93cae1bac42b837192c736266050bf"><div class="ttname"><a href="lib_2Target_2README_8txt.html#a2b93cae1bac42b837192c736266050bf">assertion</a></div><div class="ttdeci">we compile this esp call L1 $pb L1 esp je LBB1_2 esp ret but is currently always computed in the entry block It would be better to sink the picbase computation down into the block for the assertion</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2README_8txt_source.html#l00422">README.txt:422</a></div></div>
<div class="ttc" id="alib_2Target_2X86_2README_8txt_html_a82bd4f4b721c049035c0d86cc261eadd"><div class="ttname"><a href="lib_2Target_2X86_2README_8txt.html#a82bd4f4b721c049035c0d86cc261eadd">tmp</a></div><div class="ttdeci">alloca&lt; 16 x float &gt;, align 16 %tmp2=alloca&lt; 16 x float &gt;, align 16 store&lt; 16 x float &gt; %A,&lt; 16 x float &gt; *%tmp %s=bitcast&lt; 16 x float &gt; *%tmp to i8 *%s2=bitcast&lt; 16 x float &gt; *%tmp2 to i8 *call void @llvm.memcpy.i64(i8 *%s, i8 *%s2, i64 64, i32 16) %R=load&lt; 16 x float &gt; *%tmp2 ret&lt; 16 x float &gt; %R } declare void @llvm.memcpy.i64(i8 *nocapture, i8 *nocapture, i64, i32) nounwind which compiles to:_foo:subl $140, %esp movaps %xmm3, 112(%esp) movaps %xmm2, 96(%esp) movaps %xmm1, 80(%esp) movaps %xmm0, 64(%esp) movl 60(%esp), %eax movl %eax, 124(%esp) movl 56(%esp), %eax movl %eax, 120(%esp) movl 52(%esp), %eax&lt; many many more 32-bit copies &gt; movaps(%esp), %xmm0 movaps 16(%esp), %xmm1 movaps 32(%esp), %xmm2 movaps 48(%esp), %xmm3 addl $140, %esp ret On Nehalem, it may even be cheaper to just use movups when unaligned than to fall back to lower-granularity chunks. Implement processor-specific optimizations for parity with GCC on these processors. GCC does two optimizations:1. ix86_pad_returns inserts a noop before ret instructions if immediately preceded by a conditional branch or is the target of a jump. 2. ix86_avoid_jump_misspredicts inserts noops in cases where a 16-byte block of code contains more than 3 branches. The first one is done for all AMDs, Core2, and &quot;Generic&quot; The second one is done for:Atom, Pentium Pro, all AMDs, Pentium 4, Nocona, Core 2, and &quot;Generic&quot; Testcase:int x(int a) { return(a &amp;0xf0)&gt; &gt;4 tmp</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2X86_2README_8txt_source.html#l01347">README.txt:1347</a></div></div>
<div class="ttc" id="anamespacellvm_1_1lltok_html_af353621f14cb4b4b3af5ffaff84076b1af6b233c12b6971f63e8d302d8cd9d362"><div class="ttname"><a href="namespacellvm_1_1lltok.html#af353621f14cb4b4b3af5ffaff84076b1af6b233c12b6971f63e8d302d8cd9d362">llvm::lltok::less</a></div><div class="ttdeci">@ less</div><div class="ttdef"><b>Definition:</b> <a href="LLToken_8h_source.html#l00032">LLToken.h:32</a></div></div>
<div class="ttc" id="alib_2Target_2ARM_2README_8txt_html_a561a8b86dac9675138ca8d531aac1f78"><div class="ttname"><a href="lib_2Target_2ARM_2README_8txt.html#a561a8b86dac9675138ca8d531aac1f78">Likewise</a></div><div class="ttdeci">Should compile r2 movcc movcs str strb mov lr r1 movcs movcc mov lr r1 str mov mov cmp r1 movlo r2 str bx lr r0 mov mov cmp r0 movhs r2 mov r1 bx lr Some of the NEON intrinsics may be appropriate for more general either as target independent intrinsics or perhaps elsewhere in the ARM backend Some of them may also be lowered to target independent and perhaps some new SDNodes could be added For and absolute value operations are well defined and standard both for vector and scalar types The current NEON specific intrinsics for count leading zeros and count one bits could perhaps be replaced by the target independent ctlz and ctpop intrinsics It may also make sense to add a target independent ctls intrinsic for count leading sign bits Likewise</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2ARM_2README_8txt_source.html#l00495">README.txt:495</a></div></div>
<div class="ttc" id="alib_2Target_2README_8txt_html_a7d7452607c1ef42f1fccbb83ac7cba6d"><div class="ttname"><a href="lib_2Target_2README_8txt.html#a7d7452607c1ef42f1fccbb83ac7cba6d">handle</a></div><div class="ttdeci">then ret i32 result Tail recursion elimination should handle</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2README_8txt_source.html#l00355">README.txt:355</a></div></div>
<div class="ttc" id="alib_2Target_2X86_2README_8txt_html_aef44c1ad24071fc390303ba8ebf04af3"><div class="ttname"><a href="lib_2Target_2X86_2README_8txt.html#aef44c1ad24071fc390303ba8ebf04af3">generates</a></div><div class="ttdeci">gets compiled into this on rsp movaps rsp movaps rsp movaps rsp movaps rsp movaps rsp movaps rsp movaps rsp movaps rsp movq rsp movq rsp movq rsp movq rsp movq rsp rax movq rsp rax movq rsp rsp rsp eax eax jbe LBB1_3 rcx rax movq rsp eax rsp ret ecx eax rcx movl rsp jmp LBB1_2 gcc generates</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2X86_2README_8txt_source.html#l01153">README.txt:1153</a></div></div>
<div class="ttc" id="aConstantMerge_8cpp_html_acf172e841018fd16e65771f5ade0b297"><div class="ttname"><a href="ConstantMerge_8cpp.html#acf172e841018fd16e65771f5ade0b297">replace</a></div><div class="ttdeci">static void replace(Module &amp;M, GlobalVariable *Old, GlobalVariable *New)</div><div class="ttdef"><b>Definition:</b> <a href="ConstantMerge_8cpp_source.html#l00116">ConstantMerge.cpp:116</a></div></div>
<div class="ttc" id="alib_2Target_2X86_2README_8txt_html_a0aa3d83b100058ffd7399364d6b76b5d"><div class="ttname"><a href="lib_2Target_2X86_2README_8txt.html#a0aa3d83b100058ffd7399364d6b76b5d">and</a></div><div class="ttdeci">We currently generate a but we really shouldn eax ecx xorl edx divl ecx eax divl ecx movl eax ret A similar code sequence works for division We currently compile i32 v2 eax eax jo LBB1_2 and</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2X86_2README_8txt_source.html#l01271">README.txt:1271</a></div></div>
<div class="ttc" id="alib_2Target_2README_8txt_html_a2352e45658fc7292aa209a94baa095e9"><div class="ttname"><a href="lib_2Target_2README_8txt.html#a2352e45658fc7292aa209a94baa095e9">x86</a></div><div class="ttdeci">Note that only the low bits of effective_addr2 are used On bit we don t eliminate the computation of the top half of effective_addr2 because we don t have whole function selection dags On x86</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2README_8txt_source.html#l00318">README.txt:318</a></div></div>
<div class="ttc" id="aItaniumDemangle_8h_html_ae2b0d0345572d6718e219aa76d1d54eda3ea9a0394aab44aadd148cfafa5c6693"><div class="ttname"><a href="ItaniumDemangle_8h.html#ae2b0d0345572d6718e219aa76d1d54eda3ea9a0394aab44aadd148cfafa5c6693">SpecialSubKind::allocator</a></div><div class="ttdeci">@ allocator</div></div>
<div class="ttc" id="alib_2Target_2ARM_2README_8txt_html_aa1a9bc328cb94f5dc61a1fe8fc356eea"><div class="ttname"><a href="lib_2Target_2ARM_2README_8txt.html#aa1a9bc328cb94f5dc61a1fe8fc356eea">full_add</a></div><div class="ttdeci">Should compile to use and accumulates this with a bit value We currently get this with both v4 and r0 smull r2 adds r1 adc r0 bx lr bool full_add(unsigned a, unsigned b)</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2ARM_2README_8txt_source.html#l00441">README.txt:441</a></div></div>
<div class="ttc" id="alib_2Target_2README_8txt_html_a649b860033cb176a858a167c37961747"><div class="ttname"><a href="lib_2Target_2README_8txt.html#a649b860033cb176a858a167c37961747">preds</a></div><div class="ttdeci">preds</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2README_8txt_source.html#l00340">README.txt:340</a></div></div>
<div class="ttc" id="aRISCVExpandPseudoInsts_8cpp_html_aaf994d4589bcfc68408e1adccd544c48"><div class="ttname"><a href="RISCVExpandPseudoInsts_8cpp.html#aaf994d4589bcfc68408e1adccd544c48">pseudo</a></div><div class="ttdeci">riscv prera expand pseudo</div><div class="ttdef"><b>Definition:</b> <a href="RISCVExpandPseudoInsts_8cpp_source.html#l00432">RISCVExpandPseudoInsts.cpp:432</a></div></div>
<div class="ttc" id="alib_2Target_2ARM_2README_8txt_html_a38e79c83dad9b9a5f38c9693371a8709"><div class="ttname"><a href="lib_2Target_2ARM_2README_8txt.html#a38e79c83dad9b9a5f38c9693371a8709">p</a></div><div class="ttdeci">the resulting code requires compare and branches when and if * p</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2ARM_2README_8txt_source.html#l00396">README.txt:396</a></div></div>
<div class="ttc" id="alib_2Target_2X86_2README_8txt_html_af1fa630865127459286e11e4fab4319d"><div class="ttname"><a href="lib_2Target_2X86_2README_8txt.html#af1fa630865127459286e11e4fab4319d">movzwl</a></div><div class="ttdeci">The following code is currently eax eax ecx jb LBB1_2 eax movzbl eax ret eax ret We could change the eax into movzwl(%esp)</div></div>
<div class="ttc" id="anamespacellvm_1_1LegalityPredicates_html_a6fef38ab5d0c9c582fe6cae7d8badf5f"><div class="ttname"><a href="namespacellvm_1_1LegalityPredicates.html#a6fef38ab5d0c9c582fe6cae7d8badf5f">llvm::LegalityPredicates::any</a></div><div class="ttdeci">Predicate any(Predicate P0, Predicate P1)</div><div class="ttdoc">True iff P0 or P1 are true.</div><div class="ttdef"><b>Definition:</b> <a href="LegalizerInfo_8h_source.html#l00241">LegalizerInfo.h:241</a></div></div>
<div class="ttc" id="alib_2Target_2README_8txt_html_a9acc2b3eaec7baeef14227a79c6be049"><div class="ttname"><a href="lib_2Target_2README_8txt.html#a9acc2b3eaec7baeef14227a79c6be049">a4</a></div><div class="ttdeci">This is blocked on not handling X *X *X which is the same number of multiplies and is because the *X has multiple uses Here s a simple X1 B ret i32 C Reassociate should handle the example in GCC a4</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2README_8txt_source.html#l00084">README.txt:84</a></div></div>
<div class="ttc" id="aMachineSink_8cpp_html_a3b48f4c83665c4a2ece4938ffc9ffbcd"><div class="ttname"><a href="MachineSink_8cpp.html#a3b48f4c83665c4a2ece4938ffc9ffbcd">sinking</a></div><div class="ttdeci">Machine code sinking</div><div class="ttdef"><b>Definition:</b> <a href="MachineSink_8cpp_source.html#l00269">MachineSink.cpp:269</a></div></div>
<div class="ttc" id="alib_2Target_2README_8txt_html_a0cd8d1bc9a07cfa4b9ea5dd409d753de"><div class="ttname"><a href="lib_2Target_2README_8txt.html#a0cd8d1bc9a07cfa4b9ea5dd409d753de">http</a></div><div class="ttdeci">Clang compiles this i1 i64 store i64 i64 store i64 i64 store i64 i64 store i64 align Which gets codegen d xmm0 movaps rbp movaps rbp movaps rbp movaps rbp rbp rbp rbp rbp It would be better to have movq s of instead of the movaps s http</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2README_8txt_source.html#l00532">README.txt:532</a></div></div>
<div class="ttc" id="alib_2Target_2PowerPC_2README_8txt_html_a7dac26c0290a417e6a6e0ed8ea152a75"><div class="ttname"><a href="lib_2Target_2PowerPC_2README_8txt.html#a7dac26c0290a417e6a6e0ed8ea152a75">like</a></div><div class="ttdeci">Should compile to something like</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2PowerPC_2README_8txt_source.html#l00019">README.txt:19</a></div></div>
<div class="ttc" id="ainclude_2llvm_2Demangle_2README_8txt_html_abc3b21dc1440d1604a1e07d1dfa0f31e"><div class="ttname"><a href="include_2llvm_2Demangle_2README_8txt.html#abc3b21dc1440d1604a1e07d1dfa0f31e">library</a></div><div class="ttdeci">Itanium Name Demangler i e convert the string _Z1fv into and both[sub] projects need to demangle but neither can depend on each other *libcxxabi needs the demangler to implement which is part of the itanium ABI spec *LLVM needs a copy for a bunch of and cannot rely on the system s __cxa_demangle because it a might not be and b may not be up to date on the latest language features The copy of the demangler in LLVM has some extra stuff that aren t needed in which depend on the shared generic components Despite these we want to keep the core generic demangling library identical between both copies to simplify development and testing If you re working on the generic library</div><div class="ttdef"><b>Definition:</b> <a href="include_2llvm_2Demangle_2README_8txt_source.html#l00036">README.txt:36</a></div></div>
<div class="ttc" id="aItaniumDemangle_8cpp_html_a4c6b51e11b2b8829196d77f39feb3488"><div class="ttname"><a href="ItaniumDemangle_8cpp.html#a4c6b51e11b2b8829196d77f39feb3488">Demangler</a></div><div class="ttdeci">itanium_demangle::ManglingParser&lt; DefaultAllocator &gt; Demangler</div><div class="ttdef"><b>Definition:</b> <a href="ItaniumDemangle_8cpp_source.html#l00366">ItaniumDemangle.cpp:366</a></div></div>
<div class="ttc" id="alib_2Target_2X86_2README_8txt_html_ad6cbde5e41d09c19608b23a58271af1b"><div class="ttname"><a href="lib_2Target_2X86_2README_8txt.html#ad6cbde5e41d09c19608b23a58271af1b">least</a></div><div class="ttdeci">Instead of the following for memset char edx edx edx It might be better to generate eax movl edx movl edx movw edx when we can spare a register It reduces code size Evaluate what the best way to codegen sdiv C is For we currently get ret i32 Y eax movl ecx ecx ecx addl eax eax ret GCC knows several different ways to codegen one of which is eax eax ecx cmovle eax eax ret which is probably but it s interesting at least</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2X86_2README_8txt_source.html#l00166">README.txt:166</a></div></div>
<div class="ttc" id="aMD5_8cpp_html_a96d73bbd7af15cb1fc38c3f4a3bd82e9"><div class="ttname"><a href="MD5_8cpp.html#a96d73bbd7af15cb1fc38c3f4a3bd82e9">F</a></div><div class="ttdeci">#define F(x, y, z)</div><div class="ttdef"><b>Definition:</b> <a href="MD5_8cpp_source.html#l00055">MD5.cpp:55</a></div></div>
<div class="ttc" id="alib_2Analysis_2README_8txt_html_a01d2af4eee7c40485a0ce3683a2e907a"><div class="ttname"><a href="lib_2Analysis_2README_8txt.html#a01d2af4eee7c40485a0ce3683a2e907a">loop</a></div><div class="ttdeci">Analysis the ScalarEvolution expression for r is&lt; loop &gt; Outside the loop</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Analysis_2README_8txt_source.html#l00008">README.txt:8</a></div></div>
<div class="ttc" id="alib_2Target_2X86_2README_8txt_html_af0ecd96d12e0c3ae7849db242a6d9500"><div class="ttname"><a href="lib_2Target_2X86_2README_8txt.html#af0ecd96d12e0c3ae7849db242a6d9500">wrapped</a></div><div class="ttdeci">is currently compiled esp esp jne LBB1_1 esp ret esp esp jne L_abort $stub esp ret This can be applied to any no return function call that takes no arguments etc the stack save restore logic could be shrink wrapped</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2X86_2README_8txt_source.html#l00412">README.txt:412</a></div></div>
<div class="ttc" id="alib_2Target_2WebAssembly_2README_8txt_html_aa10ed15e46ac1ab65d947f018f9bad45"><div class="ttname"><a href="lib_2Target_2WebAssembly_2README_8txt.html#aa10ed15e46ac1ab65d947f018f9bad45">extended</a></div><div class="ttdeci">we should consider alternate ways to model stack dependencies Lots of things could be done in WebAssemblyTargetTransformInfo cpp there are numerous optimization related hooks that can be overridden in WebAssemblyTargetLowering Instead of the OptimizeReturned which should consider preserving the returned attribute through to MachineInstrs and extending the MemIntrinsicResults pass to do this optimization on calls too That would also let the WebAssemblyPeephole pass clean up dead defs for such as it does for stores Consider implementing and or getMachineCombinerPatterns Find a clean way to fix the problem which leads to the Shrink Wrapping pass being run after the WebAssembly PEI pass When setting multiple variables to the same we currently get code like const It could be done with a smaller encoding like local tee $pop5 local $pop6 WebAssembly registers are implicitly initialized to zero Explicit zeroing is therefore often redundant and could be optimized away Small indices may use smaller encodings than large indices WebAssemblyRegColoring and or WebAssemblyRegRenumbering should sort registers according to their usage frequency to maximize the usage of smaller encodings Many cases of irreducible control flow could be transformed more optimally than via the transform in WebAssemblyFixIrreducibleControlFlow cpp It may also be worthwhile to do transforms before register particularly when duplicating to allow register coloring to be aware of the duplication WebAssemblyRegStackify could use AliasAnalysis to reorder loads and stores more aggressively WebAssemblyRegStackify is currently a greedy algorithm This means for a binary however wasm doesn t actually require this WebAssemblyRegStackify could be extended</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2WebAssembly_2README_8txt_source.html#l00149">README.txt:149</a></div></div>
<div class="ttc" id="anamespacellvm_1_1tgtok_html_abbc5259d649363016626e2529fabe0c5af7dfdb0abdda5fcfe131bb1c1c6ccb71"><div class="ttname"><a href="namespacellvm_1_1tgtok.html#abbc5259d649363016626e2529fabe0c5af7dfdb0abdda5fcfe131bb1c1c6ccb71">llvm::tgtok::plus</a></div><div class="ttdeci">@ plus</div><div class="ttdef"><b>Definition:</b> <a href="TGLexer_8h_source.html#l00037">TGLexer.h:37</a></div></div>
<div class="ttc" id="aMustExecute_8cpp_html_a13fbdcf3bc34f504e8f2b5f2aa7d7f7c"><div class="ttname"><a href="MustExecute_8cpp.html#a13fbdcf3bc34f504e8f2b5f2aa7d7f7c">instructions</a></div><div class="ttdeci">print must be executed print the must be executed context for all instructions</div><div class="ttdef"><b>Definition:</b> <a href="MustExecute_8cpp_source.html#l00362">MustExecute.cpp:362</a></div></div>
<div class="ttc" id="aDivRemPairs_8cpp_html_acabf5cd140be0dea1a9b4ccae70ea89a"><div class="ttname"><a href="DivRemPairs_8cpp.html#acabf5cd140be0dea1a9b4ccae70ea89a">remainder</a></div><div class="ttdeci">div rem Hoist decompose integer division and remainder</div><div class="ttdef"><b>Definition:</b> <a href="DivRemPairs_8cpp_source.html#l00448">DivRemPairs.cpp:448</a></div></div>
<div class="ttc" id="alib_2Target_2X86_2README_8txt_html_a7ef4d3003047043a3de118adbb0570fd"><div class="ttname"><a href="lib_2Target_2X86_2README_8txt.html#a7ef4d3003047043a3de118adbb0570fd">a</a></div><div class="ttdeci">=0.0 ? 0.0 :(a &gt; 0.0 ? 1.0 :-1.0) a</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2X86_2README_8txt_source.html#l00489">README.txt:489</a></div></div>
<div class="ttc" id="alib_2Target_2ARM_2README_8txt_html_a16c448341c43522396de1768d14144e9"><div class="ttname"><a href="lib_2Target_2ARM_2README_8txt.html#a16c448341c43522396de1768d14144e9">r1</a></div><div class="ttdeci">__Z6slow4bii r1 movgt r1</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2ARM_2README_8txt_source.html#l00062">README.txt:62</a></div></div>
<div class="ttc" id="aREADME-FPStack_8txt_html_ac25bbfa16d28ab1f83da03668addad0a"><div class="ttname"><a href="README-FPStack_8txt.html#ac25bbfa16d28ab1f83da03668addad0a">floor</a></div><div class="ttdeci">We have fiadd patterns now but the followings have the same cost and complexity We need a way to specify the later is more profitable def def The FP stackifier should handle simple permutates to reduce number of shuffle e g floor</div><div class="ttdef"><b>Definition:</b> <a href="README-FPStack_8txt_source.html#l00054">README-FPStack.txt:54</a></div></div>
<div class="ttc" id="alib_2Target_2X86_2README_8txt_html_a51c635ed823e77c829c813f0dc2f72f9"><div class="ttname"><a href="lib_2Target_2X86_2README_8txt.html#a51c635ed823e77c829c813f0dc2f72f9">always</a></div><div class="ttdeci">bar al al movzbl eax ret Missed when stored in a memory are stored as single byte objects the value of which is always(false) or 1(true). We are not using this fact</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2X86_2README_8txt_source.html#l01412">README.txt:1412</a></div></div>
<div class="ttc" id="aPPCCTRLoopsVerify_8cpp_html_a345bd69760b9ee32b3f49d4fc04120fb"><div class="ttname"><a href="PPCCTRLoopsVerify_8cpp.html#a345bd69760b9ee32b3f49d4fc04120fb">Verify</a></div><div class="ttdeci">ppc ctr loops PowerPC CTR Loops Verify</div><div class="ttdef"><b>Definition:</b> <a href="PPCCTRLoopsVerify_8cpp_source.html#l00077">PPCCTRLoopsVerify.cpp:77</a></div></div>
<div class="ttc" id="aMSA_8txt_html_ab70729ff3a9bdbe2abf0403e90e4a02c"><div class="ttname"><a href="MSA_8txt.html#ab70729ff3a9bdbe2abf0403e90e4a02c">different</a></div><div class="ttdeci">Code Generation Notes for reduce the size of the ISel and reduce repetition in the implementation In a small number of this can cause different(semantically equivalent) instructions to be used in place of the requested instruction</div></div>
<div class="ttc" id="alib_2Target_2ARM_2README_8txt_html_a505ab8ccf28e119d535a848c546abc77"><div class="ttname"><a href="lib_2Target_2ARM_2README_8txt.html#a505ab8ccf28e119d535a848c546abc77">way</a></div><div class="ttdeci">should just be implemented with a CLZ instruction Since there are other e that share this it would be best to implement this in a target independent way</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2ARM_2README_8txt_source.html#l00720">README.txt:720</a></div></div>
<div class="ttc" id="alib_2Target_2WebAssembly_2README_8txt_html_a8366ba3ca9aeceb7073238e421eb1c55"><div class="ttname"><a href="lib_2Target_2WebAssembly_2README_8txt.html#a8366ba3ca9aeceb7073238e421eb1c55">clang</a></div><div class="ttdeci">The object format emitted by the WebAssembly backed is documented see the home and packaging for producing WebAssembly applications that can run in browsers and other environments wasi sdk provides a more minimal C C SDK based on clang</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2WebAssembly_2README_8txt_source.html#l00019">README.txt:19</a></div></div>
<div class="ttc" id="aCoroutines_8cpp_html_ac781ce96aa25ba7f6fd38f72de665450"><div class="ttname"><a href="Coroutines_8cpp.html#ac781ce96aa25ba7f6fd38f72de665450">clear</a></div><div class="ttdeci">static void clear(coro::Shape &amp;Shape)</div><div class="ttdef"><b>Definition:</b> <a href="Coroutines_8cpp_source.html#l00149">Coroutines.cpp:149</a></div></div>
<div class="ttc" id="alib_2Target_2README_8txt_html_afb797101b95721a1a42dc2edd2621376"><div class="ttname"><a href="lib_2Target_2README_8txt.html#afb797101b95721a1a42dc2edd2621376">sbbl</a></div><div class="ttdeci">Add support for conditional and other related patterns Instead eax eax je LBB16_2 eax edi sbbl</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2README_8txt_source.html#l00144">README.txt:144</a></div></div>
<div class="ttc" id="aImplicitNullChecks_8cpp_html_a9a4776a2cfc0bcc3774690aef4b43196"><div class="ttname"><a href="ImplicitNullChecks_8cpp.html#a9a4776a2cfc0bcc3774690aef4b43196">checks</a></div><div class="ttdeci">Implicit null checks</div><div class="ttdef"><b>Definition:</b> <a href="ImplicitNullChecks_8cpp_source.html#l00820">ImplicitNullChecks.cpp:820</a></div></div>
<div class="ttc" id="alib_2Target_2X86_2README_8txt_html_ae4e9214eafe54cfd3293f59f4e9e710c"><div class="ttname"><a href="lib_2Target_2X86_2README_8txt.html#ae4e9214eafe54cfd3293f59f4e9e710c">rax</a></div><div class="ttdeci">gets compiled into this on rsp movaps rsp movaps rsp movaps rsp movaps rsp movaps rsp movaps rsp movaps rsp movaps rsp movq rsp movq rsp movq rsp movq rsp movq rsp rax movq rax</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2X86_2README_8txt_source.html#l01129">README.txt:1129</a></div></div>
<div class="ttc" id="aREADME__ALTIVEC_8txt_html_a18bbedb7809894745ed8ef8b739930f1"><div class="ttname"><a href="README__ALTIVEC_8txt.html#a18bbedb7809894745ed8ef8b739930f1">here</a></div><div class="ttdeci">A predicate compare being used in a select_cc should have the same peephole applied to it as a predicate compare used by a br_cc There should be no mfcr here</div><div class="ttdef"><b>Definition:</b> <a href="README__ALTIVEC_8txt_source.html#l00147">README_ALTIVEC.txt:147</a></div></div>
<div class="ttc" id="alib_2Target_2X86_2README_8txt_html_a54ea11a98d6b831aa35770a9c46c02bc"><div class="ttname"><a href="lib_2Target_2X86_2README_8txt.html#a54ea11a98d6b831aa35770a9c46c02bc">processors</a></div><div class="ttdeci">http eax xorl edx cl sete al setne dl sall eax sall edx But that requires good bit subreg support this might be better It s an extra but it s one instruction and doesn t stress bit subreg eax eax movl edx edx sall eax sall cl edx bit we should expand to a conditional branch like GCC produces Some isel and Sequencing of Instructions Scheduling for reduced register pressure E g Minimum Register Instruction Sequence load p Because the compare isn t it is not matched with the load on both sides The dag combiner should be made smart enough to canonicalize the load into the RHS of a compare when it can invert the result of the compare for free In many LLVM generates code like eax cmpl esp setl al movzbl eax ret on some processors(which ones?)</div></div>
<div class="ttc" id="anamespacellvm_1_1sys_1_1fs_html_a142386357a8879fc0b5041dc2e275bf5"><div class="ttname"><a href="namespacellvm_1_1sys_1_1fs.html#a142386357a8879fc0b5041dc2e275bf5">llvm::sys::fs::equivalent</a></div><div class="ttdeci">bool equivalent(file_status A, file_status B)</div><div class="ttdoc">Do file_status's represent the same thing?</div></div>
<div class="ttc" id="alib_2CodeGen_2README_8txt_html_abd9dd7b33cfc6258b9e2757a8bfd7f0a"><div class="ttname"><a href="lib_2CodeGen_2README_8txt.html#abd9dd7b33cfc6258b9e2757a8bfd7f0a">reg1039</a></div><div class="ttdeci">Common register allocation spilling lr str ldr sxth r3 ldr mla r4 can lr mov lr str ldr sxth r3 mla r4 and then merge mul and lr str ldr sxth r3 mla r4 It also increase the likelihood the store may become dead bb27 reg1039</div><div class="ttdef"><b>Definition:</b> <a href="lib_2CodeGen_2README_8txt_source.html#l00036">README.txt:36</a></div></div>
<div class="ttc" id="aInductiveRangeCheckElimination_8cpp_html_a9615611bbacf6f823667984844b3c3ae"><div class="ttname"><a href="InductiveRangeCheckElimination_8cpp.html#a9615611bbacf6f823667984844b3c3ae">elimination</a></div><div class="ttdeci">Inductive range check elimination</div><div class="ttdef"><b>Definition:</b> <a href="InductiveRangeCheckElimination_8cpp_source.html#l00284">InductiveRangeCheckElimination.cpp:284</a></div></div>
<div class="ttc" id="aclassStringView_html_a7862563af6397ffdffe88f619ce93390"><div class="ttname"><a href="classStringView.html#a7862563af6397ffdffe88f619ce93390">StringView::substr</a></div><div class="ttdeci">StringView substr(size_t Pos, size_t Len=npos) const</div><div class="ttdef"><b>Definition:</b> <a href="StringView_8h_source.html#l00041">StringView.h:41</a></div></div>
<div class="ttc" id="alib_2Target_2PowerPC_2README_8txt_html_a4475be408b62271c85c7128011323f8a"><div class="ttname"><a href="lib_2Target_2PowerPC_2README_8txt.html#a4475be408b62271c85c7128011323f8a">LBB1_2</a></div><div class="ttdeci">entry stw r5 blr GCC r3 srawi xor r4 subf r0 stw r5 blr which is much nicer This theoretically may help improve twolf li blt LBB1_2</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2PowerPC_2README_8txt_source.html#l00201">README.txt:201</a></div></div>
<div class="ttc" id="aX86PartialReduction_8cpp_html_a9e1483f7215664a2315c53c3558d9a8d"><div class="ttname"><a href="X86PartialReduction_8cpp.html#a9e1483f7215664a2315c53c3558d9a8d">LHS</a></div><div class="ttdeci">Value * LHS</div><div class="ttdef"><b>Definition:</b> <a href="X86PartialReduction_8cpp_source.html#l00075">X86PartialReduction.cpp:75</a></div></div>
<div class="ttc" id="aHexagonLoopIdiomRecognition_8cpp_html_a0f0185c2b182606dd585b84e3f68f4e6"><div class="ttname"><a href="HexagonLoopIdiomRecognition_8cpp.html#a0f0185c2b182606dd585b84e3f68f4e6">idioms</a></div><div class="ttdeci">hexagon loop Recognize Hexagon specific loop idioms</div><div class="ttdef"><b>Definition:</b> <a href="HexagonLoopIdiomRecognition_8cpp_source.html#l00284">HexagonLoopIdiomRecognition.cpp:284</a></div></div>
<div class="ttc" id="alib_2CodeGen_2README_8txt_html_a2ee0af66fe0326c32ec4a34e371db61f"><div class="ttname"><a href="lib_2CodeGen_2README_8txt.html#a2ee0af66fe0326c32ec4a34e371db61f">r4</a></div><div class="ttdeci">Common register allocation spilling r4</div><div class="ttdef"><b>Definition:</b> <a href="lib_2CodeGen_2README_8txt_source.html#l00005">README.txt:5</a></div></div>
<div class="ttc" id="aMathExtras_8h_html_a9211f62d8e1e6de999eaa63ec0f6ae02"><div class="ttname"><a href="MathExtras_8h.html#a9211f62d8e1e6de999eaa63ec0f6ae02">R2</a></div><div class="ttdeci">#define R2(n)</div></div>
<div class="ttc" id="alib_2Target_2X86_2README_8txt_html_ac9423a63151469d95755528cceb322fb"><div class="ttname"><a href="lib_2Target_2X86_2README_8txt.html#ac9423a63151469d95755528cceb322fb">bb</a></div><div class="ttdeci">&lt; i1 &gt; br i1 label label bb bb</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2X86_2README_8txt_source.html#l00978">README.txt:978</a></div></div>
<div class="ttc" id="aHexagonBitSimplify_8cpp_html_a6b8ff89d1b6bc38b02fb1182b1f7291e"><div class="ttname"><a href="HexagonBitSimplify_8cpp.html#a6b8ff89d1b6bc38b02fb1182b1f7291e">simplification</a></div><div class="ttdeci">hexagon bit Hexagon bit simplification</div><div class="ttdef"><b>Definition:</b> <a href="HexagonBitSimplify_8cpp_source.html#l00290">HexagonBitSimplify.cpp:290</a></div></div>
<div class="ttc" id="alib_2Target_2README_8txt_html_a16107502a78fcaae694e2189573d5b37"><div class="ttname"><a href="lib_2Target_2README_8txt.html#a16107502a78fcaae694e2189573d5b37">i64</a></div><div class="ttdeci">Clang compiles this i64</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2README_8txt_source.html#l00504">README.txt:504</a></div></div>
<div class="ttc" id="aSeparateConstOffsetFromGEP_8cpp_html_ac56c14d91bc69a17e4e5936093b3bc05"><div class="ttname"><a href="SeparateConstOffsetFromGEP_8cpp.html#ac56c14d91bc69a17e4e5936093b3bc05">CSE</a></div><div class="ttdeci">separate const offset from Split GEPs to a variadic base and a constant offset for better CSE</div><div class="ttdef"><b>Definition:</b> <a href="SeparateConstOffsetFromGEP_8cpp_source.html#l00495">SeparateConstOffsetFromGEP.cpp:495</a></div></div>
<div class="ttc" id="alib_2Target_2PowerPC_2README_8txt_html_a6e62594a2cbf6b18a9e518f38637efa3"><div class="ttname"><a href="lib_2Target_2PowerPC_2README_8txt.html#a6e62594a2cbf6b18a9e518f38637efa3">lo16</a></div><div class="ttdeci">We lo16(.CPI_X_0)(r2) lis r2</div></div>
<div class="ttc" id="aIndVarSimplify_8cpp_html_a566d8ea0c046e39ce95437e5c8390b8f"><div class="ttname"><a href="IndVarSimplify_8cpp.html#a566d8ea0c046e39ce95437e5c8390b8f">indvars</a></div><div class="ttdeci">indvars</div><div class="ttdef"><b>Definition:</b> <a href="IndVarSimplify_8cpp_source.html#l02271">IndVarSimplify.cpp:2271</a></div></div>
<div class="ttc" id="aREADME-FPStack_8txt_html_a18f5ebac457be2d6e279cdd3842a4024"><div class="ttname"><a href="README-FPStack_8txt.html#a18f5ebac457be2d6e279cdd3842a4024">turning</a></div><div class="ttdeci">We have fiadd patterns now but the followings have the same cost and complexity We need a way to specify the later is more profitable def def The FP stackifier should handle simple permutates to reduce number of shuffle e g turning</div><div class="ttdef"><b>Definition:</b> <a href="README-FPStack_8txt_source.html#l00054">README-FPStack.txt:54</a></div></div>
<div class="ttc" id="alib_2Target_2ARM_2README_8txt_html_a80845dd3c9a43a32e4f70ec5a88ce96c"><div class="ttname"><a href="lib_2Target_2ARM_2README_8txt.html#a80845dd3c9a43a32e4f70ec5a88ce96c">no_overflow</a></div><div class="ttdeci">bool no_overflow(unsigned a, unsigned b)</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2ARM_2README_8txt_source.html#l00443">README.txt:443</a></div></div>
<div class="ttc" id="aREADME-SSE_8txt_html_a9fb6cbbc77fb02ab3a51b0660bd09909"><div class="ttname"><a href="README-SSE_8txt.html#a9fb6cbbc77fb02ab3a51b0660bd09909">select</a></div><div class="ttdeci">into xmm2 addss xmm2 xmm1 xmm3 addss xmm3 movaps xmm0 unpcklps xmm0 ret seems silly when it could just be one addps Expand libm rounding functions main should enable SSE DAZ mode and other fast SSE modes Think about doing i64 math in SSE regs on x86 This testcase should have no SSE instructions in and only one load from a constant double ret double C the select is being which prevents the dag combiner from turning select(load CPI1)</div></div>
<div class="ttc" id="alib_2Target_2X86_2README_8txt_html_a453c93d61fb340b0c4cba053d29ad728"><div class="ttname"><a href="lib_2Target_2X86_2README_8txt.html#a453c93d61fb340b0c4cba053d29ad728">movw</a></div><div class="ttdeci">Instead of the following for memset char edx edx movw</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2X86_2README_8txt_source.html#l00121">README.txt:121</a></div></div>
<div class="ttc" id="alib_2Target_2PowerPC_2README_8txt_html_abf71691117ab2cafab3198a30d3f746c"><div class="ttname"><a href="lib_2Target_2PowerPC_2README_8txt.html#abf71691117ab2cafab3198a30d3f746c">LCPI1_0</a></div><div class="ttdeci">cond_true lis lo16() LCPI1_0(r2) lis r2</div></div>
<div class="ttc" id="alib_2Target_2Sparc_2README_8txt_html_a83d1a355368d98db17d7e896b09ea62b"><div class="ttname"><a href="lib_2Target_2Sparc_2README_8txt.html#a83d1a355368d98db17d7e896b09ea62b">l0</a></div><div class="ttdeci">To do *Keep the address of the constant pool in a register instead of forming its address all of the time *We can fold small constant offsets into the hi lo references to constant pool addresses as well *When in V9 register allocate icc *[0-3] Add support for isel ing UMUL_LOHI instead of marking it as Expand *Emit the Branch on Integer Register with Prediction instructions It s not clear how to write a pattern for this int o6 subcc l0 bne LBBt1_2 ! F nop l0 st l0</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2Sparc_2README_8txt_source.html#l00031">README.txt:31</a></div></div>
<div class="ttc" id="alib_2Target_2ARM_2README_8txt_html_adefbb946b174533d5eb8db503b1f4ffa"><div class="ttname"><a href="lib_2Target_2ARM_2README_8txt.html#adefbb946b174533d5eb8db503b1f4ffa">L2</a></div><div class="ttdeci">add sub stmia L5 ldr L2</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2ARM_2README_8txt_source.html#l00201">README.txt:201</a></div></div>
<div class="ttc" id="anamespacellvm_1_1ISD_html_a22ea9cec080dd5f4f47ba234c2f59110a78d0f198115bfe3331ab7cfcf7a40a97"><div class="ttname"><a href="namespacellvm_1_1ISD.html#a22ea9cec080dd5f4f47ba234c2f59110a78d0f198115bfe3331ab7cfcf7a40a97">llvm::ISD::SELECT</a></div><div class="ttdeci">@ SELECT</div><div class="ttdoc">Select(COND, TRUEVAL, FALSEVAL).</div><div class="ttdef"><b>Definition:</b> <a href="ISDOpcodes_8h_source.html#l00713">ISDOpcodes.h:713</a></div></div>
<div class="ttc" id="anamespacellvm_1_1PatternMatch_html_a25d956d9e0beadd47ce4bc255dfa811d"><div class="ttname"><a href="namespacellvm_1_1PatternMatch.html#a25d956d9e0beadd47ce4bc255dfa811d">llvm::PatternMatch::match</a></div><div class="ttdeci">bool match(Val *V, const Pattern &amp;P)</div><div class="ttdef"><b>Definition:</b> <a href="PatternMatch_8h_source.html#l00049">PatternMatch.h:49</a></div></div>
<div class="ttc" id="alib_2Target_2README_8txt_html_afe8cc12d0d0c28bd5b1c8aedbc4e0040"><div class="ttname"><a href="lib_2Target_2README_8txt.html#afe8cc12d0d0c28bd5b1c8aedbc4e0040">available</a></div><div class="ttdeci">This requires reassociating to forms of expressions that are already available</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2README_8txt_source.html#l00092">README.txt:92</a></div></div>
<div class="ttc" id="alib_2Target_2X86_2README_8txt_html_a757949b674680f197bec1b39c73be480"><div class="ttname"><a href="lib_2Target_2X86_2README_8txt.html#a757949b674680f197bec1b39c73be480">rsi</a></div><div class="ttdeci">gets compiled into this on rsp movaps rsp movaps rsp movaps rsp movaps rsp movaps rsp movaps rsp movaps rsp movaps rsp movq rsp movq rsp movq rsp movq rsp movq rsi</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2X86_2README_8txt_source.html#l01127">README.txt:1127</a></div></div>
<div class="ttc" id="alib_2Target_2ARM_2README_8txt_html_abbb81dd83f010e6d9afcbfb124c22da1"><div class="ttname"><a href="lib_2Target_2ARM_2README_8txt.html#abbb81dd83f010e6d9afcbfb124c22da1">s2</a></div><div class="ttdeci">_bar mov r0 mov r1 fldd LCPI1_0 fmrrd d0 bl _foo fmdrr r5 fmsr s2</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2ARM_2README_8txt_source.html#l00159">README.txt:159</a></div></div>
<div class="ttc" id="alib_2Target_2X86_2README_8txt_html_af91797dc0ab1ae005fdbf19482859eaf"><div class="ttname"><a href="lib_2Target_2X86_2README_8txt.html#af91797dc0ab1ae005fdbf19482859eaf">shl</a></div><div class="ttdeci">We currently generate a but we really shouldn eax ecx xorl edx divl ecx eax divl ecx movl eax ret A similar code sequence works for division We currently compile i32 v2 eax eax jo LBB1_2 shl</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2X86_2README_8txt_source.html#l01271">README.txt:1271</a></div></div>
<div class="ttc" id="alib_2CodeGen_2README_8txt_html_a13f0a2e1f455ac47147b41701e609e17"><div class="ttname"><a href="lib_2CodeGen_2README_8txt.html#a13f0a2e1f455ac47147b41701e609e17">them</a></div><div class="ttdeci">Common register allocation spilling lr str ldr sxth r3 ldr mla r4 can lr mov lr str ldr sxth r3 mla r4 and then merge mul and lr str ldr sxth r3 mla r4 It also increase the likelihood the store may become dead bb27 Successors according to LLVM ID Predecessors according to mbb&lt; bb27, 0x8b0a7c0 &gt; Note ADDri is not a two address instruction its result reg1037 is an operand of the PHI node in bb76 and its operand reg1039 is the result of the PHI node We should treat it as a two address code and make sure the ADDri is scheduled after any node that reads reg1039 Use info(i.e. register scavenger) to assign it a free register to allow reuse the collector could move the objects and invalidate the derived pointer This is bad enough in the first but safe points can crop up unpredictably **array_addr i32 n y store obj obj **nth_el If the i64 division is lowered to a then a safe point array and nth_el no longer point into the correct object The fix for this is to copy address calculations so that dependent pointers are never live across safe point boundaries But the loads cannot be copied like this if there was an intervening so may be hard to get right Only a concurrent mutator can trigger a collection at the libcall safe point So single threaded programs do not have this even with a copying collector LLVM optimizations would probably undo a front end s careful work The ocaml frametable structure supports liveness information It would be good to support it The FIXME in ComputeCommonTailLength in BranchFolding cpp needs to be revisited The check is there to work around a misuse of directives in assembly It would be good to detect collector target compatibility instead of silently doing the wrong thing It would be really nice to be able to write patterns in td files for which would eliminate a bunch of predicates on them(e.g. no side effects). Once this is in place</div></div>
<div class="ttc" id="ainclude_2llvm_2Demangle_2README_8txt_html_a9d56f6c541a0ab888755f9bc198b8eca"><div class="ttname"><a href="include_2llvm_2Demangle_2README_8txt.html#a9d56f6c541a0ab888755f9bc198b8eca">f</a></div><div class="ttdeci">Itanium Name Demangler i e convert the string _Z1fv into f()&quot;. You can also use the CRTP base ManglingParser to perform some simple analysis on the mangled name</div></div>
<div class="ttc" id="aBuiltinGCs_8cpp_html_a6742d2e0a668baf1196ec69e158d5f15"><div class="ttname"><a href="BuiltinGCs_8cpp.html#a6742d2e0a668baf1196ec69e158d5f15">E</a></div><div class="ttdeci">static GCRegistry::Add&lt; CoreCLRGC &gt; E(&quot;coreclr&quot;, &quot;CoreCLR-compatible GC&quot;)</div></div>
<div class="ttc" id="alib_2Target_2X86_2README_8txt_html_a53514c72c73a4abdd523352784bcf2ef"><div class="ttname"><a href="lib_2Target_2X86_2README_8txt.html#a53514c72c73a4abdd523352784bcf2ef">mulss</a></div><div class="ttdeci">esp eax movl ecx ecx cvtsi2ss xmm0 eax cvtsi2ss xmm1 mulss</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2X86_2README_8txt_source.html#l00304">README.txt:304</a></div></div>
<div class="ttc" id="alib_2Target_2X86_2README_8txt_html_aeeccfe9374681010ca306d54a209eac8"><div class="ttname"><a href="lib_2Target_2X86_2README_8txt.html#aeeccfe9374681010ca306d54a209eac8">edx</a></div><div class="ttdeci">sar eax, 31) more aggressively edx</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2X86_2README_8txt_source.html#l00923">README.txt:923</a></div></div>
<div class="ttc" id="aclassStringView_html_a6c08589e09d7bb55cf1c1c8674ddb473"><div class="ttname"><a href="classStringView.html#a6c08589e09d7bb55cf1c1c8674ddb473">StringView::consumeFront</a></div><div class="ttdeci">bool consumeFront(char C)</div><div class="ttdef"><b>Definition:</b> <a href="StringView_8h_source.html#l00085">StringView.h:85</a></div></div>
<div class="ttc" id="aREADME__ALTIVEC_8txt_html_a9aacd9146afe44bf656cd664e2a88c8c"><div class="ttname"><a href="README__ALTIVEC_8txt.html#a9aacd9146afe44bf656cd664e2a88c8c">C</a></div><div class="ttdeci">(vector float) vec_cmpeq(*A, *B) C</div><div class="ttdef"><b>Definition:</b> <a href="README__ALTIVEC_8txt_source.html#l00086">README_ALTIVEC.txt:86</a></div></div>
<div class="ttc" id="alib_2Target_2X86_2README_8txt_html_ad5da9a19280b84509a8d1cac2290a0ad"><div class="ttname"><a href="lib_2Target_2X86_2README_8txt.html#ad5da9a19280b84509a8d1cac2290a0ad">cmp</a></div><div class="ttdeci">&lt; i32 &gt;&lt; i32 &gt; cmp</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2X86_2README_8txt_source.html#l01447">README.txt:1447</a></div></div>
<div class="ttc" id="alib_2Target_2README_8txt_html_aef6a892009839879b1324728c5588941"><div class="ttname"><a href="lib_2Target_2README_8txt.html#aef6a892009839879b1324728c5588941">LBB1_1</a></div><div class="ttdeci">we compile this esp call L1 $pb L1 esp je LBB1_2 LBB1_1</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2README_8txt_source.html#l00414">README.txt:414</a></div></div>
<div class="ttc" id="axxhash_8cpp_html_ae4e947c75dafebd71b8de03cd0dbf5d6"><div class="ttname"><a href="xxhash_8cpp.html#ae4e947c75dafebd71b8de03cd0dbf5d6">round</a></div><div class="ttdeci">static uint64_t round(uint64_t Acc, uint64_t Input)</div><div class="ttdef"><b>Definition:</b> <a href="xxhash_8cpp_source.html#l00056">xxhash.cpp:56</a></div></div>
<div class="ttc" id="alib_2Target_2README_8txt_html_a3217063f680fa8e35dea3c59b6e52b18"><div class="ttname"><a href="lib_2Target_2README_8txt.html#a3217063f680fa8e35dea3c59b6e52b18">int</a></div><div class="ttdeci">Clang compiles this i1 i64 store i64 i64 store i64 i64 store i64 i64 store i64 align Which gets codegen d xmm0 movaps rbp movaps rbp movaps rbp movaps rbp rbp rbp rbp rbp It would be better to have movq s of instead of the movaps s LLVM produces ret int</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2README_8txt_source.html#l00536">README.txt:536</a></div></div>
<div class="ttc" id="alib_2CodeGen_2README_8txt_html_a3084b133295965e6e12cfde3ba5bb173"><div class="ttname"><a href="lib_2CodeGen_2README_8txt.html#a3084b133295965e6e12cfde3ba5bb173">old</a></div><div class="ttdeci">Common register allocation spilling lr str ldr sxth r3 ldr mla r4 can lr mov lr str ldr sxth r3 mla r4 and then merge mul and lr str ldr sxth r3 mla r4 It also increase the likelihood the store may become dead bb27 Successors according to LLVM ID Predecessors according to mbb&lt; bb27, 0x8b0a7c0 &gt; Note ADDri is not a two address instruction its result reg1037 is an operand of the PHI node in bb76 and its operand reg1039 is the result of the PHI node We should treat it as a two address code and make sure the ADDri is scheduled after any node that reads reg1039 Use info(i.e. register scavenger) to assign it a free register to allow reuse the collector could move the objects and invalidate the derived pointer This is bad enough in the first but safe points can crop up unpredictably **array_addr i32 n old</div><div class="ttdef"><b>Definition:</b> <a href="lib_2CodeGen_2README_8txt_source.html#l00123">README.txt:123</a></div></div>
<div class="ttc" id="aOcamlGCPrinter_8cpp_html_afcf2f797ed287a723263583c9b1c1bce"><div class="ttname"><a href="OcamlGCPrinter_8cpp.html#afcf2f797ed287a723263583c9b1c1bce">Y</a></div><div class="ttdeci">static GCMetadataPrinterRegistry::Add&lt; OcamlGCMetadataPrinter &gt; Y(&quot;ocaml&quot;, &quot;ocaml 3.10-compatible collector&quot;)</div></div>
<div class="ttc" id="alib_2Target_2X86_2README_8txt_html_aeed62993acfd8432754e369188764cdf"><div class="ttname"><a href="lib_2Target_2X86_2README_8txt.html#aeed62993acfd8432754e369188764cdf">tmp614615</a></div><div class="ttdeci">&lt; i32 &gt; tmp614615</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2X86_2README_8txt_source.html#l00563">README.txt:563</a></div></div>
<div class="ttc" id="aDXILTranslateMetadata_8cpp_html_abd738f0052b7243a148afd74274996b7"><div class="ttname"><a href="DXILTranslateMetadata_8cpp.html#abd738f0052b7243a148afd74274996b7">Emit</a></div><div class="ttdeci">dxil metadata DXIL Metadata Emit</div><div class="ttdef"><b>Definition:</b> <a href="DXILTranslateMetadata_8cpp_source.html#l00074">DXILTranslateMetadata.cpp:74</a></div></div>
<div class="ttc" id="aDwarfEHPrepare_8cpp_html_a094aa3551c201aaad8067b009ad3b7a7"><div class="ttname"><a href="DwarfEHPrepare_8cpp.html#a094aa3551c201aaad8067b009ad3b7a7">exceptions</a></div><div class="ttdeci">Prepare DWARF exceptions</div><div class="ttdef"><b>Definition:</b> <a href="DwarfEHPrepare_8cpp_source.html#l00376">DwarfEHPrepare.cpp:376</a></div></div>
<div class="ttc" id="alib_2Target_2X86_2README_8txt_html_a8c5ceb5d61c4f106955d6fc557ccd715"><div class="ttname"><a href="lib_2Target_2X86_2README_8txt.html#a8c5ceb5d61c4f106955d6fc557ccd715">shorter</a></div><div class="ttdeci">http eax xorl edx cl sete al setne dl sall eax sall edx But that requires good bit subreg support this might be better It s an extra but it s one instruction shorter</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2X86_2README_8txt_source.html#l00031">README.txt:31</a></div></div>
<div class="ttc" id="alib_2Target_2X86_2README_8txt_html_a8b16b981dd241099aa211d44ea553cfa"><div class="ttname"><a href="lib_2Target_2X86_2README_8txt.html#a8b16b981dd241099aa211d44ea553cfa">tmp585</a></div><div class="ttdeci">&lt; i32 &gt; tmp585</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2X86_2README_8txt_source.html#l00562">README.txt:562</a></div></div>
<div class="ttc" id="aREADME-SSE_8txt_html_a50fd53d9a3e55ae78555e11827355565"><div class="ttname"><a href="README-SSE_8txt.html#a50fd53d9a3e55ae78555e11827355565">t</a></div><div class="ttdeci">bitcast float %x to i32 %s=and i32 %t, 2147483647 %d=bitcast i32 %s to float ret float %d } declare float @fabsf(float %n) define float @bar(float %x) nounwind { %d=call float @fabsf(float %x) ret float %d } This IR(from PR6194):target datalayout=&quot;e-p:64:64:64-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64-f32:32:32-f64:64:64-v64:64:64-v128:128:128-a0:0:64-s0:64:64-f80:128:128-n8:16:32:64-S128&quot; target triple=&quot;x86_64-apple-darwin10.0.0&quot; %0=type { double, double } %struct.float3=type { float, float, float } define void @test(%0, %struct.float3 *nocapture %res) nounwind noinline ssp { entry:%tmp18=extractvalue %0 %0, 0 t</div><div class="ttdef"><b>Definition:</b> <a href="README-SSE_8txt_source.html#l00788">README-SSE.txt:788</a></div></div>
<div class="ttc" id="alib_2Target_2ARM_2README_8txt_html_acdf5bf3bbc10f9331f56441a4d483bb1"><div class="ttname"><a href="lib_2Target_2ARM_2README_8txt.html#acdf5bf3bbc10f9331f56441a4d483bb1">b</a></div><div class="ttdeci">the resulting code requires compare and branches when and if the revised code is with conditional branches instead of More there is a byte word extend before each where there should be only and the condition codes are not remembered when the same two values are compared twice More LSR enhancements i8 and i32 load store addressing modes are identical int b</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2ARM_2README_8txt_source.html#l00418">README.txt:418</a></div></div>
<div class="ttc" id="aBlockFrequencyInfo_8cpp_html_a882e33145fd2a17174b47d3f964a6b2d"><div class="ttname"><a href="BlockFrequencyInfo_8cpp.html#a882e33145fd2a17174b47d3f964a6b2d">Analysis</a></div><div class="ttdeci">block Block Frequency Analysis</div><div class="ttdef"><b>Definition:</b> <a href="BlockFrequencyInfo_8cpp_source.html#l00301">BlockFrequencyInfo.cpp:301</a></div></div>
<div class="ttc" id="anamespacellvm_1_1ISD_html_a22ea9cec080dd5f4f47ba234c2f59110ae690127648393001a7d5b93dc23da7b3"><div class="ttname"><a href="namespacellvm_1_1ISD.html#a22ea9cec080dd5f4f47ba234c2f59110ae690127648393001a7d5b93dc23da7b3">llvm::ISD::TRUNCATE</a></div><div class="ttdeci">@ TRUNCATE</div><div class="ttdoc">TRUNCATE - Completely drop the high bits.</div><div class="ttdef"><b>Definition:</b> <a href="ISDOpcodes_8h_source.html#l00769">ISDOpcodes.h:769</a></div></div>
<div class="ttc" id="alib_2Target_2README_8txt_html_a6ed1f35286c95ab6ea121464f3223c95"><div class="ttname"><a href="lib_2Target_2README_8txt.html#a6ed1f35286c95ab6ea121464f3223c95">C</a></div><div class="ttdeci">This is blocked on not handling X *X *X which is the same number of multiplies and is because the *X has multiple uses Here s a simple X1 * C</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2README_8txt_source.html#l00075">README.txt:75</a></div></div>
<div class="ttc" id="anamespacellvm_1_1AMDGPU_1_1PALMD_html_af892c75285b0f64d58ca76cb73059adf"><div class="ttname"><a href="namespacellvm_1_1AMDGPU_1_1PALMD.html#af892c75285b0f64d58ca76cb73059adf">llvm::AMDGPU::PALMD::Key</a></div><div class="ttdeci">Key</div><div class="ttdoc">PAL metadata keys.</div><div class="ttdef"><b>Definition:</b> <a href="AMDGPUMetadata_8h_source.html#l00486">AMDGPUMetadata.h:486</a></div></div>
<div class="ttc" id="alib_2Target_2ARM_2README_8txt_html_a4ecce0cbecc7f36338ed1a74dd5bee49"><div class="ttname"><a href="lib_2Target_2ARM_2README_8txt.html#a4ecce0cbecc7f36338ed1a74dd5bee49">acc</a></div><div class="ttdeci">acc</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2ARM_2README_8txt_source.html#l00420">README.txt:420</a></div></div>
<div class="ttc" id="alib_2Target_2PowerPC_2README_8txt_html_a7d64dacb468c798c45c8efd8c01e513c"><div class="ttname"><a href="lib_2Target_2PowerPC_2README_8txt.html#a7d64dacb468c798c45c8efd8c01e513c">group</a></div><div class="ttdeci">bb420 i The CBE manages to mtctr r0 r11 stbx r9 addi bdz later b loop This could be much the loop would be a single dispatch group</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2PowerPC_2README_8txt_source.html#l00061">README.txt:61</a></div></div>
<div class="ttc" id="aGenericCycleImpl_8h_html_a9b7ee5bbb263671ca310a70e0d1526e9"><div class="ttname"><a href="GenericCycleImpl_8h.html#a9b7ee5bbb263671ca310a70e0d1526e9">check</a></div><div class="ttdeci">#define check(cond)</div></div>
<div class="ttc" id="alib_2Target_2README_8txt_html_a3c28410fcd8d82bd0f4e07f76987f680"><div class="ttname"><a href="lib_2Target_2README_8txt.html#a3c28410fcd8d82bd0f4e07f76987f680">test</a></div><div class="ttdeci">int test(U32 *inst, U64 *regs)</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2README_8txt_source.html#l00301">README.txt:301</a></div></div>
<div class="ttc" id="alib_2Target_2X86_2README_8txt_html_a7e8b7c0a6b2285d76bb6f04ceb12e246"><div class="ttname"><a href="lib_2Target_2X86_2README_8txt.html#a7e8b7c0a6b2285d76bb6f04ceb12e246">bar</a></div><div class="ttdeci">bar al al movzbl eax ret GCC produces bar</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2X86_2README_8txt_source.html#l01434">README.txt:1434</a></div></div>
<div class="ttc" id="alib_2Target_2X86_2README_8txt_html_aa83c72f88ef534194b17d361cec24bd6"><div class="ttname"><a href="lib_2Target_2X86_2README_8txt.html#aa83c72f88ef534194b17d361cec24bd6">leal</a></div><div class="ttdeci">Instead of the following for memset char edx edx edx It might be better to generate eax movl edx movl edx movw edx when we can spare a register It reduces code size Evaluate what the best way to codegen sdiv C is For we currently get ret i32 Y eax movl ecx ecx ecx addl eax eax ret GCC knows several different ways to codegen one of which is eax eax leal(%eax)</div></div>
<div class="ttc" id="aLoopDeletion_8cpp_html_a66a2592ace8a67bc796c72710d632bab"><div class="ttname"><a href="LoopDeletion_8cpp.html#a66a2592ace8a67bc796c72710d632bab">merge</a></div><div class="ttdeci">static LoopDeletionResult merge(LoopDeletionResult A, LoopDeletionResult B)</div><div class="ttdef"><b>Definition:</b> <a href="LoopDeletion_8cpp_source.html#l00053">LoopDeletion.cpp:53</a></div></div>
<div class="ttc" id="alib_2Target_2README_8txt_html_ab24db72f7bd10b13351812874015861b"><div class="ttname"><a href="lib_2Target_2README_8txt.html#ab24db72f7bd10b13351812874015861b">First</a></div><div class="ttdeci">into llvm powi allowing the code generator to produce balanced multiplication trees First</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2README_8txt_source.html#l00054">README.txt:54</a></div></div>
<div class="ttc" id="alib_2Target_2ARM_2README_8txt_html_ab8dcaf4852e5cdda5c08de364d6940b6"><div class="ttname"><a href="lib_2Target_2ARM_2README_8txt.html#ab8dcaf4852e5cdda5c08de364d6940b6">SDNodes</a></div><div class="ttdeci">Should compile r2 movcc movcs str strb mov lr r1 movcs movcc mov lr r1 str mov mov cmp r1 movlo r2 str bx lr r0 mov mov cmp r0 movhs r2 mov r1 bx lr Some of the NEON intrinsics may be appropriate for more general either as target independent intrinsics or perhaps elsewhere in the ARM backend Some of them may also be lowered to target independent SDNodes</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2ARM_2README_8txt_source.html#l00486">README.txt:486</a></div></div>
<div class="ttc" id="aARMLoadStoreOptimizer_8cpp_html_ab3bfc7321acfbc3619170d5bed907cb3"><div class="ttname"><a href="ARMLoadStoreOptimizer_8cpp.html#ab3bfc7321acfbc3619170d5bed907cb3">opt</a></div><div class="ttdeci">arm prera ldst opt</div><div class="ttdef"><b>Definition:</b> <a href="ARMLoadStoreOptimizer_8cpp_source.html#l02191">ARMLoadStoreOptimizer.cpp:2191</a></div></div>
<div class="ttc" id="aclassStringView_html_a7b7e9d4488195df865a0dae09338702e"><div class="ttname"><a href="classStringView.html#a7b7e9d4488195df865a0dae09338702e">StringView::npos</a></div><div class="ttdeci">static const size_t npos</div><div class="ttdef"><b>Definition:</b> <a href="StringView_8h_source.html#l00030">StringView.h:30</a></div></div>
<div class="ttc" id="alib_2Target_2PowerPC_2README_8txt_html_a1b0d084db70d0d0f40c511e9c462d0c7"><div class="ttname"><a href="lib_2Target_2PowerPC_2README_8txt.html#a1b0d084db70d0d0f40c511e9c462d0c7">LBB2_2</a></div><div class="ttdeci">So that lo16() r2 stb r3 blr Becomes r3 they should compile to something better r3 subfic cmpwi bgt LBB2_2</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2PowerPC_2README_8txt_source.html#l00164">README.txt:164</a></div></div>
<div class="ttc" id="aAMDGPUAnnotateUniformValues_8cpp_html_a3cd36c33be3dfbc64aa6da755a47e6b1"><div class="ttname"><a href="AMDGPUAnnotateUniformValues_8cpp.html#a3cd36c33be3dfbc64aa6da755a47e6b1">metadata</a></div><div class="ttdeci">Add AMDGPU uniform metadata</div><div class="ttdef"><b>Definition:</b> <a href="AMDGPUAnnotateUniformValues_8cpp_source.html#l00076">AMDGPUAnnotateUniformValues.cpp:76</a></div></div>
<div class="ttc" id="aDXILTranslateMetadata_8cpp_html_a495f2f072f4be26544a46193a96bd97b"><div class="ttname"><a href="DXILTranslateMetadata_8cpp.html#a495f2f072f4be26544a46193a96bd97b">emit</a></div><div class="ttdeci">dxil metadata emit</div><div class="ttdef"><b>Definition:</b> <a href="DXILTranslateMetadata_8cpp_source.html#l00073">DXILTranslateMetadata.cpp:73</a></div></div>
<div class="ttc" id="alib_2Target_2X86_2README_8txt_html_a53ef6baa17a51ad508b57678806d5ef6"><div class="ttname"><a href="lib_2Target_2X86_2README_8txt.html#a53ef6baa17a51ad508b57678806d5ef6">testb</a></div><div class="ttdeci">http eax xorl edx testb</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2X86_2README_8txt_source.html#l00022">README.txt:22</a></div></div>
<div class="ttc" id="alib_2Target_2WebAssembly_2README_8txt_html_ad0f7d198414c3f3cf72769a0f58e5914"><div class="ttname"><a href="lib_2Target_2WebAssembly_2README_8txt.html#ad0f7d198414c3f3cf72769a0f58e5914">in</a></div><div class="ttdeci">The object format emitted by the WebAssembly backed is documented in</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2WebAssembly_2README_8txt_source.html#l00011">README.txt:11</a></div></div>
<div class="ttc" id="alib_2Analysis_2README_8txt_html_a99b988477f9c08d280bc9c90c3a68eb0"><div class="ttname"><a href="lib_2Analysis_2README_8txt.html#a99b988477f9c08d280bc9c90c3a68eb0">ll</a></div><div class="ttdeci">Analysis the ScalarEvolution expression for r is&lt; loop &gt; Outside the this could be evaluated simply however ScalarEvolution currently evaluates it it involves i65 which is very inefficient when expanded into code In formatValue in test CodeGen X86 lsr delayed fold ll</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Analysis_2README_8txt_source.html#l00020">README.txt:20</a></div></div>
<div class="ttc" id="anamespacellvm_1_1AArch64__AM_html_a7e75394a33f6a5897d7a14c0ba5d44f1a7e1384a3b7d612a03b54d9c8f2071a04"><div class="ttname"><a href="namespacellvm_1_1AArch64__AM.html#a7e75394a33f6a5897d7a14c0ba5d44f1a7e1384a3b7d612a03b54d9c8f2071a04">llvm::AArch64_AM::LSR</a></div><div class="ttdeci">@ LSR</div><div class="ttdef"><b>Definition:</b> <a href="AArch64AddressingModes_8h_source.html#l00036">AArch64AddressingModes.h:36</a></div></div>
<div class="ttc" id="aDivRemPairs_8cpp_html_acc133ed83700bf3b14757629b84df429"><div class="ttname"><a href="DivRemPairs_8cpp.html#acc133ed83700bf3b14757629b84df429">pairs</a></div><div class="ttdeci">div rem pairs</div><div class="ttdef"><b>Definition:</b> <a href="DivRemPairs_8cpp_source.html#l00447">DivRemPairs.cpp:447</a></div></div>
<div class="ttc" id="alib_2CodeGen_2README_8txt_html_aa0629dbc89f0868f62da8cbcb681b2be"><div class="ttname"><a href="lib_2CodeGen_2README_8txt.html#aa0629dbc89f0868f62da8cbcb681b2be">be</a></div><div class="ttdeci">Common register allocation spilling lr str ldr sxth r3 ldr mla r4 can be</div><div class="ttdef"><b>Definition:</b> <a href="lib_2CodeGen_2README_8txt_source.html#l00014">README.txt:14</a></div></div>
<div class="ttc" id="aclassStringView_html_a7319efa03001871969255b9b7760136a"><div class="ttname"><a href="classStringView.html#a7319efa03001871969255b9b7760136a">StringView::popFront</a></div><div class="ttdeci">char popFront()</div><div class="ttdef"><b>Definition:</b> <a href="StringView_8h_source.html#l00080">StringView.h:80</a></div></div>
<div class="ttc" id="alib_2XRay_2CMakeLists_8txt_html_aafdfebe14a06b834fe5fb0d10309d43c"><div class="ttname"><a href="lib_2XRay_2CMakeLists_8txt.html#aafdfebe14a06b834fe5fb0d10309d43c">include</a></div><div class="ttdeci">include(LLVM-Build) add_subdirectory(IR) add_subdirectory(FuzzMutate) add_subdirectory(FileCheck) add_subdirectory(InterfaceStub) add_subdirectory(IRPrinter) add_subdirectory(IRReader) add_subdirectory(CodeGen) add_subdirectory(BinaryFormat) add_subdirectory(Bitcode) add_subdirectory(Bitstream) add_subdirectory(DWARFLinker) add_subdirectory(DWARFLinkerParallel) add_subdirectory(Extensions) add_subdirectory(Frontend) add_subdirectory(Transforms) add_subdirectory(Linker) add_subdirectory(Analysis) add_subdirectory(LTO) add_subdirectory(MC) add_subdirectory(MCA) add_subdirectory(ObjCopy) add_subdirectory(Object) add_subdirectory(ObjectYAML) add_subdirectory(Option) add_subdirectory(Remarks) add_subdirectory(Debuginfod) add_subdirectory(DebugInfo) add_subdirectory(DWP) add_subdirectory(ExecutionEngine) add_subdirectory(Target) add_subdirectory(AsmParser) add_subdirectory(LineEditor) add_subdirectory(ProfileData) add_subdirectory(Passes) add_subdirectory(TargetParser) add_subdirectory(TextAPI) add_subdirectory(ToolDrivers) add_subdirectory(XRay) if(LLVM_INCLUDE_TESTS) add_subdirectory(Testing) endif() add_subdirectory(WindowsDriver) add_subdirectory(WindowsManifest) set(LLVMCONFIGLIBRARYDEPENDENCIESINC &quot;$</div><div class="ttdef"><b>Definition:</b> <a href="lib_2XRay_2CMakeLists_8txt_source.html#l00001">CMakeLists.txt:1</a></div></div>
<div class="ttc" id="alib_2Target_2Sparc_2README_8txt_html_a70a3fcaf61f8747c8c16ea386619cf64"><div class="ttname"><a href="lib_2Target_2Sparc_2README_8txt.html#a70a3fcaf61f8747c8c16ea386619cf64">above</a></div><div class="ttdeci">To do *Keep the address of the constant pool in a register instead of forming its address all of the time *We can fold small constant offsets into the hi lo references to constant pool addresses as well *When in V9 register allocate icc *[0-3] Add support for isel ing UMUL_LOHI instead of marking it as Expand *Emit the Branch on Integer Register with Prediction instructions It s not clear how to write a pattern for this int o6 subcc l0 bne LBBt1_2 ! F nop l0 st g0 retl nop should be replaced with a brz in V9 mode *Same as above</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2Sparc_2README_8txt_source.html#l00040">README.txt:40</a></div></div>
<div class="ttc" id="alib_2Target_2PowerPC_2README_8txt_html_ae827eebc380642a86ac7755e5ca7cc75"><div class="ttname"><a href="lib_2Target_2PowerPC_2README_8txt.html#ae827eebc380642a86ac7755e5ca7cc75">r8</a></div><div class="ttdeci">bb420 i lbzx r8</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2PowerPC_2README_8txt_source.html#l00039">README.txt:39</a></div></div>
<div class="ttc" id="alib_2Target_2ARM_2README_8txt_html_a940be94e0429ba61bec9f68aa6e65625"><div class="ttname"><a href="lib_2Target_2ARM_2README_8txt.html#a940be94e0429ba61bec9f68aa6e65625">r0</a></div><div class="ttdeci">__Z6slow4bii r1 movgt r0 mov r0</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2ARM_2README_8txt_source.html#l00063">README.txt:63</a></div></div>
<div class="ttc" id="alib_2Target_2X86_2README_8txt_html_ab6841842e14099af9419c954e0f5ff60"><div class="ttname"><a href="lib_2Target_2X86_2README_8txt.html#ab6841842e14099af9419c954e0f5ff60">optimizations</a></div><div class="ttdeci">Moving arg1 onto the stack slot of callee function would overwrite arg2 of the caller Possible optimizations</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2X86_2README_8txt_source.html#l00700">README.txt:700</a></div></div>
<div class="ttc" id="anamespacellvm_1_1ISD_html_a22ea9cec080dd5f4f47ba234c2f59110a68014623710f7a44c808cd412236d6a1"><div class="ttname"><a href="namespacellvm_1_1ISD.html#a22ea9cec080dd5f4f47ba234c2f59110a68014623710f7a44c808cd412236d6a1">llvm::ISD::FRINT</a></div><div class="ttdeci">@ FRINT</div><div class="ttdef"><b>Definition:</b> <a href="ISDOpcodes_8h_source.html#l00925">ISDOpcodes.h:925</a></div></div>
<div class="ttc" id="alib_2CodeGen_2README_8txt_html_a3bb4aba7282bba64d822fbf46a93b4e9"><div class="ttname"><a href="lib_2CodeGen_2README_8txt.html#a3bb4aba7282bba64d822fbf46a93b4e9">lr</a></div><div class="ttdeci">Common register allocation spilling lr str lr</div><div class="ttdef"><b>Definition:</b> <a href="lib_2CodeGen_2README_8txt_source.html#l00006">README.txt:6</a></div></div>
<div class="ttc" id="anamespacellvm_1_1tgtok_html_abbc5259d649363016626e2529fabe0c5ab2ceb2a4ac0a01535be896234ce2d83c"><div class="ttname"><a href="namespacellvm_1_1tgtok.html#abbc5259d649363016626e2529fabe0c5ab2ceb2a4ac0a01535be896234ce2d83c">llvm::tgtok::If</a></div><div class="ttdeci">@ If</div><div class="ttdef"><b>Definition:</b> <a href="TGLexer_8h_source.html#l00051">TGLexer.h:51</a></div></div>
<div class="ttc" id="alib_2Target_2README_8txt_html_a15cbab8537bfbb820f4d2b3253e8a757"><div class="ttname"><a href="lib_2Target_2README_8txt.html#a15cbab8537bfbb820f4d2b3253e8a757">finite</a></div><div class="ttdeci">We don t delete this output free because trip count analysis doesn t realize that it is finite(if it were infinite, it would be undefined). Not having this blocks Loop Idiom from matching strlen and friends. void foo(char *C)</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2README_8txt_source.html#l00206">README.txt:206</a></div></div>
<div class="ttc" id="anamespacesaved_html"><div class="ttname"><a href="namespacesaved.html">saved</a></div></div>
<div class="ttc" id="aLint_8cpp_html_a7fb3c9caadeb0f7fe4828d380158d0f9"><div class="ttname"><a href="Lint_8cpp.html#a7fb3c9caadeb0f7fe4828d380158d0f9">IR</a></div><div class="ttdeci">Statically lint checks LLVM IR</div><div class="ttdef"><b>Definition:</b> <a href="Lint_8cpp_source.html#l00746">Lint.cpp:746</a></div></div>
<div class="ttc" id="anamespacellvm_1_1ilist__detail_html_ac7551955242d0b1649a6962fc449df5c"><div class="ttname"><a href="namespacellvm_1_1ilist__detail.html#ac7551955242d0b1649a6962fc449df5c">llvm::ilist_detail::make</a></div><div class="ttdeci">T &amp; make()</div></div>
<div class="ttc" id="alib_2Target_2README_8txt_html_a55af18a960b4a3ef703b4f5ba598fcaa"><div class="ttname"><a href="lib_2Target_2README_8txt.html#a55af18a960b4a3ef703b4f5ba598fcaa">b2</a></div><div class="ttdeci">int b2</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2README_8txt_source.html#l00084">README.txt:84</a></div></div>
<div class="ttc" id="aDemandedBits_8cpp_html_a424386ca25576268325092c3f58b45ab"><div class="ttname"><a href="DemandedBits_8cpp.html#a424386ca25576268325092c3f58b45ab">analysis</a></div><div class="ttdeci">demanded Demanded bits analysis</div><div class="ttdef"><b>Definition:</b> <a href="DemandedBits_8cpp_source.html#l00058">DemandedBits.cpp:58</a></div></div>
<div class="ttc" id="aExpandLargeDivRem_8cpp_html_ac7752c64c2d688b882808f06328ad521"><div class="ttname"><a href="ExpandLargeDivRem_8cpp.html#ac7752c64c2d688b882808f06328ad521">rem</a></div><div class="ttdeci">expand large div rem</div><div class="ttdef"><b>Definition:</b> <a href="ExpandLargeDivRem_8cpp_source.html#l00134">ExpandLargeDivRem.cpp:134</a></div></div>
<div class="ttc" id="anamespacellvm_1_1ISD_html_a22ea9cec080dd5f4f47ba234c2f59110ac513a7da1bf74fb3e3c594da8534f2d2"><div class="ttname"><a href="namespacellvm_1_1ISD.html#a22ea9cec080dd5f4f47ba234c2f59110ac513a7da1bf74fb3e3c594da8534f2d2">llvm::ISD::AND</a></div><div class="ttdeci">@ AND</div><div class="ttdoc">Bitwise operators - logical and, logical or, logical xor.</div><div class="ttdef"><b>Definition:</b> <a href="ISDOpcodes_8h_source.html#l00666">ISDOpcodes.h:666</a></div></div>
<div class="ttc" id="aTargetLibraryInfo_8cpp_html_aca185e6d0e9f423dbb24440206454872afbe5087b942deaaa3202c7ca87dbc327"><div class="ttname"><a href="TargetLibraryInfo_8cpp.html#aca185e6d0e9f423dbb24440206454872afbe5087b942deaaa3202c7ca87dbc327">Long</a></div><div class="ttdeci">@ Long</div><div class="ttdef"><b>Definition:</b> <a href="TargetLibraryInfo_8cpp_source.html#l00052">TargetLibraryInfo.cpp:52</a></div></div>
<div class="ttc" id="alib_2Target_2X86_2README_8txt_html_a6a470079c287619cde1886b96be341e8"><div class="ttname"><a href="lib_2Target_2X86_2README_8txt.html#a6a470079c287619cde1886b96be341e8">Finally</a></div><div class="ttdeci">is currently compiled esp esp jne LBB1_1 esp ret esp esp jne L_abort $stub esp ret This can be applied to any no return function call that takes no arguments etc the stack save restore logic could be shrink producing something like esp jne LBB1_1 ret esp call L_abort $stub Both are useful in different situations Finally</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2X86_2README_8txt_source.html#l00423">README.txt:423</a></div></div>
<div class="ttc" id="alib_2Target_2WebAssembly_2README_8txt_html_a8b4fec11feb69428162c4dafa16b75aa"><div class="ttname"><a href="lib_2Target_2WebAssembly_2README_8txt.html#a8b4fec11feb69428162c4dafa16b75aa">coloring</a></div><div class="ttdeci">we should consider alternate ways to model stack dependencies Lots of things could be done in WebAssemblyTargetTransformInfo cpp there are numerous optimization related hooks that can be overridden in WebAssemblyTargetLowering Instead of the OptimizeReturned which should consider preserving the returned attribute through to MachineInstrs and extending the MemIntrinsicResults pass to do this optimization on calls too That would also let the WebAssemblyPeephole pass clean up dead defs for such as it does for stores Consider implementing and or getMachineCombinerPatterns Find a clean way to fix the problem which leads to the Shrink Wrapping pass being run after the WebAssembly PEI pass When setting multiple variables to the same we currently get code like const It could be done with a smaller encoding like local tee $pop5 local $pop6 WebAssembly registers are implicitly initialized to zero Explicit zeroing is therefore often redundant and could be optimized away Small indices may use smaller encodings than large indices WebAssemblyRegColoring and or WebAssemblyRegRenumbering should sort registers according to their usage frequency to maximize the usage of smaller encodings Many cases of irreducible control flow could be transformed more optimally than via the transform in WebAssemblyFixIrreducibleControlFlow cpp It may also be worthwhile to do transforms before register coloring</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2WebAssembly_2README_8txt_source.html#l00119">README.txt:119</a></div></div>
<div class="ttc" id="aREADME-Thumb_8txt_html_a973d97283c6051f289e2347e413dff5d"><div class="ttname"><a href="README-Thumb_8txt.html#a973d97283c6051f289e2347e413dff5d">modes</a></div><div class="ttdeci">*Add support for compiling functions in both ARM and Thumb then taking the smallest *Add support for compiling individual basic blocks in thumb when in a larger ARM function This can be used for presumed cold like paths to EH handling etc *Thumb doesn t have normal pre post increment addressing modes</div><div class="ttdef"><b>Definition:</b> <a href="README-Thumb_8txt_source.html#l00012">README-Thumb.txt:12</a></div></div>
<div class="ttc" id="aLoopStrengthReduce_8cpp_html_a6d827fc34f1b4371a0b7183d3ca5bcac"><div class="ttname"><a href="LoopStrengthReduce_8cpp.html#a6d827fc34f1b4371a0b7183d3ca5bcac">reduce</a></div><div class="ttdeci">loop reduce</div><div class="ttdef"><b>Definition:</b> <a href="LoopStrengthReduce_8cpp_source.html#l07016">LoopStrengthReduce.cpp:7016</a></div></div>
<div class="ttc" id="alib_2Target_2SystemZ_2README_8txt_html_a839cdc0e6ffaecf33b5d7bfc83e2b7ec"><div class="ttname"><a href="lib_2Target_2SystemZ_2README_8txt.html#a839cdc0e6ffaecf33b5d7bfc83e2b7ec">input</a></div><div class="ttdeci">The initial backend is deliberately restricted to z10 We should add support for later architectures at some point If an asm ties an i32 r result to an i64 input</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2SystemZ_2README_8txt_source.html#l00010">README.txt:10</a></div></div>
<div class="ttc" id="aMem2Reg_8cpp_html_a6fde3eb6ca09ddf2fd76432176d817bb"><div class="ttname"><a href="Mem2Reg_8cpp.html#a6fde3eb6ca09ddf2fd76432176d817bb">Register</a></div><div class="ttdeci">Promote Memory to Register</div><div class="ttdef"><b>Definition:</b> <a href="Mem2Reg_8cpp_source.html#l00110">Mem2Reg.cpp:110</a></div></div>
<div class="ttc" id="anamespacellvm_1_1NVPTX_1_1PTXLdStInstCode_html_a91119cbee2be000c528a690252aee07ca09c68d67f7dbfa6cc77eaf73aa535217"><div class="ttname"><a href="namespacellvm_1_1NVPTX_1_1PTXLdStInstCode.html#a91119cbee2be000c528a690252aee07ca09c68d67f7dbfa6cc77eaf73aa535217">llvm::NVPTX::PTXLdStInstCode::Scalar</a></div><div class="ttdeci">@ Scalar</div><div class="ttdef"><b>Definition:</b> <a href="NVPTX_8h_source.html#l00123">NVPTX.h:123</a></div></div>
<div class="ttc" id="alib_2Target_2PowerPC_2README_8txt_html_a2782c90dcee19389220016d1079995a0"><div class="ttname"><a href="lib_2Target_2PowerPC_2README_8txt.html#a2782c90dcee19389220016d1079995a0">LCPI1_2</a></div><div class="ttdeci">cond_true lis lo16() lo16() LCPI1_2(r3) lfs f3</div></div>
<div class="ttc" id="alib_2Target_2SystemZ_2README_8txt_html_aeb73474502cd3b5f87e8d095252e95c3"><div class="ttname"><a href="lib_2Target_2SystemZ_2README_8txt.html#aeb73474502cd3b5f87e8d095252e95c3">force</a></div><div class="ttdeci">therefore end up llgh r3 lr r0 br r14 but truncating the load would lh r3 br r14 Functions ret i64 and ought to be implemented ngr r0 br r14 but two address optimizations reverse the order of the AND and force</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2SystemZ_2README_8txt_source.html#l00112">README.txt:112</a></div></div>
<div class="ttc" id="alib_2Target_2ARM_2README_8txt_html_ae3e84a62e4ae19e7766bde30ee72c040"><div class="ttname"><a href="lib_2Target_2ARM_2README_8txt.html#ae3e84a62e4ae19e7766bde30ee72c040">c</a></div><div class="ttdeci">the resulting code requires compare and branches when and if the revised code is with conditional branches instead of More there is a byte word extend before each where there should be only and the condition codes are not remembered when the same two values are compared twice More LSR enhancements i8 and i32 load store addressing modes are identical int int c</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2ARM_2README_8txt_source.html#l00418">README.txt:418</a></div></div>
<div class="ttc" id="aREADME-SSE_8txt_html_a4d543abbbb5e65f82c0ff777e778e848"><div class="ttname"><a href="README-SSE_8txt.html#a4d543abbbb5e65f82c0ff777e778e848">pshufd</a></div><div class="ttdeci">Instead we get xmm1 addss xmm1 pshufd</div><div class="ttdef"><b>Definition:</b> <a href="README-SSE_8txt_source.html#l00035">README-SSE.txt:35</a></div></div>
<div class="ttc" id="aRegionPrinter_8cpp_html_a5782a8740ff1e91516b41b3726a3168c"><div class="ttname"><a href="RegionPrinter_8cpp.html#a5782a8740ff1e91516b41b3726a3168c">only</a></div><div class="ttdeci">dot regions only</div><div class="ttdef"><b>Definition:</b> <a href="RegionPrinter_8cpp_source.html#l00194">RegionPrinter.cpp:194</a></div></div>
<div class="ttc" id="alib_2CodeGen_2README_8txt_html_a134ffba8da3505dfab10eef1a9a8b1ef"><div class="ttname"><a href="lib_2CodeGen_2README_8txt.html#a134ffba8da3505dfab10eef1a9a8b1ef">place</a></div><div class="ttdeci">Common register allocation spilling lr str ldr sxth r3 ldr mla r4 can lr mov lr str ldr sxth r3 mla r4 and then merge mul and lr str ldr sxth r3 mla r4 It also increase the likelihood the store may become dead bb27 Successors according to LLVM ID Predecessors according to mbb&lt; bb27, 0x8b0a7c0 &gt; Note ADDri is not a two address instruction its result reg1037 is an operand of the PHI node in bb76 and its operand reg1039 is the result of the PHI node We should treat it as a two address code and make sure the ADDri is scheduled after any node that reads reg1039 Use info(i.e. register scavenger) to assign it a free register to allow reuse the collector could move the objects and invalidate the derived pointer This is bad enough in the first place</div><div class="ttdef"><b>Definition:</b> <a href="lib_2CodeGen_2README_8txt_source.html#l00050">README.txt:50</a></div></div>
<div class="ttc" id="aclassStringView_html_a7f2ffb885adbde9d847c15600469c2bb"><div class="ttname"><a href="classStringView.html#a7f2ffb885adbde9d847c15600469c2bb">StringView::end</a></div><div class="ttdeci">const char * end() const</div><div class="ttdef"><b>Definition:</b> <a href="StringView_8h_source.html#l00110">StringView.h:110</a></div></div>
<div class="ttc" id="alib_2Target_2X86_2README_8txt_html_ad69006407bac3cd372fb772acc724fe4"><div class="ttname"><a href="lib_2Target_2X86_2README_8txt.html#ad69006407bac3cd372fb772acc724fe4">L6</a></div><div class="ttdeci">gets compiled into this on rsp movaps rsp movaps rsp movaps rsp movaps rsp movaps rsp movaps rsp movaps rsp movaps rsp movq rsp movq rsp movq rsp movq rsp movq rsp rax movq rsp rax movq rsp rsp rsp eax eax jbe LBB1_3 rcx rax movq rsp eax rsp ret ecx eax rcx movl rsp jmp LBB1_2 gcc rsp rax movq rsp rsp movq rsp rax movq rsp eax eax jb L6 rdx eax rsp ret p2align L6</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2X86_2README_8txt_source.html#l01168">README.txt:1168</a></div></div>
<div class="ttc" id="alib_2Target_2X86_2README_8txt_html_ac8b87f01ba64a825a85f33e88cb94ca0"><div class="ttname"><a href="lib_2Target_2X86_2README_8txt.html#ac8b87f01ba64a825a85f33e88cb94ca0">xmm6</a></div><div class="ttdeci">gets compiled into this on rsp movaps rsp movaps xmm6</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2X86_2README_8txt_source.html#l01116">README.txt:1116</a></div></div>
<div class="ttc" id="alib_2Target_2X86_2README_8txt_html_abfd08d6fe5fc62edeccb6e654c8781dd"><div class="ttname"><a href="lib_2Target_2X86_2README_8txt.html#abfd08d6fe5fc62edeccb6e654c8781dd">L10</a></div><div class="ttdeci">gcc compiles this esp xorl eax jmp L2 eax je L10 eax eax jne L3 call L_abort $stub L10</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2X86_2README_8txt_source.html#l00747">README.txt:747</a></div></div>
<div class="ttc" id="anamespacellvm_html_a1e2e31e83143be1af2ac00ab3322291e"><div class="ttname"><a href="namespacellvm.html#a1e2e31e83143be1af2ac00ab3322291e">llvm::demangle</a></div><div class="ttdeci">std::string demangle(const std::string &amp;MangledName)</div><div class="ttdoc">Attempt to demangle a string using different demangling schemes.</div><div class="ttdef"><b>Definition:</b> <a href="Demangle_8cpp_source.html#l00029">Demangle.cpp:29</a></div></div>
<div class="ttc" id="alib_2Target_2SystemZ_2README_8txt_html_a8e96f00729aa3d4404fa4eff73925f9d"><div class="ttname"><a href="lib_2Target_2SystemZ_2README_8txt.html#a8e96f00729aa3d4404fa4eff73925f9d">too</a></div><div class="ttdeci">The initial backend is deliberately restricted to z10 We should add support for later architectures at some point If an asm ties an i32 r result to an i64 the input will be treated as an leaving the upper bits uninitialised For i64 store i32 i32 *dst ret void from CodeGen SystemZ asm ll will use LHI rather than LGHI to load This seems to be a general target independent problem The tuning of the choice between LOAD XC and CLC for constant length block operations We could extend them to variable length operations too</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2SystemZ_2README_8txt_source.html#l00040">README.txt:40</a></div></div>
<div class="ttc" id="alib_2CodeGen_2README_8txt_html_a09571efa45610bd20734656e6c524047"><div class="ttname"><a href="lib_2CodeGen_2README_8txt.html#a09571efa45610bd20734656e6c524047">will</a></div><div class="ttdeci">Common register allocation spilling lr str ldr sxth r3 ldr mla r4 can lr mov lr str ldr sxth r3 mla r4 and then merge mul and lr str ldr sxth r3 mla r4 It also increase the likelihood the store may become dead bb27 Successors according to LLVM ID Predecessors according to mbb&lt; bb27, 0x8b0a7c0 &gt; Note ADDri is not a two address instruction its result reg1037 is an operand of the PHI node in bb76 and its operand reg1039 is the result of the PHI node We should treat it as a two address code and make sure the ADDri is scheduled after any node that reads reg1039 Use info(i.e. register scavenger) to assign it a free register to allow reuse the collector could move the objects and invalidate the derived pointer This is bad enough in the first but safe points can crop up unpredictably **array_addr i32 n y store obj obj **nth_el If the i64 division is lowered to a then a safe point will(must) appear for the call site. If a collection occurs</div></div>
<div class="ttc" id="alib_2Target_2README_8txt_html_a819b717d29c6c488a332fefeeb3815ba"><div class="ttname"><a href="lib_2Target_2README_8txt.html#a819b717d29c6c488a332fefeeb3815ba">foo</a></div><div class="ttdeci">&lt; i32 &gt; tmp foo</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2README_8txt_source.html#l00383">README.txt:383</a></div></div>
<div class="ttc" id="alib_2Target_2ARM_2README_8txt_html_ade8c6980e1babe1b309a9bcec7eefd2c"><div class="ttname"><a href="lib_2Target_2ARM_2README_8txt.html#ade8c6980e1babe1b309a9bcec7eefd2c">one</a></div><div class="ttdeci">the resulting code requires compare and branches when and if the revised code is with conditional branches instead of More there is a byte word extend before each where there should be only one</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2ARM_2README_8txt_source.html#l00401">README.txt:401</a></div></div>
<div class="ttc" id="anamespacellvm_1_1dxil_1_1PointerTypeAnalysis_html_ae574a4c1d84b9e67bc94489f356805b4"><div class="ttname"><a href="namespacellvm_1_1dxil_1_1PointerTypeAnalysis.html#ae574a4c1d84b9e67bc94489f356805b4">llvm::dxil::PointerTypeAnalysis::run</a></div><div class="ttdeci">PointerTypeMap run(const Module &amp;M)</div><div class="ttdoc">Compute the PointerTypeMap for the module M.</div><div class="ttdef"><b>Definition:</b> <a href="PointerTypeAnalysis_8cpp_source.html#l00189">PointerTypeAnalysis.cpp:189</a></div></div>
<div class="ttc" id="aclassStringView_html_aed7c7638f6c0cbcac746e912805f7f39"><div class="ttname"><a href="classStringView.html#aed7c7638f6c0cbcac746e912805f7f39">StringView::startsWith</a></div><div class="ttdeci">bool startsWith(StringView Str) const</div><div class="ttdef"><b>Definition:</b> <a href="StringView_8h_source.html#l00101">StringView.h:101</a></div></div>
<div class="ttc" id="alib_2Target_2WebAssembly_2README_8txt_html_a2f18db7a825d21ca8818134d56e0cee1"><div class="ttname"><a href="lib_2Target_2WebAssembly_2README_8txt.html#a2f18db7a825d21ca8818134d56e0cee1">jump</a></div><div class="ttdeci">The object format emitted by the WebAssembly backed is documented see the home and packaging for producing WebAssembly applications that can run in browsers and other environments wasi sdk provides a more minimal C C SDK based on llvm and a libc based on for producing WebAssemmbly applictions that use the WASI ABI Rust provides WebAssembly support integrated into Cargo There are two main which provides a relatively minimal environment that has an emphasis on being native wasm32 unknown which uses Emscripten internally and provides standard C C filesystem GL and SDL bindings For more and br_table instructions can support having a value on the value stack across the jump(sometimes). We should(a) model this</div></div>
<div class="ttc" id="alib_2Target_2README_8txt_html_a50c8e2b4c2b4b443dd0149c808a1f812"><div class="ttname"><a href="lib_2Target_2README_8txt.html#a50c8e2b4c2b4b443dd0149c808a1f812">into</a></div><div class="ttdeci">Clang compiles this into</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2README_8txt_source.html#l00504">README.txt:504</a></div></div>
<div class="ttc" id="alib_2Target_2X86_2README_8txt_html_a70ec792a441b34b77d4803f0607cf763"><div class="ttname"><a href="lib_2Target_2X86_2README_8txt.html#a70ec792a441b34b77d4803f0607cf763">Instead</a></div><div class="ttdeci">Current eax eax eax ret Ideal eax eax ret Re implement atomic builtins x86 does not have to use add to implement these Instead</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2X86_2README_8txt_source.html#l01366">README.txt:1366</a></div></div>
<div class="ttc" id="alib_2CodeGen_2README_8txt_html_a39b85bbe83e984ed97956f03d6c42501"><div class="ttname"><a href="lib_2CodeGen_2README_8txt.html#a39b85bbe83e984ed97956f03d6c42501">i32</a></div><div class="ttdeci">Common register allocation spilling lr str ldr sxth r3 ldr mla r4 can lr mov lr str ldr sxth r3 mla r4 and then merge mul and lr str ldr sxth r3 mla r4 It also increase the likelihood the store may become dead bb27 Successors according to LLVM ID Predecessors according to mbb&lt; bb27, 0x8b0a7c0 &gt; Note ADDri is not a two address instruction its result reg1037 is an operand of the PHI node in bb76 and its operand reg1039 is the result of the PHI node We should treat it as a two address code and make sure the ADDri is scheduled after any node that reads reg1039 Use info(i.e. register scavenger) to assign it a free register to allow reuse the collector could move the objects and invalidate the derived pointer This is bad enough in the first but safe points can crop up unpredictably **array_addr i32</div><div class="ttdef"><b>Definition:</b> <a href="lib_2CodeGen_2README_8txt_source.html#l00122">README.txt:122</a></div></div>
<div class="ttc" id="alib_2Target_2X86_2README_8txt_html_a4fb8859e996fb3772fe187df4cb209c1"><div class="ttname"><a href="lib_2Target_2X86_2README_8txt.html#a4fb8859e996fb3772fe187df4cb209c1">xmm5</a></div><div class="ttdeci">gets compiled into this on rsp movaps rsp movaps rsp movaps xmm5</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2X86_2README_8txt_source.html#l01117">README.txt:1117</a></div></div>
<div class="ttc" id="anamespacellvm_html_a74cdbd1e4f731e7d7cd83461b8b1de0b"><div class="ttname"><a href="namespacellvm.html#a74cdbd1e4f731e7d7cd83461b8b1de0b">llvm::sort</a></div><div class="ttdeci">void sort(IteratorTy Start, IteratorTy End)</div><div class="ttdef"><b>Definition:</b> <a href="STLExtras_8h_source.html#l01683">STLExtras.h:1683</a></div></div>
<div class="ttc" id="alib_2Target_2README_8txt_html_af821e68d2a86a3a844d45fa2af733a90"><div class="ttname"><a href="lib_2Target_2README_8txt.html#af821e68d2a86a3a844d45fa2af733a90">cases</a></div><div class="ttdeci">this could be done in SelectionDAGISel along with other special cases</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2README_8txt_source.html#l00103">README.txt:103</a></div></div>
<div class="ttc" id="aREADME-SSE_8txt_html_a74cbdc7d94b0939a18d91b65d2a046aa"><div class="ttname"><a href="README-SSE_8txt.html#a74cbdc7d94b0939a18d91b65d2a046aa">bad</a></div><div class="ttdeci">We currently generate an sqrtsd and divsd instructions This is bad</div><div class="ttdef"><b>Definition:</b> <a href="README-SSE_8txt_source.html#l00820">README-SSE.txt:820</a></div></div>
<div class="ttc" id="anamespacellvm_1_1COFF_html_aeffa16735e18df727a173beaf748c392a95141c0cf45e0de7385c99ac433ca8f6"><div class="ttname"><a href="namespacellvm_1_1COFF.html#aeffa16735e18df727a173beaf748c392a95141c0cf45e0de7385c99ac433ca8f6">llvm::COFF::SDL</a></div><div class="ttdeci">@ SDL</div><div class="ttdef"><b>Definition:</b> <a href="BinaryFormat_2COFF_8h_source.html#l00783">COFF.h:783</a></div></div>
<div class="ttc" id="anamespacellvm_1_1tgtok_html_abbc5259d649363016626e2529fabe0c5a5fa7b4069ef3bd1ceb9f2caa315cf5ac"><div class="ttname"><a href="namespacellvm_1_1tgtok.html#abbc5259d649363016626e2529fabe0c5a5fa7b4069ef3bd1ceb9f2caa315cf5ac">llvm::tgtok::In</a></div><div class="ttdeci">@ In</div><div class="ttdef"><b>Definition:</b> <a href="TGLexer_8h_source.html#l00051">TGLexer.h:51</a></div></div>
<div class="ttc" id="alib_2Analysis_2README_8txt_html_a990e4c7eb157d34eb1f3b087fd9f3da0"><div class="ttname"><a href="lib_2Analysis_2README_8txt.html#a990e4c7eb157d34eb1f3b087fd9f3da0">Opportunities</a></div><div class="ttdeci">Analysis Opportunities</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Analysis_2README_8txt_source.html#l00005">README.txt:5</a></div></div>
<div class="ttc" id="alib_2Target_2SystemZ_2README_8txt_html_accaf4e23f4ffc792355e64dcb9af2c96"><div class="ttname"><a href="lib_2Target_2SystemZ_2README_8txt.html#accaf4e23f4ffc792355e64dcb9af2c96">val</a></div><div class="ttdeci">The initial backend is deliberately restricted to z10 We should add support for later architectures at some point If an asm ties an i32 r result to an i64 the input will be treated as an leaving the upper bits uninitialised For i64 store i32 val</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2SystemZ_2README_8txt_source.html#l00015">README.txt:15</a></div></div>
<div class="ttc" id="alib_2Target_2README_8txt_html_affeca8df537e034591b261deab2f85d3"><div class="ttname"><a href="lib_2Target_2README_8txt.html#affeca8df537e034591b261deab2f85d3">xmm0</a></div><div class="ttdeci">Clang compiles this i1 i64 store i64 i64 store i64 i64 store i64 i64 store i64 align Which gets codegen d xmm0 movaps xmm0</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2README_8txt_source.html#l00517">README.txt:517</a></div></div>
<div class="ttc" id="alib_2Target_2SystemZ_2README_8txt_html_aa8360da3e6a89cbef2fdf88f38d3463d"><div class="ttname"><a href="lib_2Target_2SystemZ_2README_8txt.html#aa8360da3e6a89cbef2fdf88f38d3463d">ADDRESS</a></div><div class="ttdeci">The initial backend is deliberately restricted to z10 We should add support for later architectures at some point If an asm ties an i32 r result to an i64 the input will be treated as an leaving the upper bits uninitialised For i64 store i32 i32 *dst ret void from CodeGen SystemZ asm ll will use LHI rather than LGHI to load This seems to be a general target independent problem The tuning of the choice between LOAD ADDRESS(LA) and addition in SystemZISelDAGToDAG.cpp is suspect. It should be tweaked based on performance measurements. -- There is no scheduling support. -- We don 't use the BRANCH ON INDEX instructions. -- We only use MVC</div></div>
<div class="ttc" id="alib_2Target_2X86_2README_8txt_html_a544ce2b7de50b042a2d052c3d2831598"><div class="ttname"><a href="lib_2Target_2X86_2README_8txt.html#a544ce2b7de50b042a2d052c3d2831598">t</a></div><div class="ttdeci">We currently generate a but we really shouldn t</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2X86_2README_8txt_source.html#l01225">README.txt:1225</a></div></div>
<div class="ttc" id="alib_2Target_2X86_2README_8txt_html_a2db2310e02c56b8fb38c218ef736b956"><div class="ttname"><a href="lib_2Target_2X86_2README_8txt.html#a2db2310e02c56b8fb38c218ef736b956">v8i8</a></div><div class="ttdeci">def v8i8(MMX_MOVDQ2Qrr VR128:$src))&gt;</div></div>
<div class="ttc" id="aREADME-SSE_8txt_html_a294dbd0dcb369349e07f9bd78330b672"><div class="ttname"><a href="README-SSE_8txt.html#a294dbd0dcb369349e07f9bd78330b672">readonly</a></div><div class="ttdeci">This currently compiles esp xmm0 movsd esp eax eax esp ret We should use not the dag combiner This is because dagcombine2 needs to be able to see through the X86ISD::Wrapper which DAGCombine can t really do The code for turning x load into a single vector load is target independent and should be moved to the dag combiner The code for turning x load into a vector load can only handle a direct load from a global or a direct load from the stack It should be generalized to handle any load from where P can be anything The alignment inference code cannot handle loads from globals in static non mode because it doesn t look through the extra dyld stub load If you try vec_align ll without relocation you ll see what I mean We should lower which eliminates a constant pool load For float z nounwind readonly</div><div class="ttdef"><b>Definition:</b> <a href="README-SSE_8txt_source.html#l00421">README-SSE.txt:421</a></div></div>
<div class="ttc" id="aPHIElimination_8cpp_html_a6058ea3bdb60defe0ccd652f1a08131c"><div class="ttname"><a href="PHIElimination_8cpp.html#a6058ea3bdb60defe0ccd652f1a08131c">allocation</a></div><div class="ttdeci">Eliminate PHI nodes for register allocation</div><div class="ttdef"><b>Definition:</b> <a href="PHIElimination_8cpp_source.html#l00135">PHIElimination.cpp:135</a></div></div>
<div class="ttc" id="alib_2Target_2ARM_2README_8txt_html_ad2d2dbc6158971bef32d028ca933f960"><div class="ttname"><a href="lib_2Target_2ARM_2README_8txt.html#ad2d2dbc6158971bef32d028ca933f960">UXTAB16</a></div><div class="ttdeci">Reimplement select in terms of SEL *We would really like to support UXTAB16</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2ARM_2README_8txt_source.html#l00007">README.txt:7</a></div></div>
<div class="ttc" id="alib_2Target_2ARM_2README_8txt_html_a02241d17a38e10ee6b26448b2ff791e9"><div class="ttname"><a href="lib_2Target_2ARM_2README_8txt.html#a02241d17a38e10ee6b26448b2ff791e9">SMLAL</a></div><div class="ttdeci">Should compile to use SMLAL(Signed Multiply Accumulate Long) which multiplies two signed 32-bit values to produce a 64-bit value</div></div>
<div class="ttc" id="anamespacellvm_1_1lto_html_a89ef034c1f3a70da2446c1af1d656dab"><div class="ttname"><a href="namespacellvm_1_1lto.html#a89ef034c1f3a70da2446c1af1d656dab">llvm::lto::backend</a></div><div class="ttdeci">Error backend(const Config &amp;C, AddStreamFn AddStream, unsigned ParallelCodeGenParallelismLevel, Module &amp;M, ModuleSummaryIndex &amp;CombinedIndex)</div><div class="ttdoc">Runs a regular LTO backend.</div><div class="ttdef"><b>Definition:</b> <a href="LTOBackend_8cpp_source.html#l00497">LTOBackend.cpp:497</a></div></div>
<div class="ttc" id="aREADME__ALTIVEC_8txt_html_a52d387873c0d733fc2f0b9de3730223d"><div class="ttname"><a href="README__ALTIVEC_8txt.html#a52d387873c0d733fc2f0b9de3730223d">needed</a></div><div class="ttdeci">We should do a little better with eliminating dead stores The stores to the stack are dead since a and b are not needed</div><div class="ttdef"><b>Definition:</b> <a href="README__ALTIVEC_8txt_source.html#l00212">README_ALTIVEC.txt:212</a></div></div>
<div class="ttc" id="alib_2Target_2X86_2README_8txt_html_a1562fc446f77d508d88246f2da381a16"><div class="ttname"><a href="lib_2Target_2X86_2README_8txt.html#a1562fc446f77d508d88246f2da381a16">object</a></div><div class="ttdeci">bar al al movzbl eax ret Missed when stored in a memory object</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2X86_2README_8txt_source.html#l01411">README.txt:1411</a></div></div>
<div class="ttc" id="aDemangleConfig_8h_html_aacd584e2ac8072e41efbd2f3c2e439ca"><div class="ttname"><a href="DemangleConfig_8h.html#aacd584e2ac8072e41efbd2f3c2e439ca">DEMANGLE_NAMESPACE_END</a></div><div class="ttdeci">#define DEMANGLE_NAMESPACE_END</div><div class="ttdef"><b>Definition:</b> <a href="DemangleConfig_8h_source.html#l00090">DemangleConfig.h:90</a></div></div>
<div class="ttc" id="anamespacellvm_1_1cl_html_a8fa743aa76b6902028f8a643dfb87171"><div class="ttname"><a href="namespacellvm_1_1cl.html#a8fa743aa76b6902028f8a643dfb87171">llvm::cl::values</a></div><div class="ttdeci">ValuesClass values(OptsTy... Options)</div><div class="ttdoc">Helper to build a ValuesClass by forwarding a variable number of arguments as an initializer list to ...</div><div class="ttdef"><b>Definition:</b> <a href="CommandLine_8h_source.html#l00703">CommandLine.h:703</a></div></div>
<div class="ttc" id="aREADME-X86-64_8txt_html_aac3add0badd5c39bebc02df0b5d9bdcf"><div class="ttname"><a href="README-X86-64_8txt.html#aac3add0badd5c39bebc02df0b5d9bdcf">type</a></div><div class="ttdeci">AMD64 Optimization Manual has some nice information about optimizing integer multiplication by a constant How much of it applies to Intel s X86 implementation There are definite trade offs to xmm0 cvttss2siq rdx jb L3 subss xmm0 rax cvttss2siq rdx xorq rdx rax ret instead of xmm1 cvttss2siq rcx movaps xmm2 subss xmm2 cvttss2siq rax rdx xorq rax ucomiss xmm0 cmovb rax ret Seems like the jb branch has high likelihood of being taken It would have saved a few instructions It s not possible to reference and DH registers in an instruction requiring REX prefix divb and mulb both produce results in AH If isel emits a CopyFromReg which gets turned into a movb and that can be allocated a r8b r15b To get around isel emits a CopyFromReg from AX and then right shift it down by and truncate it It s not pretty but it works We need some register allocation magic to make the hack go which would often require a callee saved register Callees usually need to keep this value live for most of their body so it doesn t add a significant burden on them We currently implement this in however this is suboptimal because it means that it would be quite awkward to implement the optimization for callers A better implementation would be to relax the LLVM IR rules for sret arguments to allow a function with an sret argument to have a non void return type</div><div class="ttdef"><b>Definition:</b> <a href="README-X86-64_8txt_source.html#l00070">README-X86-64.txt:70</a></div></div>
<div class="ttc" id="alib_2Target_2X86_2README_8txt_html_ad2f7724072b5d664bca622e53494c853"><div class="ttname"><a href="lib_2Target_2X86_2README_8txt.html#ad2f7724072b5d664bca622e53494c853">inc</a></div><div class="ttdeci">Current eax eax eax ret Ideal eax eax ret Re implement atomic builtins x86 does not have to use add to implement these it can use inc</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2X86_2README_8txt_source.html#l01367">README.txt:1367</a></div></div>
<div class="ttc" id="aGlobPattern_8cpp_html_a7dfb870dcce522f4df1212ba56cf9efd"><div class="ttname"><a href="GlobPattern_8cpp.html#a7dfb870dcce522f4df1212ba56cf9efd">expand</a></div><div class="ttdeci">static Expected&lt; BitVector &gt; expand(StringRef S, StringRef Original)</div><div class="ttdef"><b>Definition:</b> <a href="GlobPattern_8cpp_source.html#l00026">GlobPattern.cpp:26</a></div></div>
<div class="ttc" id="alib_2Target_2README_8txt_html_a224c8fc3b52ad2cda25bafa32e1094d3"><div class="ttname"><a href="lib_2Target_2README_8txt.html#a224c8fc3b52ad2cda25bafa32e1094d3">a1</a></div><div class="ttdeci">This is blocked on not handling X *X *X which is the same number of multiplies and is because the *X has multiple uses Here s a simple X1 B ret i32 C Reassociate should handle the example in GCC a1</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2README_8txt_source.html#l00084">README.txt:84</a></div></div>
<div class="ttc" id="anamespacellvm_html_ab1772fd431decccb7926d484ea223db7"><div class="ttname"><a href="namespacellvm.html#ab1772fd431decccb7926d484ea223db7">llvm::count</a></div><div class="ttdeci">auto count(R &amp;&amp;Range, const E &amp;Element)</div><div class="ttdoc">Wrapper function around std::count to count the number of times an element Element occurs in the give...</div><div class="ttdef"><b>Definition:</b> <a href="STLExtras_8h_source.html#l01896">STLExtras.h:1896</a></div></div>
<div class="ttc" id="alib_2Target_2README_8txt_html_a9026bda84f719fb903ddea83fc478a76"><div class="ttname"><a href="lib_2Target_2README_8txt.html#a9026bda84f719fb903ddea83fc478a76">following</a></div><div class="ttdeci">This is equivalent to the following</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2README_8txt_source.html#l00671">README.txt:671</a></div></div>
<div class="ttc" id="aBuiltinGCs_8cpp_html_a9bf617fd3367180fb96cebccfaae8dfa"><div class="ttname"><a href="BuiltinGCs_8cpp.html#a9bf617fd3367180fb96cebccfaae8dfa">D</a></div><div class="ttdeci">static GCRegistry::Add&lt; StatepointGC &gt; D(&quot;statepoint-example&quot;, &quot;an example strategy for statepoint&quot;)</div></div>
<div class="ttc" id="aExpandReductions_8cpp_html_a4bfc835c142e9a1d698379da76392e9f"><div class="ttname"><a href="ExpandReductions_8cpp.html#a4bfc835c142e9a1d698379da76392e9f">intrinsics</a></div><div class="ttdeci">expand Expand reduction intrinsics</div><div class="ttdef"><b>Definition:</b> <a href="ExpandReductions_8cpp_source.html#l00198">ExpandReductions.cpp:198</a></div></div>
<div class="ttc" id="aAArch64PromoteConstant_8cpp_html_a90f8350fecae261c25be85d38b451bff"><div class="ttname"><a href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></div><div class="ttdeci">aarch64 promote const</div><div class="ttdef"><b>Definition:</b> <a href="AArch64PromoteConstant_8cpp_source.html#l00232">AArch64PromoteConstant.cpp:232</a></div></div>
<div class="ttc" id="alib_2Target_2PowerPC_2README_8txt_html_a25b4d4c1e0d625cfc6076f3b66fd631a"><div class="ttname"><a href="lib_2Target_2PowerPC_2README_8txt.html#a25b4d4c1e0d625cfc6076f3b66fd631a">LBB2_1</a></div><div class="ttdeci">entry LBB2_1</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2PowerPC_2README_8txt_source.html#l00165">README.txt:165</a></div></div>
<div class="ttc" id="anamespacellvm_1_1ISD_html_a22ea9cec080dd5f4f47ba234c2f59110a269b81f007000306e3e69d0d290c2159"><div class="ttname"><a href="namespacellvm_1_1ISD.html#a22ea9cec080dd5f4f47ba234c2f59110a269b81f007000306e3e69d0d290c2159">llvm::ISD::LOAD</a></div><div class="ttdeci">@ LOAD</div><div class="ttdoc">LOAD and STORE have token chains as their first operand, then the same operands as an LLVM load/store...</div><div class="ttdef"><b>Definition:</b> <a href="ISDOpcodes_8h_source.html#l00965">ISDOpcodes.h:965</a></div></div>
<div class="ttc" id="aREADME-SSE_8txt_html_afd91459f7d35fb3d57a28214c8a358dd"><div class="ttname"><a href="README-SSE_8txt.html#afd91459f7d35fb3d57a28214c8a358dd">tmp10</a></div><div class="ttdeci">&lt; i128 &gt; tmp10</div><div class="ttdef"><b>Definition:</b> <a href="README-SSE_8txt_source.html#l00791">README-SSE.txt:791</a></div></div>
<div class="ttc" id="alib_2Target_2X86_2README_8txt_html_a00545862984da0abbb576968c3d48f91"><div class="ttname"><a href="lib_2Target_2X86_2README_8txt.html#a00545862984da0abbb576968c3d48f91">__const_coal</a></div><div class="ttdeci">the multiplication has a latency of four as opposed to two cycles for the movl lea variant It appears gcc place string data with linkonce linkage in section __const_coal</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2X86_2README_8txt_source.html#l00259">README.txt:259</a></div></div>
<div class="ttc" id="anamespacellvm_1_1LegalityPredicates_html_ad7ac7032baa62cc00002886633b9f281"><div class="ttname"><a href="namespacellvm_1_1LegalityPredicates.html#ad7ac7032baa62cc00002886633b9f281">llvm::LegalityPredicates::all</a></div><div class="ttdeci">Predicate all(Predicate P0, Predicate P1)</div><div class="ttdoc">True iff P0 and P1 are true.</div><div class="ttdef"><b>Definition:</b> <a href="LegalizerInfo_8h_source.html#l00228">LegalizerInfo.h:228</a></div></div>
<div class="ttc" id="alib_2Target_2README_8txt_html_a5a6a05b7d9e9efb3f7b098c20fa0088a"><div class="ttname"><a href="lib_2Target_2README_8txt.html#a5a6a05b7d9e9efb3f7b098c20fa0088a">s</a></div><div class="ttdeci">multiplies can be turned into SHL s</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2README_8txt_source.html#l00370">README.txt:370</a></div></div>
<div class="ttc" id="alib_2Target_2X86_2README_8txt_html_a45fb1d078ce1e6a0cc79a8e8075b667a"><div class="ttname"><a href="lib_2Target_2X86_2README_8txt.html#a45fb1d078ce1e6a0cc79a8e8075b667a">extend</a></div><div class="ttdeci">_test eax xmm0 eax xmm1 comiss xmm1 setae al movzbl ecx eax edx ecx cmove eax ret Note the cmove can be replaced with a single cmovae There are a number of issues We are introducing a setcc between the result of the intrisic call and select The intrinsic is expected to produce a i32 value so a any extend(which becomes a zero extend) is added. We probably need some kind of target DAG combine hook to fix this. We generate significantly worse code for this than GCC</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2X86_2README_8txt_source.html#l00213">README.txt:213</a></div></div>
<div class="ttc" id="anamespacellvm_1_1logicalview_html_ace26b39c8ec4392e05223c28d8572c4d"><div class="ttname"><a href="namespacellvm_1_1logicalview.html#ace26b39c8ec4392e05223c28d8572c4d">llvm::logicalview::patterns</a></div><div class="ttdeci">LVPatterns &amp; patterns()</div><div class="ttdef"><b>Definition:</b> <a href="LVOptions_8h_source.html#l00640">LVOptions.h:640</a></div></div>
<div class="ttc" id="alib_2Target_2ARM_2README_8txt_html_ad3a99906764c35b2694ae90fa57744a5"><div class="ttname"><a href="lib_2Target_2ARM_2README_8txt.html#ad3a99906764c35b2694ae90fa57744a5">move</a></div><div class="ttdeci">compiles ldr LCPI1_0 ldr ldr mov lsr tst moveq r1 ldr LCPI1_1 and r0 bx lr It would be better to do something like to fold the shift into the conditional move</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2ARM_2README_8txt_source.html#l00546">README.txt:546</a></div></div>
<div class="ttc" id="ainclude_2llvm_2Demangle_2README_8txt_html_a01ccd2be3243452df4d6034ba6476c91"><div class="ttname"><a href="include_2llvm_2Demangle_2README_8txt.html#a01ccd2be3243452df4d6034ba6476c91">though</a></div><div class="ttdeci">test_demangle and llvm unittest Demangle The llvm directory should only get tests for stuff not included in the core library In the future though</div><div class="ttdef"><b>Definition:</b> <a href="include_2llvm_2Demangle_2README_8txt_source.html#l00057">README.txt:57</a></div></div>
<div class="ttc" id="aclassStringView_html_a70ff79f8b666f2d777a54950c1dabb4b"><div class="ttname"><a href="classStringView.html#a70ff79f8b666f2d777a54950c1dabb4b">StringView::StringView</a></div><div class="ttdeci">StringView(const char *Str)</div><div class="ttdef"><b>Definition:</b> <a href="StringView_8h_source.html#l00038">StringView.h:38</a></div></div>
<div class="ttc" id="ainclude_2llvm_2Demangle_2README_8txt_html_a2731ac5232eae4966860e9796375c663"><div class="ttname"><a href="include_2llvm_2Demangle_2README_8txt.html#a2731ac5232eae4966860e9796375c663">symbols</a></div><div class="ttdeci">Itanium Name Demangler i e convert the string _Z1fv into and both[sub] projects need to demangle symbols</div><div class="ttdef"><b>Definition:</b> <a href="include_2llvm_2Demangle_2README_8txt_source.html#l00020">README.txt:20</a></div></div>
<div class="ttc" id="anamespacellvm_1_1numbers_html_a92f4283d4e0e2ea1776894b3ae93640f"><div class="ttname"><a href="namespacellvm_1_1numbers.html#a92f4283d4e0e2ea1776894b3ae93640f">llvm::numbers::e</a></div><div class="ttdeci">constexpr double e</div><div class="ttdef"><b>Definition:</b> <a href="MathExtras_8h_source.html#l00031">MathExtras.h:31</a></div></div>
<div class="ttc" id="alib_2Target_2README_8txt_html_a000dca4bb092d40e3a906a44d9f73e10"><div class="ttname"><a href="lib_2Target_2README_8txt.html#a000dca4bb092d40e3a906a44d9f73e10">block</a></div><div class="ttdeci">Note that only the low bits of effective_addr2 are used On bit we don t eliminate the computation of the top half of effective_addr2 because we don t have whole function selection dags On this means we use one extra register for the function when effective_addr2 is declared as U64 than when it is declared U32 PHI Slicing could be extended to do this Tail call elim should be more checking to see if the call is followed by an uncond branch to an exit block</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2README_8txt_source.html#l00329">README.txt:329</a></div></div>
<div class="ttc" id="alib_2Target_2X86_2README_8txt_html_aa30b4a3f9687a43ebd32794525a507a3"><div class="ttname"><a href="lib_2Target_2X86_2README_8txt.html#aa30b4a3f9687a43ebd32794525a507a3">__DATA</a></div><div class="ttdeci">the multiplication has a latency of four as opposed to two cycles for the movl lea variant It appears gcc place string data with linkonce linkage in section coalesced instead of section __DATA</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2X86_2README_8txt_source.html#l00260">README.txt:260</a></div></div>
<div class="ttc" id="alib_2Target_2README_8txt_html_a0fc83b9f269b32b90d78cee5231c02e7"><div class="ttname"><a href="lib_2Target_2README_8txt.html#a0fc83b9f269b32b90d78cee5231c02e7">b3</a></div><div class="ttdeci">int b3</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2README_8txt_source.html#l00084">README.txt:84</a></div></div>
<div class="ttc" id="alib_2Target_2PowerPC_2README_8txt_html_ac3d3b392e54e180dbd5dc75af615268f"><div class="ttname"><a href="lib_2Target_2PowerPC_2README_8txt.html#ac3d3b392e54e180dbd5dc75af615268f">LBB1_83</a></div><div class="ttdeci">bb432 i LBB1_83</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2PowerPC_2README_8txt_source.html#l00038">README.txt:38</a></div></div>
<div class="ttc" id="aREADME__P9_8txt_html_a31e9c2fec98b86a6f4e630d2d4c4eb6c"><div class="ttname"><a href="README__P9_8txt.html#a31e9c2fec98b86a6f4e630d2d4c4eb6c">semantics</a></div><div class="ttdeci">Vector Shift Left don t map to llvm shl and because they have different semantics</div><div class="ttdef"><b>Definition:</b> <a href="README__P9_8txt_source.html#l00119">README_P9.txt:119</a></div></div>
<div class="ttc" id="aMD5_8cpp_html_ac0eafdc9ee161b71e7af98af736952fd"><div class="ttname"><a href="MD5_8cpp.html#ac0eafdc9ee161b71e7af98af736952fd">I</a></div><div class="ttdeci">#define I(x, y, z)</div><div class="ttdef"><b>Definition:</b> <a href="MD5_8cpp_source.html#l00058">MD5.cpp:58</a></div></div>
<div class="ttc" id="aREADME-SSE_8txt_html_a2b0732029f53354e4c2f685e93b36cac"><div class="ttname"><a href="README-SSE_8txt.html#a2b0732029f53354e4c2f685e93b36cac">something</a></div><div class="ttdeci">This might compile to this xmm1 xorps xmm0 movss xmm0 ret Now consider if the code caused xmm1 to get spilled This might produce this xmm1 movaps xmm0 movaps xmm1 movss xmm0 ret since the reload is only used by these we could fold it into the producing something like xmm1 movaps xmm0 ret saving two instructions The basic idea is that a reload from a spill if only one byte chunk is bring in zeros the one element instead of elements This can be used to simplify a variety of shuffle where the elements are fixed zeros This code generates ugly probably due to costs being off or something</div><div class="ttdef"><b>Definition:</b> <a href="README-SSE_8txt_source.html#l00278">README-SSE.txt:278</a></div></div>
<div class="ttc" id="alib_2Target_2PowerPC_2README_8txt_html_a0b7a6d10a388a5cd76ada79c909f545e"><div class="ttname"><a href="lib_2Target_2PowerPC_2README_8txt.html#a0b7a6d10a388a5cd76ada79c909f545e">cr0</a></div><div class="ttdeci">bb432 i mr r6 cmplwi cr0</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2PowerPC_2README_8txt_source.html#l00044">README.txt:44</a></div></div>
<div class="ttc" id="aAArch64O0PreLegalizerCombiner_8cpp_html_af818eca24c0322f3de14f4233fff73e6"><div class="ttname"><a href="AArch64O0PreLegalizerCombiner_8cpp.html#af818eca24c0322f3de14f4233fff73e6">legalization</a></div><div class="ttdeci">Combine AArch64 machine instrs before legalization</div><div class="ttdef"><b>Definition:</b> <a href="AArch64O0PreLegalizerCombiner_8cpp_source.html#l00166">AArch64O0PreLegalizerCombiner.cpp:166</a></div></div>
<div class="ttc" id="alib_2Target_2X86_2README_8txt_html_a47047da86e359f28033bcf83e4648793"><div class="ttname"><a href="lib_2Target_2X86_2README_8txt.html#a47047da86e359f28033bcf83e4648793">sub</a></div><div class="ttdeci">we currently eax ecx subl eax ret We would use one fewer register if codegen d eax neg eax eax ret Note that this isn t beneficial if the load can be folded into the sub In this we want a sub</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2X86_2README_8txt_source.html#l00460">README.txt:460</a></div></div>
<div class="ttc" id="alib_2Target_2ARM_2README_8txt_html_a09f6d95681fd43c904d1164c81a5141d"><div class="ttname"><a href="lib_2Target_2ARM_2README_8txt.html#a09f6d95681fd43c904d1164c81a5141d">call</a></div><div class="ttdeci">S is passed via registers r2 But gcc stores them to the and then reload them to and r3 before issuing the call(r0 contains the address of the format string)</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2ARM_2README_8txt_source.html#l00190">README.txt:190</a></div></div>
<div class="ttc" id="alib_2Target_2X86_2README_8txt_html_a563bc935d89bbba936c8355a3a6d6829"><div class="ttname"><a href="lib_2Target_2X86_2README_8txt.html#a563bc935d89bbba936c8355a3a6d6829">movaps</a></div><div class="ttdeci">_test eax movaps(%eax)</div></div>
<div class="ttc" id="anamespacellvm_1_1cl_html_a10a041239ae1870cfcc064bfaa79fb65"><div class="ttname"><a href="namespacellvm_1_1cl.html#a10a041239ae1870cfcc064bfaa79fb65">llvm::cl::init</a></div><div class="ttdeci">initializer&lt; Ty &gt; init(const Ty &amp;Val)</div><div class="ttdef"><b>Definition:</b> <a href="CommandLine_8h_source.html#l00445">CommandLine.h:445</a></div></div>
<div class="ttc" id="alib_2Target_2README_8txt_html_ae6434b48e3399d9bb8de51bbd4709003"><div class="ttname"><a href="lib_2Target_2README_8txt.html#ae6434b48e3399d9bb8de51bbd4709003">CLZ</a></div><div class="ttdeci">This should be recognized as CLZ</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2README_8txt_source.html#l00238">README.txt:238</a></div></div>
<div class="ttc" id="aREADME-SSE_8txt_html_adb7d9f7a99bf1090decff0ea8b50452d"><div class="ttname"><a href="README-SSE_8txt.html#adb7d9f7a99bf1090decff0ea8b50452d">node</a></div><div class="ttdeci">This currently compiles esp xmm0 movsd esp eax eax esp ret We should use not the dag combiner This is because dagcombine2 needs to be able to see through the X86ISD::Wrapper node</div><div class="ttdef"><b>Definition:</b> <a href="README-SSE_8txt_source.html#l00406">README-SSE.txt:406</a></div></div>
<div class="ttc" id="alib_2Target_2X86_2README_8txt_html_af2f37a99b74b150e396c0911cc22407f"><div class="ttname"><a href="lib_2Target_2X86_2README_8txt.html#af2f37a99b74b150e396c0911cc22407f">processor</a></div><div class="ttdeci">it should cost the same as a move shift on any modern processor</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2X86_2README_8txt_source.html#l00924">README.txt:924</a></div></div>
<div class="ttc" id="alib_2Target_2README_8txt_html_a02def7c594e9f19ff247ed0bf33d1c30"><div class="ttname"><a href="lib_2Target_2README_8txt.html#a02def7c594e9f19ff247ed0bf33d1c30">size</a></div><div class="ttdeci">i&lt; reg-&gt; size</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2README_8txt_source.html#l00166">README.txt:166</a></div></div>
<div class="ttc" id="alib_2Support_2Unix_2README_8txt_html_a2f233bead4ec71618d6f3a0ff7184373"><div class="ttname"><a href="lib_2Support_2Unix_2README_8txt.html#a2f233bead4ec71618d6f3a0ff7184373">README</a></div><div class="ttdeci">llvm lib Support Unix README</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Support_2Unix_2README_8txt_source.html#l00002">README.txt:2</a></div></div>
<div class="ttc" id="ainclude_2llvm_2Demangle_2README_8txt_html_a31d4c91b2056d9976c088336aadc9147"><div class="ttname"><a href="include_2llvm_2Demangle_2README_8txt.html#a31d4c91b2056d9976c088336aadc9147">places</a></div><div class="ttdeci">Itanium Name Demangler i e convert the string _Z1fv into and both[sub] projects need to demangle but neither can depend on each other *libcxxabi needs the demangler to implement which is part of the itanium ABI spec *LLVM needs a copy for a bunch of places</div><div class="ttdef"><b>Definition:</b> <a href="include_2llvm_2Demangle_2README_8txt_source.html#l00025">README.txt:25</a></div></div>
<div class="ttc" id="alib_2Target_2X86_2README_8txt_html_ad0a666df390b6bb23e152cd3805fe429"><div class="ttname"><a href="lib_2Target_2X86_2README_8txt.html#ad0a666df390b6bb23e152cd3805fe429">generated</a></div><div class="ttdeci">The following code is currently generated</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2X86_2README_8txt_source.html#l00954">README.txt:954</a></div></div>
<div class="ttc" id="alib_2Target_2README_8txt_html_ab9cbac3fe2f319e2f757dbe9dc3db66d"><div class="ttname"><a href="lib_2Target_2README_8txt.html#ab9cbac3fe2f319e2f757dbe9dc3db66d">a2</a></div><div class="ttdeci">This is blocked on not handling X *X *X which is the same number of multiplies and is because the *X has multiple uses Here s a simple X1 B ret i32 C Reassociate should handle the example in GCC a2</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2README_8txt_source.html#l00084">README.txt:84</a></div></div>
<div class="ttc" id="alib_2CodeGen_2README_8txt_html_a6ca76931253db2c6668f0cf07d8f66ab"><div class="ttname"><a href="lib_2CodeGen_2README_8txt.html#a6ca76931253db2c6668f0cf07d8f66ab">reg1038</a></div><div class="ttdeci">Common register allocation spilling lr str ldr sxth r3 ldr mla r4 can lr mov lr str ldr sxth r3 mla r4 and then merge mul and lr str ldr sxth r3 mla r4 It also increase the likelihood the store may become dead bb27 reg1038</div><div class="ttdef"><b>Definition:</b> <a href="lib_2CodeGen_2README_8txt_source.html#l00036">README.txt:36</a></div></div>
<div class="ttc" id="aREADME-Thumb_8txt_html_aba06a6e625a3fd56ccd541e3e78ab6be"><div class="ttname"><a href="README-Thumb_8txt.html#aba06a6e625a3fd56ccd541e3e78ab6be">LCPI1_0</a></div><div class="ttdeci">&gt; ldr r0, pc, #((LCPI1_0-(LPCRELL0+4))&amp;0xfffffffc) We compile the following:define i16 @func_entry_2E_ce(i32 %i) { switch i32 %i, label %bb12.exitStub[i32 0, label %bb4.exitStub i32 1, label %bb9.exitStub i32 2, label %bb4.exitStub i32 3, label %bb4.exitStub i32 7, label %bb9.exitStub i32 8, label %bb.exitStub i32 9, label %bb9.exitStub] bb12.exitStub:ret i16 0 bb4.exitStub:ret i16 1 bb9.exitStub:ret i16 2 bb.exitStub:ret i16 3 } into:_func_entry_2E_ce:mov r2, #1 lsl r2, r0 cmp r0, #9 bhi LBB1_4 @bb12.exitStub LBB1_1:@newFuncRoot mov r1, #13 tst r2, r1 bne LBB1_5 @bb4.exitStub LBB1_2:@newFuncRoot ldr r1, LCPI1_0 tst r2, r1 bne LBB1_6 @bb9.exitStub LBB1_3:@newFuncRoot mov r1, #1 lsl r1, r1, #8 tst r2, r1 bne LBB1_7 @bb.exitStub LBB1_4:@bb12.exitStub mov r0, #0 bx lr LBB1_5:@bb4.exitStub mov r0, #1 bx lr LBB1_6:@bb9.exitStub mov r0, #2 bx lr LBB1_7:@bb.exitStub mov r0, #3 bx lr LBB1_8:.align 2 LCPI1_0:.long 642 gcc compiles to:cmp r0, #9 @ lr needed for prologue bhi L2 ldr r3, L11 mov r2, #1 mov r1, r2, asl r0 ands r0, r3, r2, asl r0 movne r0, #2 bxne lr tst r1, #13 beq L9 L3:mov r0, r2 bx lr L9:tst r1, #256 movne r0, #3 bxne lr L2:mov r0, #0 bx lr L12:.align 2 L11:.long 642 GCC is doing a couple of clever things here:1. It is predicating one of the returns. This isn 't a clear win though:in cases where that return isn 't taken, it is replacing one condbranch with two 'ne' predicated instructions. 2. It is sinking the shift of &quot;1 &lt;&lt; i&quot; into the tst, and using ands instead of tst. This will probably require whole function isel. 3. GCC emits:tst r1, #256 we emit:mov r1, #1 lsl r1, r1, #8 tst r2, r1 When spilling in thumb mode and the sp offset is too large to fit in the ldr/str offset field, we load the offset from a constpool entry and add it to sp:ldr r2, LCPI add r2, sp ldr r2,[r2] These instructions preserve the condition code which is important if the spill is between a cmp and a bcc instruction. However, we can use the(potentially) cheaper sequence if we know it 's ok to clobber the condition register. add r2, sp, #255 *4 add r2, #132 ldr r2,[r2, #7 *4] This is especially bad when dynamic alloca is used. The all fixed size stack objects are referenced off the frame pointer with negative offsets. See oggenc for an example. Poor codegen test/CodeGen/ARM/select.ll f7:ldr r5, LCPI1_0 LPC0:add r5, pc ldr r6, LCPI1_1 ldr r2, LCPI1_2 mov r3, r6 mov lr, pc bx r5 Make register allocator/spiller smarter so we can re-materialize &quot;mov r, imm&quot;, etc. Almost all Thumb instructions clobber condition code. Thumb load/store address mode offsets are scaled. The values kept in the instruction operands are pre-scale values. This probably ought to be changed to avoid extra work when we convert Thumb2 instructions to Thumb1 instructions. We need to make(some of the) Thumb1 instructions predicable. That will allow shrinking of predicated Thumb2 instructions. To allow this, we need to be able to toggle the 's' bit since they do not set CPSR when they are inside IT blocks. Make use of hi register variants of cmp:tCMPhir/tCMPZhir. Thumb1 immediate field sometimes keep pre-scaled values. See ThumbRegisterInfo::eliminateFrameIndex. This is inconsistent from ARM and Thumb2. Rather than having tBR_JTr print a &quot;.align 2&quot; and constant island pass pad it, add a target specific ALIGN instruction instead. That way, getInstSizeInBytes won 't have to over-estimate. It can also be used for loop alignment pass. We generate conditional code for icmp when we don 't need to. This code:int foo(int s) { return s==1 LCPI1_0</div><div class="ttdef"><b>Definition:</b> <a href="README-Thumb_8txt_source.html#l00249">README-Thumb.txt:249</a></div></div>
<div class="ttc" id="aREADME__P9_8txt_html_a1a187076033ee3a6c1a38f652281bfae"><div class="ttname"><a href="README__P9_8txt.html#a1a187076033ee3a6c1a38f652281bfae">So</a></div><div class="ttdeci">So we should use XX3Form_Rcr to implement intrinsic Convert DP outs ins xscvdpsp So</div><div class="ttdef"><b>Definition:</b> <a href="README__P9_8txt_source.html#l00331">README_P9.txt:331</a></div></div>
<div class="ttc" id="alib_2Target_2X86_2README_8txt_html_a1517606f80cdd3daf97d2c598cee27f7"><div class="ttname"><a href="lib_2Target_2X86_2README_8txt.html#a1517606f80cdd3daf97d2c598cee27f7">__TEXT</a></div><div class="ttdeci">the multiplication has a latency of four as opposed to two cycles for the movl lea variant It appears gcc place string data with linkonce linkage in section __TEXT</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2X86_2README_8txt_source.html#l00259">README.txt:259</a></div></div>
<div class="ttc" id="alib_2Target_2ARM_2README_8txt_html_a77e00b6dc529eeb68ba1b34bdbbd23f8"><div class="ttname"><a href="lib_2Target_2ARM_2README_8txt.html#a77e00b6dc529eeb68ba1b34bdbbd23f8">ldr</a></div><div class="ttdeci">add sub stmia L5 ldr r0 bl L_printf $stub Instead of a and a ldr</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2ARM_2README_8txt_source.html#l00204">README.txt:204</a></div></div>
<div class="ttc" id="alib_2Target_2X86_2README_8txt_html_a53e39717513447bc9e8c187ebca9eba7"><div class="ttname"><a href="lib_2Target_2X86_2README_8txt.html#a53e39717513447bc9e8c187ebca9eba7">mtune</a></div><div class="ttdeci">pentium2/3/4/m/etc.:abs:movl 4(%esp), %eax cltd xorl %edx, %eax subl %edx, %eax ret Take the following code(from http:extern unsigned char first_one[65536] mtune</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2X86_2README_8txt_source.html#l00943">README.txt:943</a></div></div>
<div class="ttc" id="alib_2Target_2ARM_2README_8txt_html_ac394f9304a427e4d136ac39a262c0f32"><div class="ttname"><a href="lib_2Target_2ARM_2README_8txt.html#ac394f9304a427e4d136ac39a262c0f32">maximum</a></div><div class="ttdeci">Should compile r2 movcc movcs str strb mov lr r1 movcs movcc mov lr r1 str mov mov cmp r1 movlo r2 str bx lr r0 mov mov cmp r0 movhs r2 mov r1 bx lr Some of the NEON intrinsics may be appropriate for more general either as target independent intrinsics or perhaps elsewhere in the ARM backend Some of them may also be lowered to target independent and perhaps some new SDNodes could be added For maximum</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2ARM_2README_8txt_source.html#l00489">README.txt:489</a></div></div>
<div class="ttc" id="alib_2Target_2README_8txt_html_a7f7d2a575673bdb5b7844688b75bc664"><div class="ttname"><a href="lib_2Target_2README_8txt.html#a7f7d2a575673bdb5b7844688b75bc664">false</a></div><div class="ttdeci">Clang compiles this i1 false</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2README_8txt_source.html#l00505">README.txt:505</a></div></div>
<div class="ttc" id="alib_2Target_2X86_2README_8txt_html_ac41057b8cda493c88cc5c07fb75234de"><div class="ttname"><a href="lib_2Target_2X86_2README_8txt.html#ac41057b8cda493c88cc5c07fb75234de">setae</a></div><div class="ttdeci">_test eax xmm0 eax xmm1 comiss xmm1 setae al movzbl ecx eax edx ecx cmove eax ret Note the setae</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2X86_2README_8txt_source.html#l00210">README.txt:210</a></div></div>
<div class="ttc" id="alib_2Target_2PowerPC_2README_8txt_html_a6b82edef3e753cda0669694957b21319"><div class="ttname"><a href="lib_2Target_2PowerPC_2README_8txt.html#a6b82edef3e753cda0669694957b21319">r6</a></div><div class="ttdeci">bb420 i lbzx r7 addi r6</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2PowerPC_2README_8txt_source.html#l00040">README.txt:40</a></div></div>
<div class="ttc" id="alib_2Target_2WebAssembly_2README_8txt_html_a20a0123e18f7bce1f3636761adac949e"><div class="ttname"><a href="lib_2Target_2WebAssembly_2README_8txt.html#a20a0123e18f7bce1f3636761adac949e">emulation</a></div><div class="ttdeci">The object format emitted by the WebAssembly backed is documented see the home and packaging for producing WebAssembly applications that can run in browsers and other environments wasi sdk provides a more minimal C C SDK based on llvm and a libc based on for producing WebAssemmbly applictions that use the WASI ABI Rust provides WebAssembly support integrated into Cargo There are two main which provides a relatively minimal environment that has an emphasis on being native wasm32 unknown which uses Emscripten internally and provides standard C C filesystem emulation</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2WebAssembly_2README_8txt_source.html#l00027">README.txt:27</a></div></div>
<div class="ttc" id="alib_2Target_2ARM_2README_8txt_html_a02674d5764aac2d2106856e061309f61"><div class="ttname"><a href="lib_2Target_2ARM_2README_8txt.html#a02674d5764aac2d2106856e061309f61">_Z11no_overflowjj</a></div><div class="ttdeci">Should compile r2 movcc movcs str strb mov lr _Z11no_overflowjj</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2ARM_2README_8txt_source.html#l00457">README.txt:457</a></div></div>
<div class="ttc" id="aSILowerControlFlow_8cpp_html_a4868c5d81c5ccc98c47aeab6244346a0"><div class="ttname"><a href="SILowerControlFlow_8cpp.html#a4868c5d81c5ccc98c47aeab6244346a0">assert</a></div><div class="ttdeci">assert(ImpDefSCC.getReg()==AMDGPU::SCC &amp;&amp;ImpDefSCC.isDef())</div></div>
<div class="ttc" id="aclassStringView_html_af632623580840d68b2fcea9fd6504533"><div class="ttname"><a href="classStringView.html#af632623580840d68b2fcea9fd6504533">StringView::find</a></div><div class="ttdeci">size_t find(char C, size_t From=0) const</div><div class="ttdef"><b>Definition:</b> <a href="StringView_8h_source.html#l00048">StringView.h:48</a></div></div>
<div class="ttc" id="alib_2CodeGen_2README_8txt_html_a9b5005cb979e934f18ef800ab923c963"><div class="ttname"><a href="lib_2CodeGen_2README_8txt.html#a9b5005cb979e934f18ef800ab923c963">Still</a></div><div class="ttdeci">Common register allocation spilling lr str ldr sxth r3 ldr mla r4 can lr mov lr str ldr sxth r3 mla r4 and then merge mul and lr str ldr sxth r3 mla r4 It also increase the likelihood the store may become dead bb27 Successors according to LLVM ID Predecessors according to mbb&lt; bb27, 0x8b0a7c0 &gt; Note ADDri is not a two address instruction its result reg1037 is an operand of the PHI node in bb76 and its operand reg1039 is the result of the PHI node We should treat it as a two address code and make sure the ADDri is scheduled after any node that reads reg1039 Use info(i.e. register scavenger) to assign it a free register to allow reuse the collector could move the objects and invalidate the derived pointer This is bad enough in the first but safe points can crop up unpredictably **array_addr i32 n y store obj obj **nth_el If the i64 division is lowered to a then a safe point array and nth_el no longer point into the correct object The fix for this is to copy address calculations so that dependent pointers are never live across safe point boundaries But the loads cannot be copied like this if there was an intervening so may be hard to get right Only a concurrent mutator can trigger a collection at the libcall safe point So single threaded programs do not have this even with a copying collector Still</div><div class="ttdef"><b>Definition:</b> <a href="lib_2CodeGen_2README_8txt_source.html#l00137">README.txt:137</a></div></div>
<div class="ttc" id="alib_2Target_2X86_2README_8txt_html_a61cf8483bf6de83f6b4bcde19c08d1d1"><div class="ttname"><a href="lib_2Target_2X86_2README_8txt.html#a61cf8483bf6de83f6b4bcde19c08d1d1">tmp252253</a></div><div class="ttdeci">&lt; i32 &gt; tmp252253</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2X86_2README_8txt_source.html#l00558">README.txt:558</a></div></div>
<div class="ttc" id="alib_2Target_2X86_2README_8txt_html_ae9a0b74d51072a063c998e1cee0b856d"><div class="ttname"><a href="lib_2Target_2X86_2README_8txt.html#ae9a0b74d51072a063c998e1cee0b856d">called</a></div><div class="ttdeci">is currently compiled esp esp jne LBB1_1 esp ret esp esp jne L_abort $stub esp ret This can be applied to any no return function call that takes no arguments etc the stack save restore logic could be shrink producing something like esp jne LBB1_1 ret esp call L_abort $stub Both are useful in different situations it could be shrink wrapped and tail called</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2X86_2README_8txt_source.html#l00424">README.txt:424</a></div></div>
<div class="ttc" id="alib_2Target_2X86_2README_8txt_html_ad6a9e04ace03e64069c0e3a87c529dcc"><div class="ttname"><a href="lib_2Target_2X86_2README_8txt.html#ad6a9e04ace03e64069c0e3a87c529dcc">load</a></div><div class="ttdeci">LLVM currently emits rax rax movq rax rax ret It could narrow the loads and stores to emit rax rax movq rax rax ret The trouble is that there is a TokenFactor between the store and the load</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2X86_2README_8txt_source.html#l01531">README.txt:1531</a></div></div>
<div class="ttc" id="alib_2Target_2ARM_2README_8txt_html_ae2bb081d94f22e64ca6bc4bd58512a93"><div class="ttname"><a href="lib_2Target_2ARM_2README_8txt.html#ae2bb081d94f22e64ca6bc4bd58512a93">memcpy</a></div><div class="ttdeci">&lt;%struct.s * &gt; cast struct s *S to sbyte *&lt; sbyte * &gt; sbyte uint cast struct s *agg result to sbyte *&lt; sbyte * &gt; sbyte uint cast struct s *memtmp to sbyte *&lt; sbyte * &gt; sbyte uint ret void llc ends up issuing two memcpy or custom lower memcpy(of small size) to be ldmia/stmia. I think option 2 is better but the current register allocator cannot allocate a chunk of registers at a time. A feasible temporary solution is to use specific physical registers at the lowering time for small(&lt;</div></div>
<div class="ttc" id="alib_2Target_2X86_2README_8txt_html_a9e3993ebe32e8d52c238075fc2aa8d4e"><div class="ttname"><a href="lib_2Target_2X86_2README_8txt.html#a9e3993ebe32e8d52c238075fc2aa8d4e">fl</a></div><div class="ttdeci">fh *return fh fl</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2X86_2README_8txt_source.html#l00293">README.txt:293</a></div></div>
<div class="ttc" id="alib_2Target_2SystemZ_2README_8txt_html_aff41f78457c5b0beb8af78edab100d70"><div class="ttname"><a href="lib_2Target_2SystemZ_2README_8txt.html#aff41f78457c5b0beb8af78edab100d70">base</a></div><div class="ttdeci">therefore end up llgh r3 lr r0 br r14 but truncating the load would lh r3 br r14 Functions ret i64 and ought to be implemented ngr r0 br r14 but two address optimizations reverse the order of the AND and ngr r2 lgr r0 br r14 CodeGen SystemZ and ll has several examples of this Out of range displacements are usually handled by loading the full address into a register In many cases it would be better to create an anchor point instead E g i64 base</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2SystemZ_2README_8txt_source.html#l00125">README.txt:125</a></div></div>
<div class="ttc" id="anamespacellvm_1_1ScaledNumbers_html_a0651aa0a52c69c4fe12cf730e7ed65ab"><div class="ttname"><a href="namespacellvm_1_1ScaledNumbers.html#a0651aa0a52c69c4fe12cf730e7ed65ab">llvm::ScaledNumbers::compare</a></div><div class="ttdeci">int compare(DigitsT LDigits, int16_t LScale, DigitsT RDigits, int16_t RScale)</div><div class="ttdoc">Compare two scaled numbers.</div><div class="ttdef"><b>Definition:</b> <a href="ScaledNumber_8h_source.html#l00252">ScaledNumber.h:252</a></div></div>
<div class="ttc" id="aStraightLineStrengthReduce_8cpp_html_a7b51b9df5e7db582597e8556087c71ce"><div class="ttname"><a href="StraightLineStrengthReduce_8cpp.html#a7b51b9df5e7db582597e8556087c71ce">reduction</a></div><div class="ttdeci">Straight line strength reduction</div><div class="ttdef"><b>Definition:</b> <a href="StraightLineStrengthReduce_8cpp_source.html#l00266">StraightLineStrengthReduce.cpp:266</a></div></div>
<div class="ttc" id="alib_2Target_2X86_2README_8txt_html_a6b4dd059196129d30ac080fe959889dc"><div class="ttname"><a href="lib_2Target_2X86_2README_8txt.html#a6b4dd059196129d30ac080fe959889dc">abort_gzip</a></div><div class="ttdeci">&lt; i32 &gt; ret i32 tmp10 ecx esp je LBB0_2 eax addl eax ret edx movl eax subl eax ret There s an obviously unnecessary movl in and we could eliminate a couple more movls by putting(%esp) into %eax instead of %ecx. See rdar&lt; i1 * &gt; define fastcc void abort_gzip() noreturn nounwind</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2X86_2README_8txt_source.html#l01060">README.txt:1060</a></div></div>
<div class="ttc" id="alib_2Target_2X86_2README_8txt_html_acbd1b994302236a519fd64e889b74168"><div class="ttname"><a href="lib_2Target_2X86_2README_8txt.html#acbd1b994302236a519fd64e889b74168">removed</a></div><div class="ttdeci">currently compiles eax eax je LBB0_3 testl eax jne LBB0_4 the testl could be removed</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2X86_2README_8txt_source.html#l01552">README.txt:1552</a></div></div>
<div class="ttc" id="alib_2Target_2Sparc_2README_8txt_html_a9f97b64d7a37a7854265cd07946131c1"><div class="ttname"><a href="lib_2Target_2Sparc_2README_8txt.html#a9f97b64d7a37a7854265cd07946131c1">o6</a></div><div class="ttdeci">To do *Keep the address of the constant pool in a register instead of forming its address all of the time *We can fold small constant offsets into the hi lo references to constant pool addresses as well *When in V9 register allocate icc *[0-3] Add support for isel ing UMUL_LOHI instead of marking it as Expand *Emit the Branch on Integer Register with Prediction instructions It s not clear how to write a pattern for this int o6</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2Sparc_2README_8txt_source.html#l00026">README.txt:26</a></div></div>
<div class="ttc" id="alib_2Target_2X86_2README_8txt_html_ab5770b8366206ae045d03afb9e5c0105"><div class="ttname"><a href="lib_2Target_2X86_2README_8txt.html#ab5770b8366206ae045d03afb9e5c0105">i16</a></div><div class="ttdeci">&lt; i32 &gt; ret i32 conv5 And the following x86 eax movsbl ecx cmpl ecx sete al movzbl eax ret It should be possible to eliminate the sign extensions LLVM misses a load store narrowing opportunity in this i16</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2X86_2README_8txt_source.html#l01493">README.txt:1493</a></div></div>
<div class="ttc" id="alib_2Target_2X86_2README_8txt_html_ae0623af8f1debe2f6deaf507c4adbaf9"><div class="ttname"><a href="lib_2Target_2X86_2README_8txt.html#ae0623af8f1debe2f6deaf507c4adbaf9">slower</a></div><div class="ttdeci">Instead of the following for memset char edx edx edx It might be better to generate eax movl edx movl edx movw edx when we can spare a register It reduces code size Evaluate what the best way to codegen sdiv C is For we currently get ret i32 Y eax movl ecx ecx ecx addl eax eax ret GCC knows several different ways to codegen one of which is eax eax ecx cmovle eax eax ret which is probably slower</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2X86_2README_8txt_source.html#l00161">README.txt:161</a></div></div>
<div class="ttc" id="aREADME-SSE_8txt_html_adff055de8bac5465d2600c78402012f4"><div class="ttname"><a href="README-SSE_8txt.html#adff055de8bac5465d2600c78402012f4">edi</a></div><div class="ttdeci">into eax xorps xmm0 xmm0 eax xmm0 eax xmm0 ret esp eax movdqa xmm0 xmm0 esp const ret align it should be movdqa xmm0 edi</div><div class="ttdef"><b>Definition:</b> <a href="README-SSE_8txt_source.html#l00650">README-SSE.txt:650</a></div></div>
<div class="ttc" id="alib_2Target_2README_8txt_html_aa08809ca81b324a7ecb8582b8b01325a"><div class="ttname"><a href="lib_2Target_2README_8txt.html#aa08809ca81b324a7ecb8582b8b01325a">movq</a></div><div class="ttdeci">Clang compiles this i1 i64 store i64 i64 store i64 i64 store i64 i64 store i64 align Which gets codegen d xmm0 movaps rbp movaps rbp movaps rbp movaps rbp movq</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2README_8txt_source.html#l00521">README.txt:521</a></div></div>
<div class="ttc" id="alib_2Target_2ARM_2README_8txt_html_a90cca76dd78688687e0d697679dbc799"><div class="ttname"><a href="lib_2Target_2ARM_2README_8txt.html#a90cca76dd78688687e0d697679dbc799">B</a></div><div class="ttdeci">compiles ldr LCPI1_0 ldr ldr mov lsr tst moveq r1 ldr LCPI1_1 and r0 bx lr It would be better to do something like to fold the shift into the conditional ldr LCPI1_0 ldr ldr tst movne lsr ldr LCPI1_1 and r0 bx lr it saves an instruction and a register It might be profitable to cse MOVi16 if there are lots of bit immediates with the same bottom half Robert Muth started working on an alternate jump table implementation that does not put the tables in line in the text This is more like the llvm default jump table implementation This might be useful sometime Several revisions of patches are on the mailing beginning while CMP sets them like a subtract Therefore to be able to use CMN for comparisons other than the Z we ll need additional logic to reverse the conditionals associated with the comparison Perhaps a pseudo instruction for the with a post codegen pass to clean up and handle the condition codes See PR5694 for testcase Given the following on int B</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2ARM_2README_8txt_source.html#l00592">README.txt:592</a></div></div>
<div class="ttc" id="alib_2Support_2Unix_2README_8txt_html_a636047a61c4f9dead2a05cbb3a588ecb"><div class="ttname"><a href="lib_2Support_2Unix_2README_8txt.html#a636047a61c4f9dead2a05cbb3a588ecb">example</a></div><div class="ttdeci">llvm lib Support Unix the directory structure underneath this directory could look like only those directories actually needing to be created should be created further subdirectories could be created to reflect versions of the various standards For example</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Support_2Unix_2README_8txt_source.html#l00015">README.txt:15</a></div></div>
<div class="ttc" id="alib_2Target_2README_8txt_html_a80a694fb0f4379c31cdb69faf50a4b4a"><div class="ttname"><a href="lib_2Target_2README_8txt.html#a80a694fb0f4379c31cdb69faf50a4b4a">b1</a></div><div class="ttdeci">int b1</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2README_8txt_source.html#l00084">README.txt:84</a></div></div>
<div class="ttc" id="aSIOptimizeExecMaskingPreRA_8cpp_html_a3e47bdb3e296b00df96eff7896fa57bf"><div class="ttname"><a href="SIOptimizeExecMaskingPreRA_8cpp.html#a3e47bdb3e296b00df96eff7896fa57bf">RA</a></div><div class="ttdeci">SI optimize exec mask operations pre RA</div><div class="ttdef"><b>Definition:</b> <a href="SIOptimizeExecMaskingPreRA_8cpp_source.html#l00071">SIOptimizeExecMaskingPreRA.cpp:71</a></div></div>
<div class="ttc" id="alib_2Target_2ARM_2README_8txt_html_ab5ea3360d1fe424425a3cfafb89a0d92"><div class="ttname"><a href="lib_2Target_2ARM_2README_8txt.html#ab5ea3360d1fe424425a3cfafb89a0d92">register</a></div><div class="ttdeci">should just be implemented with a CLZ instruction Since there are other e that share this it would be best to implement this in a target independent as zero is the default value for the binary encoder e add r0 add r5 Register operands should be distinct That when the encoding does not require two syntactical operands to refer to the same register</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2ARM_2README_8txt_source.html#l00726">README.txt:726</a></div></div>
<div class="ttc" id="aAMDGPUISelDAGToDAG_8cpp_html_a1bcea9a90cf7291ab18e2df09099b9ad"><div class="ttname"><a href="AMDGPUISelDAGToDAG_8cpp.html#a1bcea9a90cf7291ab18e2df09099b9ad">isel</a></div><div class="ttdeci">amdgpu isel</div><div class="ttdef"><b>Definition:</b> <a href="AMDGPUISelDAGToDAG_8cpp_source.html#l00109">AMDGPUISelDAGToDAG.cpp:109</a></div></div>
<div class="ttc" id="aFunctionAttrs_8cpp_html_afaaa7a54f8efe730ccfb969164d51ccf"><div class="ttname"><a href="FunctionAttrs_8cpp.html#afaaa7a54f8efe730ccfb969164d51ccf">attrs</a></div><div class="ttdeci">function attrs</div><div class="ttdef"><b>Definition:</b> <a href="FunctionAttrs_8cpp_source.html#l01851">FunctionAttrs.cpp:1851</a></div></div>
<div class="ttc" id="alib_2Target_2README_8txt_html_a00fbe120dd0ce034b4a84296fe00f63b"><div class="ttname"><a href="lib_2Target_2README_8txt.html#a00fbe120dd0ce034b4a84296fe00f63b">also</a></div><div class="ttdeci">Doing so could allow SROA of the destination pointers See also</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2README_8txt_source.html#l00166">README.txt:166</a></div></div>
<div class="ttc" id="anamespaceshuffles_html_a7cade9676084608ac3d3e68dcecbf95a"><div class="ttname"><a href="namespaceshuffles.html#a7cade9676084608ac3d3e68dcecbf95a">shuffles::hi</a></div><div class="ttdeci">ArrayRef&lt; int &gt; hi(ArrayRef&lt; int &gt; Vuu)</div><div class="ttdef"><b>Definition:</b> <a href="HexagonISelDAGToDAGHVX_8cpp_source.html#l00814">HexagonISelDAGToDAGHVX.cpp:814</a></div></div>
<div class="ttc" id="aExpandLargeFpConvert_8cpp_html_a8ede31e560f002894d3cafea50fc7a42"><div class="ttname"><a href="ExpandLargeFpConvert_8cpp.html#a8ede31e560f002894d3cafea50fc7a42">convert</a></div><div class="ttdeci">expand large fp convert</div><div class="ttdef"><b>Definition:</b> <a href="ExpandLargeFpConvert_8cpp_source.html#l00659">ExpandLargeFpConvert.cpp:659</a></div></div>
<div class="ttc" id="alib_2Target_2PowerPC_2README_8txt_html_a55a6cebc8f78e3b3a2bd5b14ebe2c6e2"><div class="ttname"><a href="lib_2Target_2PowerPC_2README_8txt.html#a55a6cebc8f78e3b3a2bd5b14ebe2c6e2">LBB1_84</a></div><div class="ttdeci">rlwinm add r4 b LBB1_84</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2PowerPC_2README_8txt_source.html#l00037">README.txt:37</a></div></div>
<div class="ttc" id="alib_2Target_2X86_2README_8txt_html_a969c5a3a8768b68fa5590a74945c8a2d"><div class="ttname"><a href="lib_2Target_2X86_2README_8txt.html#a969c5a3a8768b68fa5590a74945c8a2d">xmm3</a></div><div class="ttdeci">gets compiled into this on rsp movaps rsp movaps rsp movaps rsp movaps rsp movaps xmm3</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2X86_2README_8txt_source.html#l01119">README.txt:1119</a></div></div>
<div class="ttc" id="aLazyValueInfo_8cpp_html_add11cb1bc38847ce70e526af765dcce7"><div class="ttname"><a href="LazyValueInfo_8cpp.html#add11cb1bc38847ce70e526af765dcce7">info</a></div><div class="ttdeci">lazy value info</div><div class="ttdef"><b>Definition:</b> <a href="LazyValueInfo_8cpp_source.html#l00058">LazyValueInfo.cpp:58</a></div></div>
<div class="ttc" id="aREADME-SSE_8txt_html_a07c9d568a9ec7929a526f2b6753b764f"><div class="ttname"><a href="README-SSE_8txt.html#a07c9d568a9ec7929a526f2b6753b764f">gcc</a></div><div class="ttdeci">into eax xorps xmm0 xmm0 eax xmm0 eax xmm0 ret gcc</div><div class="ttdef"><b>Definition:</b> <a href="README-SSE_8txt_source.html#l00630">README-SSE.txt:630</a></div></div>
<div class="ttc" id="anamespacellvm_1_1PatternMatch_html_a24bca8838396aa81b87de8e7ac774b19"><div class="ttname"><a href="namespacellvm_1_1PatternMatch.html#a24bca8838396aa81b87de8e7ac774b19">llvm::PatternMatch::m_Value</a></div><div class="ttdeci">class_match&lt; Value &gt; m_Value()</div><div class="ttdoc">Match an arbitrary value and ignore it.</div><div class="ttdef"><b>Definition:</b> <a href="PatternMatch_8h_source.html#l00076">PatternMatch.h:76</a></div></div>
<div class="ttc" id="alib_2Target_2X86_2README_8txt_html_a6a5733f13d5be11c953d4f3c99c418a6"><div class="ttname"><a href="lib_2Target_2X86_2README_8txt.html#a6a5733f13d5be11c953d4f3c99c418a6">clearbit</a></div><div class="ttdeci">void clearbit(int *target, int bit)</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2X86_2README_8txt_source.html#l00111">README.txt:111</a></div></div>
<div class="ttc" id="anamespacellvm_1_1sys_1_1fs_html_a921e0b01f22f9a37012450f9b5f0ccb7"><div class="ttname"><a href="namespacellvm_1_1sys_1_1fs.html#a921e0b01f22f9a37012450f9b5f0ccb7">llvm::sys::fs::remove</a></div><div class="ttdeci">std::error_code remove(const Twine &amp;path, bool IgnoreNonExisting=true)</div><div class="ttdoc">Remove path.</div></div>
<div class="ttc" id="anamespacellvm_1_1MSP430Attrs_html_ac4bcc6f1a5cb5507e75bfef0838487db"><div class="ttname"><a href="namespacellvm_1_1MSP430Attrs.html#ac4bcc6f1a5cb5507e75bfef0838487db">llvm::MSP430Attrs::ISA</a></div><div class="ttdeci">ISA</div><div class="ttdef"><b>Definition:</b> <a href="MSP430Attributes_8h_source.html#l00036">MSP430Attributes.h:36</a></div></div>
<div class="ttc" id="alib_2Target_2X86_2README_8txt_html_a2407093da57a63d818ea3e962c7222a2"><div class="ttname"><a href="lib_2Target_2X86_2README_8txt.html#a2407093da57a63d818ea3e962c7222a2">rdx</a></div><div class="ttdeci">gets compiled into this on rsp movaps rsp movaps rsp movaps rsp movaps rsp movaps rsp movaps rsp movaps rsp movaps rsp movq rsp movq rsp movq rsp movq rdx</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2X86_2README_8txt_source.html#l01126">README.txt:1126</a></div></div>
<div class="ttc" id="aGVNSink_8cpp_html_a947112d0f5a5fc2abebffb587153f200"><div class="ttname"><a href="GVNSink_8cpp.html#a947112d0f5a5fc2abebffb587153f200">sink</a></div><div class="ttdeci">gvn sink</div><div class="ttdoc">When an instruction is found to only be used outside of the loop, this function moves it to the exit ...</div><div class="ttdef"><b>Definition:</b> <a href="GVNSink_8cpp_source.html#l00927">GVNSink.cpp:927</a></div></div>
<div class="ttc" id="ainclude_2llvm_2Demangle_2README_8txt_html_aff67cf4f42ea16083cc079c66f39eb85"><div class="ttname"><a href="include_2llvm_2Demangle_2README_8txt.html#aff67cf4f42ea16083cc079c66f39eb85">__cxa_demangle</a></div><div class="ttdeci">Itanium Name Demangler i e convert the string _Z1fv into and both[sub] projects need to demangle but neither can depend on each other *libcxxabi needs the demangler to implement __cxa_demangle</div><div class="ttdef"><b>Definition:</b> <a href="include_2llvm_2Demangle_2README_8txt_source.html#l00022">README.txt:22</a></div></div>
<div class="ttc" id="alib_2Target_2PowerPC_2README_8txt_html_ac192a3b2540e95fa9495953a813d3c64"><div class="ttname"><a href="lib_2Target_2PowerPC_2README_8txt.html#ac192a3b2540e95fa9495953a813d3c64">Ick</a></div><div class="ttdeci">rlwinm add r4 Ick</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2PowerPC_2README_8txt_source.html#l00032">README.txt:32</a></div></div>
<div class="ttc" id="alib_2Target_2ARM_2README_8txt_html_a9113792ca2cec3e530e7ef0d1f613d22"><div class="ttname"><a href="lib_2Target_2ARM_2README_8txt.html#a9113792ca2cec3e530e7ef0d1f613d22">r7</a></div><div class="ttdeci">add r7</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2ARM_2README_8txt_source.html#l00194">README.txt:194</a></div></div>
<div class="ttc" id="alib_2Target_2X86_2README_8txt_html_ad16a5bab6abc21d58319f5bbae3522ce"><div class="ttname"><a href="lib_2Target_2X86_2README_8txt.html#ad16a5bab6abc21d58319f5bbae3522ce">r9</a></div><div class="ttdeci">gets compiled into this on rsp movaps rsp movaps rsp movaps rsp movaps rsp movaps rsp movaps rsp movaps rsp movaps rsp movq r9</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2X86_2README_8txt_source.html#l01123">README.txt:1123</a></div></div>
<div class="ttc" id="alib_2Target_2README_8txt_html_a8769b43ff252f5965471b7e3c4554bdc"><div class="ttname"><a href="lib_2Target_2README_8txt.html#a8769b43ff252f5965471b7e3c4554bdc">Control</a></div><div class="ttdeci">bool Control</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2README_8txt_source.html#l00468">README.txt:468</a></div></div>
<div class="ttc" id="anamespacellvm_html_a57f2ca0e57f4f7b13f56f9aa16af3e0d"><div class="ttname"><a href="namespacellvm.html#a57f2ca0e57f4f7b13f56f9aa16af3e0d">llvm::min</a></div><div class="ttdeci">Expected&lt; ExpressionValue &gt; min(const ExpressionValue &amp;Lhs, const ExpressionValue &amp;Rhs)</div><div class="ttdef"><b>Definition:</b> <a href="FileCheck_8cpp_source.html#l00357">FileCheck.cpp:357</a></div></div>
<div class="ttc" id="aREADME-SSE_8txt_html_a18d36b4a92c6ff6f001363ae248165d6"><div class="ttname"><a href="README-SSE_8txt.html#a18d36b4a92c6ff6f001363ae248165d6">elements</a></div><div class="ttdeci">This compiles xmm1 mulss xmm1 xorps xmm0 movss xmm0 ret Because mulss doesn t modify the top elements</div><div class="ttdef"><b>Definition:</b> <a href="README-SSE_8txt_source.html#l00221">README-SSE.txt:221</a></div></div>
<div class="ttc" id="aBasicBlockSections_8cpp_html_a5fd0741d696f28faf65b33f6c6af8fda"><div class="ttname"><a href="BasicBlockSections_8cpp.html#a5fd0741d696f28faf65b33f6c6af8fda">Cond</a></div><div class="ttdeci">SmallVector&lt; MachineOperand, 4 &gt; Cond</div><div class="ttdef"><b>Definition:</b> <a href="BasicBlockSections_8cpp_source.html#l00137">BasicBlockSections.cpp:137</a></div></div>
<div class="ttc" id="alib_2Target_2X86_2README_8txt_html_a7be0f11e03983f0479d6810c99eff54c"><div class="ttname"><a href="lib_2Target_2X86_2README_8txt.html#a7be0f11e03983f0479d6810c99eff54c">esp</a></div><div class="ttdeci">We currently emits esp</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2X86_2README_8txt_source.html#l00235">README.txt:235</a></div></div>
<div class="ttc" id="alib_2Analysis_2README_8txt_html_ad5ccdce1179bbfb942a084b3005f360d"><div class="ttname"><a href="lib_2Analysis_2README_8txt.html#ad5ccdce1179bbfb942a084b3005f360d">this</a></div><div class="ttdeci">Analysis the ScalarEvolution expression for r is this</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Analysis_2README_8txt_source.html#l00008">README.txt:8</a></div></div>
<div class="ttc" id="alib_2Target_2ARM_2README_8txt_html_a1a7a4503996d300df70ca643d1511cd3"><div class="ttname"><a href="lib_2Target_2ARM_2README_8txt.html#a1a7a4503996d300df70ca643d1511cd3">list</a></div><div class="ttdeci">compiles ldr LCPI1_0 ldr ldr mov lsr tst moveq r1 ldr LCPI1_1 and r0 bx lr It would be better to do something like to fold the shift into the conditional ldr LCPI1_0 ldr ldr tst movne lsr ldr LCPI1_1 and r0 bx lr it saves an instruction and a register It might be profitable to cse MOVi16 if there are lots of bit immediates with the same bottom half Robert Muth started working on an alternate jump table implementation that does not put the tables in line in the text This is more like the llvm default jump table implementation This might be useful sometime Several revisions of patches are on the mailing list</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2ARM_2README_8txt_source.html#l00568">README.txt:568</a></div></div>
<div class="ttc" id="aSparcISelLowering_8cpp_html_ad6539bf0f1a9d3264ca7797741a5fbe6"><div class="ttname"><a href="SparcISelLowering_8cpp.html#ad6539bf0f1a9d3264ca7797741a5fbe6">LowerSELECT_CC</a></div><div class="ttdeci">static SDValue LowerSELECT_CC(SDValue Op, SelectionDAG &amp;DAG, const SparcTargetLowering &amp;TLI, bool hasHardQuad, bool isV9, bool is64Bit)</div><div class="ttdef"><b>Definition:</b> <a href="SparcISelLowering_8cpp_source.html#l02626">SparcISelLowering.cpp:2626</a></div></div>
<div class="ttc" id="aclassStringView_html_a45dbb689c358805d44b8ce233582fa95"><div class="ttname"><a href="classStringView.html#a45dbb689c358805d44b8ce233582fa95">StringView::startsWith</a></div><div class="ttdeci">bool startsWith(char C) const</div><div class="ttdef"><b>Definition:</b> <a href="StringView_8h_source.html#l00099">StringView.h:99</a></div></div>
<div class="ttc" id="alib_2Target_2X86_2README_8txt_html_ae1268e7601b73d11a7237fc33631a6e6"><div class="ttname"><a href="lib_2Target_2X86_2README_8txt.html#ae1268e7601b73d11a7237fc33631a6e6">cl</a></div><div class="ttdeci">http eax xorl edx cl sete al setne dl sall cl</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2X86_2README_8txt_source.html#l00025">README.txt:25</a></div></div>
<div class="ttc" id="alib_2Target_2README_8txt_html_a47c3c3f28b3f34ef89e761593602dfe0"><div class="ttname"><a href="lib_2Target_2README_8txt.html#a47c3c3f28b3f34ef89e761593602dfe0">m_HotKey</a></div><div class="ttdeci">THotKey m_HotKey</div></div>
<div class="ttc" id="alib_2Target_2WebAssembly_2README_8txt_html_a7eb7b74d135146f99e3fe5cc36f0f7cf"><div class="ttname"><a href="lib_2Target_2WebAssembly_2README_8txt.html#a7eb7b74d135146f99e3fe5cc36f0f7cf">libraries</a></div><div class="ttdeci">The object format emitted by the WebAssembly backed is documented see the home and packaging for producing WebAssembly applications that can run in browsers and other environments wasi sdk provides a more minimal C C SDK based on llvm and a libc based on for producing WebAssemmbly applictions that use the WASI ABI Rust provides WebAssembly support integrated into Cargo There are two main which provides a relatively minimal environment that has an emphasis on being native wasm32 unknown which uses Emscripten internally and provides standard C C libraries</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2WebAssembly_2README_8txt_source.html#l00027">README.txt:27</a></div></div>
<div class="ttc" id="alib_2Target_2X86_2README_8txt_html_acdf0d67d85b95f2fa5cf0e7aba10409e"><div class="ttname"><a href="lib_2Target_2X86_2README_8txt.html#acdf0d67d85b95f2fa5cf0e7aba10409e">add</a></div><div class="ttdeci">we currently eax ecx subl eax ret We would use one fewer register if codegen d eax neg eax add</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2X86_2README_8txt_source.html#l00454">README.txt:454</a></div></div>
<div class="ttc" id="alib_2Target_2README_8txt_html_ab74ee16f117623214b4f784a358e207a"><div class="ttname"><a href="lib_2Target_2README_8txt.html#ab74ee16f117623214b4f784a358e207a">rotates</a></div><div class="ttdeci">The same transformation can work with an even modulo with the addition of a and shrink the compare RHS by the same amount Unless the target supports rotates</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2README_8txt_source.html#l00681">README.txt:681</a></div></div>
<div class="ttc" id="aREADME__ALTIVEC_8txt_html_a015846b6188ce15e08cd94c74a9df1a3"><div class="ttname"><a href="README__ALTIVEC_8txt.html#a015846b6188ce15e08cd94c74a9df1a3">A</a></div><div class="ttdeci">* A</div><div class="ttdef"><b>Definition:</b> <a href="README__ALTIVEC_8txt_source.html#l00089">README_ALTIVEC.txt:89</a></div></div>
<div class="ttc" id="aclassStringView_html_a359fe9ffc3eb7a64aa6f42aa8d373151"><div class="ttname"><a href="classStringView.html#a359fe9ffc3eb7a64aa6f42aa8d373151">StringView::front</a></div><div class="ttdeci">char front() const</div><div class="ttdef"><b>Definition:</b> <a href="StringView_8h_source.html#l00070">StringView.h:70</a></div></div>
<div class="ttc" id="anamespacellvm_1_1binaryformat_html_ab355a2b14b4cc35373b4526fbfab894da80eaeeee65cce2c1b9fa9a5741956f9a"><div class="ttname"><a href="namespacellvm_1_1binaryformat.html#ab355a2b14b4cc35373b4526fbfab894da80eaeeee65cce2c1b9fa9a5741956f9a">llvm::binaryformat::unknown</a></div><div class="ttdeci">@ unknown</div><div class="ttdef"><b>Definition:</b> <a href="Swift_8h_source.html#l00018">Swift.h:18</a></div></div>
<div class="ttc" id="aREADME__ALTIVEC_8txt_html_a3b54c55bd8a7121b30fc06cc567afcf0"><div class="ttname"><a href="README__ALTIVEC_8txt.html#a3b54c55bd8a7121b30fc06cc567afcf0">instruction</a></div><div class="ttdeci">Since we know that Vector is byte aligned and we know the element offset of we should change the load into a lve *x instruction</div><div class="ttdef"><b>Definition:</b> <a href="README__ALTIVEC_8txt_source.html#l00037">README_ALTIVEC.txt:37</a></div></div>
<div class="ttc" id="aREADME-SSE_8txt_html_a10b70cdd8ae9a200f1682767e2229b8b"><div class="ttname"><a href="README-SSE_8txt.html#a10b70cdd8ae9a200f1682767e2229b8b">lowered</a></div><div class="ttdeci">into xmm2 addss xmm2 xmm1 xmm3 addss xmm3 movaps xmm0 unpcklps xmm0 ret seems silly when it could just be one addps Expand libm rounding functions main should enable SSE DAZ mode and other fast SSE modes Think about doing i64 math in SSE regs on x86 This testcase should have no SSE instructions in and only one load from a constant double ret double C the select is being lowered</div><div class="ttdef"><b>Definition:</b> <a href="README-SSE_8txt_source.html#l00089">README-SSE.txt:89</a></div></div>
<div class="ttc" id="aADT_2tmp_8txt_html_aeffe8a8a944079cca957cea094c84819"><div class="ttname"><a href="ADT_2tmp_8txt.html#aeffe8a8a944079cca957cea094c84819">bits</a></div><div class="ttdeci">Class for arbitrary precision integers APInt is a functional replacement for common case unsigned integer type like unsigned long or but also allows non byte width integer sizes and large integer value types such as bits</div><div class="ttdef"><b>Definition:</b> <a href="ADT_2tmp_8txt_source.html#l00001">tmp.txt:1</a></div></div>
<div class="ttc" id="alib_2Target_2ARM_2README_8txt_html_a1b45f45820a60c09244a87eb59824aec"><div class="ttname"><a href="lib_2Target_2ARM_2README_8txt.html#a1b45f45820a60c09244a87eb59824aec">S</a></div><div class="ttdeci">add sub stmia L5 ldr r0 bl L_printf $stub Instead of a and a wouldn t it be better to do three moves *Return an aggregate type is even return S</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2ARM_2README_8txt_source.html#l00210">README.txt:210</a></div></div>
<div class="ttc" id="aREADME-FPStack_8txt_html_aeb9a134c2755c0ad7801bf630a790904"><div class="ttname"><a href="README-FPStack_8txt.html#aeb9a134c2755c0ad7801bf630a790904">trunc</a></div><div class="ttdeci">We have fiadd patterns now but the followings have the same cost and complexity We need a way to specify the later is more profitable def def The FP stackifier should handle simple permutates to reduce number of shuffle e g trunc</div><div class="ttdef"><b>Definition:</b> <a href="README-FPStack_8txt_source.html#l00063">README-FPStack.txt:63</a></div></div>
<div class="ttc" id="alib_2Support_2Unix_2README_8txt_html_a410af5b575104e0ef992b86ca94fa569"><div class="ttname"><a href="lib_2Support_2Unix_2README_8txt.html#a410af5b575104e0ef992b86ca94fa569">v2</a></div><div class="ttdeci">llvm lib Support Unix the directory structure underneath this directory could look like only those directories actually needing to be created should be created further subdirectories could be created to reflect versions of the various standards For under SUS there could be v2</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Support_2Unix_2README_8txt_source.html#l00015">README.txt:15</a></div></div>
<div class="ttc" id="alib_2Target_2X86_2README_8txt_html_a4e68cc5e0092b9f32b3d57ffc73ba947"><div class="ttname"><a href="lib_2Target_2X86_2README_8txt.html#a4e68cc5e0092b9f32b3d57ffc73ba947">bb7</a></div><div class="ttdeci">&lt; i1 &gt; br i1 label bb7</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2X86_2README_8txt_source.html#l00976">README.txt:976</a></div></div>
<div class="ttc" id="alib_2Target_2X86_2README_8txt_html_adbcd470b5e5a9cc475f1bc60ea3582a0"><div class="ttname"><a href="lib_2Target_2X86_2README_8txt.html#adbcd470b5e5a9cc475f1bc60ea3582a0">LBB1_3</a></div><div class="ttdeci">For the entry BB esp pxor xmm0 xmm1 ucomisd xmm1 setnp al sete cl testb al jne LBB1_5 xmm2 cvtss2sd xmm3 ucomisd xmm0 ja LBB1_3 xmm2 LBB1_3</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2X86_2README_8txt_source.html#l00521">README.txt:521</a></div></div>
<div class="ttc" id="alib_2CodeGen_2README_8txt_html_a37b703060219534badc7e9e41ef240f0"><div class="ttname"><a href="lib_2CodeGen_2README_8txt.html#a37b703060219534badc7e9e41ef240f0">Consider</a></div><div class="ttdeci">Common register allocation spilling lr str ldr sxth r3 ldr mla r4 can lr mov lr str ldr sxth r3 mla r4 and then merge mul and lr str ldr sxth r3 mla r4 It also increase the likelihood the store may become dead bb27 Successors according to LLVM ID Predecessors according to mbb&lt; bb27, 0x8b0a7c0 &gt; Note ADDri is not a two address instruction its result reg1037 is an operand of the PHI node in bb76 and its operand reg1039 is the result of the PHI node We should treat it as a two address code and make sure the ADDri is scheduled after any node that reads reg1039 Use info(i.e. register scavenger) to assign it a free register to allow reuse the collector could move the objects and invalidate the derived pointer This is bad enough in the first but safe points can crop up unpredictably Consider</div><div class="ttdef"><b>Definition:</b> <a href="lib_2CodeGen_2README_8txt_source.html#l00121">README.txt:121</a></div></div>
<div class="ttc" id="alib_2Target_2X86_2README_8txt_html_ac2b15b507a33298ecf7ad382b6558a9b"><div class="ttname"><a href="lib_2Target_2X86_2README_8txt.html#ac2b15b507a33298ecf7ad382b6558a9b">it</a></div><div class="ttdeci">Instead of the following for memset char edx edx edx It might be better to generate eax movl edx movl edx movw edx when we can spare a register It reduces code size Evaluate what the best way to codegen sdiv C is For we currently get ret i32 Y eax movl ecx ecx ecx addl eax eax ret GCC knows several different ways to codegen it</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2X86_2README_8txt_source.html#l00151">README.txt:151</a></div></div>
<div class="ttc" id="anamespacellvm_html_a66f0c57e04037076030c6a6e48f44f2d"><div class="ttname"><a href="namespacellvm.html#a66f0c57e04037076030c6a6e48f44f2d">llvm::format</a></div><div class="ttdeci">format_object&lt; Ts... &gt; format(const char *Fmt, const Ts &amp;... Vals)</div><div class="ttdoc">These are helper functions used to produce formatted output.</div><div class="ttdef"><b>Definition:</b> <a href="Format_8h_source.html#l00124">Format.h:124</a></div></div>
<div class="ttc" id="alib_2Target_2X86_2README_8txt_html_a35b4e9931514f0279aa86d42fbf42ccb"><div class="ttname"><a href="lib_2Target_2X86_2README_8txt.html#a35b4e9931514f0279aa86d42fbf42ccb">xor</a></div><div class="ttdeci">We currently generate a but we really shouldn eax ecx xorl edx divl ecx eax divl ecx movl eax ret A similar code sequence works for division We currently compile i32 v2 eax eax jo LBB1_2 xor</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2X86_2README_8txt_source.html#l01271">README.txt:1271</a></div></div>
<div class="ttc" id="alib_2Target_2X86_2README_8txt_html_a0ca94266a811ff55df09da8fa875d42a"><div class="ttname"><a href="lib_2Target_2X86_2README_8txt.html#a0ca94266a811ff55df09da8fa875d42a">tmp254</a></div><div class="ttdeci">&lt; i32 &gt; tmp254</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2X86_2README_8txt_source.html#l00559">README.txt:559</a></div></div>
<div class="ttc" id="alib_2Target_2README_8txt_html_a7df6ed7588301267782c2bd4b7f6899d"><div class="ttname"><a href="lib_2Target_2README_8txt.html#a7df6ed7588301267782c2bd4b7f6899d">for</a></div><div class="ttdeci">this could be done in SelectionDAGISel along with other special for</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2README_8txt_source.html#l00104">README.txt:104</a></div></div>
<div class="ttc" id="alib_2Target_2ARM_2README_8txt_html_a80b901cd4dec078ef8dc85ec1a3bb9e4"><div class="ttname"><a href="lib_2Target_2ARM_2README_8txt.html#a80b901cd4dec078ef8dc85ec1a3bb9e4">pc</a></div><div class="ttdeci">add sub stmia L5 ldr pc</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2ARM_2README_8txt_source.html#l00201">README.txt:201</a></div></div>
<div class="ttc" id="alib_2Target_2X86_2README_8txt_html_a5ebf2994defcfc145e2f141ea860743d"><div class="ttname"><a href="lib_2Target_2X86_2README_8txt.html#a5ebf2994defcfc145e2f141ea860743d">sarl</a></div><div class="ttdeci">Instead of the following for memset char edx edx edx It might be better to generate eax movl edx movl edx movw edx when we can spare a register It reduces code size Evaluate what the best way to codegen sdiv C is For we currently get ret i32 Y eax movl ecx sarl</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2X86_2README_8txt_source.html#l00145">README.txt:145</a></div></div>
<div class="ttc" id="alib_2Target_2X86_2README_8txt_html_a3afe07893a2a13c049f7cfed5f73ef9d"><div class="ttname"><a href="lib_2Target_2X86_2README_8txt.html#a3afe07893a2a13c049f7cfed5f73ef9d">addq</a></div><div class="ttdeci">gets compiled into this on rsp movaps rsp movaps rsp movaps rsp movaps rsp movaps rsp movaps rsp movaps rsp movaps rsp movq rsp movq rsp movq rsp movq rsp movq rsp rax movq rsp rax movq rsp rsp rsp eax eax jbe LBB1_3 rcx rax movq rsp eax addq</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2X86_2README_8txt_source.html#l01143">README.txt:1143</a></div></div>
<div class="ttc" id="alib_2Target_2ARM_2README_8txt_html_a46e498e9b70d8cac397bcbb09510c615"><div class="ttname"><a href="lib_2Target_2ARM_2README_8txt.html#a46e498e9b70d8cac397bcbb09510c615">not</a></div><div class="ttdeci">Should compile r2 movcc movcs str strb mov lr r1 movcs movcc mov lr not</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2ARM_2README_8txt_source.html#l00465">README.txt:465</a></div></div>
<div class="ttc" id="alib_2Target_2ARM_2README_8txt_html_a3dc46d5697a6ce5ece766029b023eb6d"><div class="ttname"><a href="lib_2Target_2ARM_2README_8txt.html#a3dc46d5697a6ce5ece766029b023eb6d">well</a></div><div class="ttdeci">llvm ldr ldrb ldrh str strh strb strb gcc and possibly speed as well(we don 't have a good way to measure on ARM). *Consider this silly example</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2ARM_2README_8txt_source.html#l00138">README.txt:138</a></div></div>
<div class="ttc" id="anamespacellvm_1_1RISCVISD_html_ab68e2d65ea9915ffaac8334a3b8bf882ad8f9bb8ceb4f932d54869e57d152f526"><div class="ttname"><a href="namespacellvm_1_1RISCVISD.html#ab68e2d65ea9915ffaac8334a3b8bf882ad8f9bb8ceb4f932d54869e57d152f526">llvm::RISCVISD::LA</a></div><div class="ttdeci">@ LA</div><div class="ttdef"><b>Definition:</b> <a href="RISCVISelLowering_8h_source.html#l00337">RISCVISelLowering.h:337</a></div></div>
<div class="ttc" id="alib_2Target_2X86_2README_8txt_html_a115261e730f097d0f23d72326fbbe67f"><div class="ttname"><a href="lib_2Target_2X86_2README_8txt.html#a115261e730f097d0f23d72326fbbe67f">t1</a></div><div class="ttdeci">&lt;%struct.bf ** &gt; define void t1() nounwind ssp</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2X86_2README_8txt_source.html#l01497">README.txt:1497</a></div></div>
<div class="ttc" id="aPoisonChecking_8cpp_html_a702ebb77e7ff7f0a10a1b4690d8ecfc8"><div class="ttname"><a href="PoisonChecking_8cpp.html#a702ebb77e7ff7f0a10a1b4690d8ecfc8">rewrite</a></div><div class="ttdeci">static bool rewrite(Function &amp;F)</div><div class="ttdef"><b>Definition:</b> <a href="PoisonChecking_8cpp_source.html#l00255">PoisonChecking.cpp:255</a></div></div>
<div class="ttc" id="anamespacellvm_1_1pdb_html_a434cfa04e4ed34b7a901378557d4ca9ea94b04abec1ca9dfc26d182145a2ff9de"><div class="ttname"><a href="namespacellvm_1_1pdb.html#a434cfa04e4ed34b7a901378557d4ca9ea94b04abec1ca9dfc26d182145a2ff9de">llvm::pdb::Single</a></div><div class="ttdeci">@ Single</div><div class="ttdef"><b>Definition:</b> <a href="PDBTypes_8h_source.html#l00401">PDBTypes.h:401</a></div></div>
<div class="ttc" id="alib_2Target_2ARM_2README_8txt_html_ac9fd45f4cffd55a5adfc964b8858d794"><div class="ttname"><a href="lib_2Target_2ARM_2README_8txt.html#ac9fd45f4cffd55a5adfc964b8858d794">sp</a></div><div class="ttdeci">_bar sp</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2ARM_2README_8txt_source.html#l00151">README.txt:151</a></div></div>
<div class="ttc" id="aREADME__P9_8txt_html_a48a66d2f34e46f271843b6cfe41bef0a"><div class="ttname"><a href="README__P9_8txt.html#a48a66d2f34e46f271843b6cfe41bef0a">$src</a></div><div class="ttdeci">So we should use XX3Form_Rcr to implement intrinsic Convert DP outs ins xscvdpsp No builtin are required Round &amp;Convert QP DP(dword[1] is set to zero) No builtin are required Round to Quad Precision because you need to assign rounding mode in instruction Provide builtin(set f128:$vT,(int_ppc_vsx_xsrqpi f128:$vB))(set f128 yields&lt; n x&lt; ty &gt; &gt;&lt; result &gt; yields&lt; ty &gt;&lt; result &gt; No builtin are required Load Store load store see def memrix16 in PPCInstrInfo td Load Store Vector load store outs ins lxsdx $src</div><div class="ttdef"><b>Definition:</b> <a href="README__P9_8txt_source.html#l00512">README_P9.txt:512</a></div></div>
<div class="ttc" id="alib_2Target_2X86_2README_8txt_html_aa7ee9f9a5548ee69684acad8dbd3df18"><div class="ttname"><a href="lib_2Target_2X86_2README_8txt.html#aa7ee9f9a5548ee69684acad8dbd3df18">movswl</a></div><div class="ttdeci">&lt; i32 &gt; br label bb114 eax ecx movl ebp subl ebp movswl(%ebp)</div></div>
<div class="ttc" id="anamespaceFIXME_html_ab540b4225b27525c895776ad9350e729"><div class="ttname"><a href="namespaceFIXME.html#ab540b4225b27525c895776ad9350e729">FIXME::unit</a></div><div class="ttdeci">unit</div><div class="ttdef"><b>Definition:</b> <a href="include_2llvm_2Demangle_2README_8txt_source.html#l00055">README.txt:55</a></div></div>
<div class="ttc" id="alib_2CodeGen_2README_8txt_html_a82c84340651b7249e408f61be003356f"><div class="ttname"><a href="lib_2CodeGen_2README_8txt.html#a82c84340651b7249e408f61be003356f">CFG</a></div><div class="ttdeci">Common register allocation spilling lr str ldr sxth r3 ldr mla r4 can lr mov lr str ldr sxth r3 mla r4 and then merge mul and lr str ldr sxth r3 mla r4 It also increase the likelihood the store may become dead bb27 Successors according to CFG</div><div class="ttdef"><b>Definition:</b> <a href="lib_2CodeGen_2README_8txt_source.html#l00039">README.txt:39</a></div></div>
<div class="ttc" id="aREADME-SSE_8txt_html_a489a33a25e00e1000eae3b54c9c548b1"><div class="ttname"><a href="README-SSE_8txt.html#a489a33a25e00e1000eae3b54c9c548b1">Testcase</a></div><div class="ttdeci">the custom lowered code happens to be but we shouldn t have to custom lower anything This is probably related to&lt; 2 x i64 &gt; ops being so bad LLVM currently generates stack realignment when it is not necessary needed The problem is that we need to know about stack alignment too before RA runs At that point we don t whether there will be vector or not Stack realignment logic is overly conservative but otherwise we can produce unaligned loads stores Fixing this will require some huge RA changes Testcase</div><div class="ttdef"><b>Definition:</b> <a href="README-SSE_8txt_source.html#l00498">README-SSE.txt:498</a></div></div>
<div class="ttc" id="alib_2CodeGen_2README_8txt_html_a2b572719b47d2cd749a70ac5587bbf7f"><div class="ttname"><a href="lib_2CodeGen_2README_8txt.html#a2b572719b47d2cd749a70ac5587bbf7f">r3</a></div><div class="ttdeci">Common register allocation spilling lr str ldr sxth r3</div><div class="ttdef"><b>Definition:</b> <a href="lib_2CodeGen_2README_8txt_source.html#l00008">README.txt:8</a></div></div>
<div class="ttc" id="aDemangleConfig_8h_html"><div class="ttname"><a href="DemangleConfig_8h.html">DemangleConfig.h</a></div></div>
<div class="ttc" id="alib_2Target_2README_8txt_html_af20951d63b0e699b207db05daa072fdb"><div class="ttname"><a href="lib_2Target_2README_8txt.html#af20951d63b0e699b207db05daa072fdb">b4</a></div><div class="ttdeci">int b4</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2README_8txt_source.html#l00084">README.txt:84</a></div></div>
<div class="ttc" id="alib_2Target_2X86_2README_8txt_html_a87b820e89af85c48d771e67b4a2becc0"><div class="ttname"><a href="lib_2Target_2X86_2README_8txt.html#a87b820e89af85c48d771e67b4a2becc0">leaq</a></div><div class="ttdeci">gets compiled into this on rsp movaps rsp movaps rsp movaps rsp movaps rsp movaps rsp movaps rsp movaps rsp movaps rsp movq rsp movq rsp movq rsp movq rsp movq rsp leaq(%rsp)</div></div>
<div class="ttc" id="alib_2Target_2ARM_2README_8txt_html_aea3124e675677949c3e7c1a2c31f4c62"><div class="ttname"><a href="lib_2Target_2ARM_2README_8txt.html#aea3124e675677949c3e7c1a2c31f4c62">better</a></div><div class="ttdeci">a mov and lsr and lsl orr lsr orr lsl orr r1 bx lr Something like the following would be better(fewer instructions/registers)</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2ARM_2README_8txt_source.html#l00623">README.txt:623</a></div></div>
<div class="ttc" id="alib_2Target_2ARM_2README_8txt_html_afa4b88db99757d588d8206e7f0783700"><div class="ttname"><a href="lib_2Target_2ARM_2README_8txt.html#afa4b88db99757d588d8206e7f0783700">possible</a></div><div class="ttdeci">the resulting code requires compare and branches when and if the revised code is with conditional branches instead of More there is a byte word extend before each where there should be only and the condition codes are not remembered when the same two values are compared twice More LSR enhancements possible</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2ARM_2README_8txt_source.html#l00410">README.txt:410</a></div></div>
<div class="ttc" id="alib_2Target_2README_8txt_html_a3a76669632041022e6976766a22bd2b0"><div class="ttname"><a href="lib_2Target_2README_8txt.html#a3a76669632041022e6976766a22bd2b0">j</a></div><div class="ttdeci">return j(j&lt;&lt; 16)</div></div>
<div class="ttc" id="anamespacellvm_1_1PPCISD_html_ad1c32e5bb1cb213fb836bc3d221e4f19aed93fe593cbca270b48f14bc00c5d73a"><div class="ttname"><a href="namespacellvm_1_1PPCISD.html#ad1c32e5bb1cb213fb836bc3d221e4f19aed93fe593cbca270b48f14bc00c5d73a">llvm::PPCISD::FSEL</a></div><div class="ttdeci">@ FSEL</div><div class="ttdoc">FSEL - Traditional three-operand fsel node.</div><div class="ttdef"><b>Definition:</b> <a href="PPCISelLowering_8h_source.html#l00053">PPCISelLowering.h:53</a></div></div>
<div class="ttc" id="alib_2Target_2README_8txt_html_a2b4cdcfbfb93dc70d4c463052111eb96"><div class="ttname"><a href="lib_2Target_2README_8txt.html#a2b4cdcfbfb93dc70d4c463052111eb96">reassoc</a></div><div class="ttdeci">into llvm powi allowing the code generator to produce balanced multiplication trees the intrinsic needs to be extended to support and second the code generator needs to be enhanced to lower these to multiplication trees Interesting testcase for add shift mul reassoc</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2README_8txt_source.html#l00061">README.txt:61</a></div></div>
<div class="ttc" id="anamespacellvm_1_1NVPTX_1_1PTXLdStInstCode_html_a91119cbee2be000c528a690252aee07ca24244a27b634ef3e256ab3c64c6fecd4"><div class="ttname"><a href="namespacellvm_1_1NVPTX_1_1PTXLdStInstCode.html#a91119cbee2be000c528a690252aee07ca24244a27b634ef3e256ab3c64c6fecd4">llvm::NVPTX::PTXLdStInstCode::V2</a></div><div class="ttdeci">@ V2</div><div class="ttdef"><b>Definition:</b> <a href="NVPTX_8h_source.html#l00124">NVPTX.h:124</a></div></div>
<div class="ttc" id="aStringView_8h_html_af54699e6e7069b1dfd9a3ea29fe822c0"><div class="ttname"><a href="StringView_8h.html#af54699e6e7069b1dfd9a3ea29fe822c0">operator==</a></div><div class="ttdeci">bool operator==(const StringView &amp;LHS, const StringView &amp;RHS)</div><div class="ttdef"><b>Definition:</b> <a href="StringView_8h_source.html#l00115">StringView.h:115</a></div></div>
<div class="ttc" id="alib_2Target_2ARM_2README_8txt_html_ab1ad6f77a1c4660d4fbc153b172aa198"><div class="ttname"><a href="lib_2Target_2ARM_2README_8txt.html#ab1ad6f77a1c4660d4fbc153b172aa198">seriously</a></div><div class="ttdeci">the resulting code requires compare and branches when and if the revised code is with conditional branches instead of More seriously</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2ARM_2README_8txt_source.html#l00400">README.txt:400</a></div></div>
<div class="ttc" id="alib_2Target_2README_8txt_html_aeaf8f4b3728e47ef43337657f3d58879"><div class="ttname"><a href="lib_2Target_2README_8txt.html#aeaf8f4b3728e47ef43337657f3d58879">tables</a></div><div class="ttdeci">we compile this esp call L1 $pb L1 esp je LBB1_2 esp ret but is currently always computed in the entry block It would be better to sink the picbase computation down into the block for the as it is the only one that uses it This happens for a lot of code with early outs Another example is loads of which are usually emitted into the entry block on targets like x86 If not used in all paths through a they should be sunk into the ones that do In this whole function isel would also handle this Investigate lowering of sparse switch statements into perfect hash tables</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2README_8txt_source.html#l00439">README.txt:439</a></div></div>
<div class="ttc" id="anamespacellvm_1_1GraphProgram_html_a0ad4685976f8c4d4a697a53fbe05d10b"><div class="ttname"><a href="namespacellvm_1_1GraphProgram.html#a0ad4685976f8c4d4a697a53fbe05d10b">llvm::GraphProgram::Name</a></div><div class="ttdeci">Name</div><div class="ttdef"><b>Definition:</b> <a href="GraphWriter_8h_source.html#l00050">GraphWriter.h:50</a></div></div>
<div class="ttc" id="anamespacestd_html"><div class="ttname"><a href="namespacestd.html">std</a></div><div class="ttdef"><b>Definition:</b> <a href="BitVector_8h_source.html#l00851">BitVector.h:851</a></div></div>
<div class="ttc" id="alib_2Target_2ARM_2README_8txt_html_a3a82232c420700208dd1b19e316558d8"><div class="ttname"><a href="lib_2Target_2ARM_2README_8txt.html#a3a82232c420700208dd1b19e316558d8">bit</a></div><div class="ttdeci">compiles ldr LCPI1_0 ldr ldr mov lsr tst moveq r1 ldr LCPI1_1 and r0 bx lr It would be better to do something like to fold the shift into the conditional ldr LCPI1_0 ldr ldr tst movne lsr ldr LCPI1_1 and r0 bx lr it saves an instruction and a register It might be profitable to cse MOVi16 if there are lots of bit immediates with the same bottom half Robert Muth started working on an alternate jump table implementation that does not put the tables in line in the text This is more like the llvm default jump table implementation This might be useful sometime Several revisions of patches are on the mailing beginning while CMP sets them like a subtract Therefore to be able to use CMN for comparisons other than the Z bit</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2ARM_2README_8txt_source.html#l00584">README.txt:584</a></div></div>
<div class="ttc" id="aclassStringView_html_a98a29f9ba7e329b7a445e17ddffeb0fa"><div class="ttname"><a href="classStringView.html#a98a29f9ba7e329b7a445e17ddffeb0fa">StringView::back</a></div><div class="ttdeci">char back() const</div><div class="ttdef"><b>Definition:</b> <a href="StringView_8h_source.html#l00075">StringView.h:75</a></div></div>
<div class="ttc" id="alib_2Target_2README_8txt_html_a468c151b353d817979d3225dc1d7658b"><div class="ttname"><a href="lib_2Target_2README_8txt.html#a468c151b353d817979d3225dc1d7658b">rotate</a></div><div class="ttdeci">The same transformation can work with an even modulo with the addition of a rotate</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2README_8txt_source.html#l00680">README.txt:680</a></div></div>
<div class="ttc" id="aREADME-SSE_8txt_html_a4240386010e8ab75256e7fd072800b1a"><div class="ttname"><a href="README-SSE_8txt.html#a4240386010e8ab75256e7fd072800b1a">can</a></div><div class="ttdeci">This might compile to this xmm1 xorps xmm0 movss xmm0 ret Now consider if the code caused xmm1 to get spilled This might produce this xmm1 movaps xmm0 movaps xmm1 movss xmm0 ret since the reload is only used by these we could fold it into the producing something like xmm1 movaps xmm0 ret saving two instructions The basic idea is that a reload from a spill can</div><div class="ttdef"><b>Definition:</b> <a href="README-SSE_8txt_source.html#l00269">README-SSE.txt:269</a></div></div>
<div class="ttc" id="alib_2Target_2README_8txt_html_af9f7a898c4a757821053e38056d9383f"><div class="ttname"><a href="lib_2Target_2README_8txt.html#af9f7a898c4a757821053e38056d9383f">or</a></div><div class="ttdeci">compiles or</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2README_8txt_source.html#l00606">README.txt:606</a></div></div>
<div class="ttc" id="alib_2Target_2PowerPC_2README_8txt_html_aa91241c8c54738377749dc47ee489e0d"><div class="ttname"><a href="lib_2Target_2PowerPC_2README_8txt.html#aa91241c8c54738377749dc47ee489e0d">get</a></div><div class="ttdeci">Should compile to something r4 addze r3 instead we get</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2PowerPC_2README_8txt_source.html#l00024">README.txt:24</a></div></div>
<div class="ttc" id="alib_2CodeGen_2README_8txt_html_afab957938f7b4a69a97f44531b1203fe"><div class="ttname"><a href="lib_2CodeGen_2README_8txt.html#afab957938f7b4a69a97f44531b1203fe">reg1037</a></div><div class="ttdeci">Common register allocation spilling lr str ldr sxth r3 ldr mla r4 can lr mov lr str ldr sxth r3 mla r4 and then merge mul and lr str ldr sxth r3 mla r4 It also increase the likelihood the store may become dead bb27 reg1037</div><div class="ttdef"><b>Definition:</b> <a href="lib_2CodeGen_2README_8txt_source.html#l00035">README.txt:35</a></div></div>
<div class="ttc" id="alib_2Target_2PowerPC_2README_8txt_html_a037c29b088beaea1d7f31c135c61b600"><div class="ttname"><a href="lib_2Target_2PowerPC_2README_8txt.html#a037c29b088beaea1d7f31c135c61b600">f1</a></div><div class="ttdeci">We f1</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2PowerPC_2README_8txt_source.html#l00076">README.txt:76</a></div></div>
<div class="ttc" id="alib_2Target_2X86_2README_8txt_html_a9a92fe6569fc3da7967a69d77cb3b409"><div class="ttname"><a href="lib_2Target_2X86_2README_8txt.html#a9a92fe6569fc3da7967a69d77cb3b409">v4i16</a></div><div class="ttdeci">def v4i16(MMX_MOVDQ2Qrr VR128:$src))&gt;</div></div>
<div class="ttc" id="aDemangleConfig_8h_html_ad82d307eb10a0e447f4b254f0af7dde7"><div class="ttname"><a href="DemangleConfig_8h.html#ad82d307eb10a0e447f4b254f0af7dde7">DEMANGLE_NAMESPACE_BEGIN</a></div><div class="ttdeci">#define DEMANGLE_NAMESPACE_BEGIN</div><div class="ttdef"><b>Definition:</b> <a href="DemangleConfig_8h_source.html#l00089">DemangleConfig.h:89</a></div></div>
<div class="ttc" id="alib_2Target_2ARM_2README_8txt_html_abe9b23dcf0695f223572e80f18310730"><div class="ttname"><a href="lib_2Target_2ARM_2README_8txt.html#abe9b23dcf0695f223572e80f18310730">armv5</a></div><div class="ttdeci">compiles ldr LCPI1_0 ldr ldr mov lsr tst moveq r1 ldr LCPI1_1 and r0 bx lr It would be better to do something like to fold the shift into the conditional ldr LCPI1_0 ldr ldr tst movne lsr ldr LCPI1_1 and r0 bx lr it saves an instruction and a register It might be profitable to cse MOVi16 if there are lots of bit immediates with the same bottom half Robert Muth started working on an alternate jump table implementation that does not put the tables in line in the text This is more like the llvm default jump table implementation This might be useful sometime Several revisions of patches are on the mailing beginning while CMP sets them like a subtract Therefore to be able to use CMN for comparisons other than the Z we ll need additional logic to reverse the conditionals associated with the comparison Perhaps a pseudo instruction for the with a post codegen pass to clean up and handle the condition codes See PR5694 for testcase Given the following on armv5</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2ARM_2README_8txt_source.html#l00592">README.txt:592</a></div></div>
<div class="ttc" id="alib_2Support_2Unix_2README_8txt_html_a93f73fbf80832b23e9014c6ebdb28aed"><div class="ttname"><a href="lib_2Support_2Unix_2README_8txt.html#a93f73fbf80832b23e9014c6ebdb28aed">v1</a></div><div class="ttdeci">llvm lib Support Unix the directory structure underneath this directory could look like only those directories actually needing to be created should be created further subdirectories could be created to reflect versions of the various standards For under SUS there could be v1</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Support_2Unix_2README_8txt_source.html#l00015">README.txt:15</a></div></div>
<div class="ttc" id="anamespacellvm_1_1support_1_1endian_html_acfdf941f45bc58470ed8423b98862486"><div class="ttname"><a href="namespacellvm_1_1support_1_1endian.html#acfdf941f45bc58470ed8423b98862486">llvm::support::endian::read</a></div><div class="ttdeci">value_type read(const void *memory, endianness endian)</div><div class="ttdoc">Read a value of a particular endianness from memory.</div><div class="ttdef"><b>Definition:</b> <a href="Endian_8h_source.html#l00063">Endian.h:63</a></div></div>
<div class="ttc" id="aREADME__ALTIVEC_8txt_html_af3b7cce4bb5f8d59a674047d1f9689b2"><div class="ttname"><a href="README__ALTIVEC_8txt.html#af3b7cce4bb5f8d59a674047d1f9689b2">addi</a></div><div class="ttdeci">Function&lt; 16 x i8 &gt; Produces the following code with LCPI0_0 toc ha LCPI0_1 toc ha addi</div><div class="ttdef"><b>Definition:</b> <a href="README__ALTIVEC_8txt_source.html#l00233">README_ALTIVEC.txt:233</a></div></div>
<div class="ttc" id="aREADME__ALTIVEC_8txt_html_a95dde4245e3a0d25dc3f5849bef6bf30"><div class="ttname"><a href="README__ALTIVEC_8txt.html#a95dde4245e3a0d25dc3f5849bef6bf30">examples</a></div><div class="ttdeci">vperm to rotate result into correct slot vsel result together Should codegen branches on vec_any vec_all to avoid mfcr Two examples</div><div class="ttdef"><b>Definition:</b> <a href="README__ALTIVEC_8txt_source.html#l00190">README_ALTIVEC.txt:190</a></div></div>
<div class="ttc" id="alib_2Target_2X86_2README_8txt_html_a33dac8d316e438676bbcaf13737c9c35"><div class="ttname"><a href="lib_2Target_2X86_2README_8txt.html#a33dac8d316e438676bbcaf13737c9c35">tmp245246</a></div><div class="ttdeci">&lt; i32 &gt; tmp245246</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2X86_2README_8txt_source.html#l00557">README.txt:557</a></div></div>
<div class="ttc" id="aWebAssemblyRegStackify_8cpp_html_aa497ffae4fada2a1c449748e4f2ba956"><div class="ttname"><a href="WebAssemblyRegStackify_8cpp.html#aa497ffae4fada2a1c449748e4f2ba956">query</a></div><div class="ttdeci">static void query(const MachineInstr &amp;MI, bool &amp;Read, bool &amp;Write, bool &amp;Effects, bool &amp;StackPointer)</div><div class="ttdef"><b>Definition:</b> <a href="WebAssemblyRegStackify_8cpp_source.html#l00166">WebAssemblyRegStackify.cpp:166</a></div></div>
<div class="ttc" id="alib_2Target_2X86_2README_8txt_html_a1b0f9b510ec52cc3cbaa14e6e6211168"><div class="ttname"><a href="lib_2Target_2X86_2README_8txt.html#a1b0f9b510ec52cc3cbaa14e6e6211168">td</a></div><div class="ttdeci">gets compiled into this on rsp movaps rsp movaps rsp movaps rsp movaps rsp movaps rsp movaps rsp movaps rsp movaps rsp movq rsp movq rsp movq rsp movq rsp movq rsp rax movq rsp rax movq rsp rsp rsp eax eax jbe LBB1_3 rcx rax movq rsp eax rsp ret ecx eax rcx movl rsp jmp LBB1_2 gcc rsp rax movq rsp rsp movq rsp rax movq rsp eax eax jb L6 rdx eax rsp ret p2align edx rdx eax movl rsp eax rsp ret and it gets compiled into this on ebp esp eax movl ebp eax movl ebp eax esp popl ebp ret gcc ebp eax popl ebp ret Teach tblgen not to check bitconvert source type in some cases This allows us to consolidate the following patterns in X86InstrMMX td</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2X86_2README_8txt_source.html#l01204">README.txt:1204</a></div></div>
<div class="ttc" id="alib_2Target_2SystemZ_2README_8txt_html_ae6ddfd3b40656adbd522b529eb88f3f6"><div class="ttname"><a href="lib_2Target_2SystemZ_2README_8txt.html#ae6ddfd3b40656adbd522b529eb88f3f6">give</a></div><div class="ttdeci">therefore end up llgh r3 lr r0 br r14 but truncating the load would give</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2SystemZ_2README_8txt_source.html#l00091">README.txt:91</a></div></div>
<div class="ttc" id="alib_2Target_2WebAssembly_2README_8txt_html_a66652c299f245556eed274c04512f7a0"><div class="ttname"><a href="lib_2Target_2WebAssembly_2README_8txt.html#a66652c299f245556eed274c04512f7a0">options</a></div><div class="ttdeci">The object format emitted by the WebAssembly backed is documented see the home and packaging for producing WebAssembly applications that can run in browsers and other environments wasi sdk provides a more minimal C C SDK based on llvm and a libc based on for producing WebAssemmbly applictions that use the WASI ABI Rust provides WebAssembly support integrated into Cargo There are two main options</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2WebAssembly_2README_8txt_source.html#l00024">README.txt:24</a></div></div>
<div class="ttc" id="anamespacellvm_1_1MCID_html_ab357441fcd1ea1f9b0d27c12700f6023a359237c780f7c8e40645575826da8a3c"><div class="ttname"><a href="namespacellvm_1_1MCID.html#ab357441fcd1ea1f9b0d27c12700f6023a359237c780f7c8e40645575826da8a3c">llvm::MCID::Branch</a></div><div class="ttdeci">@ Branch</div><div class="ttdef"><b>Definition:</b> <a href="MCInstrDesc_8h_source.html#l00159">MCInstrDesc.h:159</a></div></div>
<div class="ttc" id="aREADME__ALTIVEC_8txt_html_af279f70fce803d73d58062f72beefc2c"><div class="ttname"><a href="README__ALTIVEC_8txt.html#af279f70fce803d73d58062f72beefc2c">_test</a></div><div class="ttdeci">float space text globl _test align _test</div><div class="ttdef"><b>Definition:</b> <a href="README__ALTIVEC_8txt_source.html#l00118">README_ALTIVEC.txt:118</a></div></div>
<div class="ttc" id="anamespacellvm_1_1support_html_a2560071a977efb94947d664e396f7206aa2d63b0536e1684292bd8bbbe49a6099"><div class="ttname"><a href="namespacellvm_1_1support.html#a2560071a977efb94947d664e396f7206aa2d63b0536e1684292bd8bbbe49a6099">llvm::support::aligned</a></div><div class="ttdeci">@ aligned</div><div class="ttdef"><b>Definition:</b> <a href="Endian_8h_source.html#l00030">Endian.h:30</a></div></div>
<div class="ttc" id="alib_2Target_2X86_2README_8txt_html_a2ddce8c59cf8508891327cfe930fc782"><div class="ttname"><a href="lib_2Target_2X86_2README_8txt.html#a2ddce8c59cf8508891327cfe930fc782">improvement</a></div><div class="ttdeci">is pessimized by loop reduce and indvars u32 to float conversion improvement</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2X86_2README_8txt_source.html#l00291">README.txt:291</a></div></div>
<div class="ttc" id="alib_2Target_2README_8txt_html_a8c7970cf0db2471b1269ac541161296e"><div class="ttname"><a href="lib_2Target_2README_8txt.html#a8c7970cf0db2471b1269ac541161296e">case</a></div><div class="ttdeci">we compile this esp call L1 $pb L1 esp je LBB1_2 esp ret but is currently always computed in the entry block It would be better to sink the picbase computation down into the block for the as it is the only one that uses it This happens for a lot of code with early outs Another example is loads of which are usually emitted into the entry block on targets like x86 If not used in all paths through a they should be sunk into the ones that do In this case</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2README_8txt_source.html#l00429">README.txt:429</a></div></div>
<div class="ttc" id="alib_2Target_2X86_2README_8txt_html_a08d0bb2b5ff3a928509a36795ba2ddad"><div class="ttname"><a href="lib_2Target_2X86_2README_8txt.html#a08d0bb2b5ff3a928509a36795ba2ddad">testl</a></div><div class="ttdeci">this lets us change the cmpl into a testl</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2X86_2README_8txt_source.html#l00967">README.txt:967</a></div></div>
<div class="ttc" id="anamespacellvm_1_1TargetStackID_html_a71392100eb15ba746b1f898986f5d8a5"><div class="ttname"><a href="namespacellvm_1_1TargetStackID.html#a71392100eb15ba746b1f898986f5d8a5">llvm::TargetStackID::Value</a></div><div class="ttdeci">Value</div><div class="ttdef"><b>Definition:</b> <a href="TargetFrameLowering_8h_source.html#l00027">TargetFrameLowering.h:27</a></div></div>
<div class="ttc" id="alib_2Target_2X86_2README_8txt_html_abb816ac660dd97791914eb40c31ddcc9"><div class="ttname"><a href="lib_2Target_2X86_2README_8txt.html#abb816ac660dd97791914eb40c31ddcc9">main</a></div><div class="ttdeci">Here we need to push the arguments because they overwrite each other main()</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2X86_2README_8txt_source.html#l00718">README.txt:718</a></div></div>
<div class="ttc" id="aclassStringView_html_a1a45a4e6becbee87f654ec5024c2b432"><div class="ttname"><a href="classStringView.html#a1a45a4e6becbee87f654ec5024c2b432">StringView::dropBack</a></div><div class="ttdeci">StringView dropBack(size_t N=1) const</div><div class="ttdef"><b>Definition:</b> <a href="StringView_8h_source.html#l00064">StringView.h:64</a></div></div>
<div class="ttc" id="alib_2Target_2PowerPC_2README_8txt_html_ad78486583aa82143a9e9bb4337cc97fe"><div class="ttname"><a href="lib_2Target_2PowerPC_2README_8txt.html#ad78486583aa82143a9e9bb4337cc97fe">x</a></div><div class="ttdeci">TODO unsigned x</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2PowerPC_2README_8txt_source.html#l00010">README.txt:10</a></div></div>
<div class="ttc" id="aPPCCTRLoopsVerify_8cpp_html_a593cc2f204f7b2edc16ee222c37c3196"><div class="ttname"><a href="PPCCTRLoopsVerify_8cpp.html#a593cc2f204f7b2edc16ee222c37c3196">verify</a></div><div class="ttdeci">ppc ctr loops verify</div><div class="ttdef"><b>Definition:</b> <a href="PPCCTRLoopsVerify_8cpp_source.html#l00076">PPCCTRLoopsVerify.cpp:76</a></div></div>
<div class="ttc" id="alib_2Target_2README_8txt_html_ada5bbf8dea294facf61576315a990e23"><div class="ttname"><a href="lib_2Target_2README_8txt.html#ada5bbf8dea294facf61576315a990e23">ppc</a></div><div class="ttdeci">Unrolling by would eliminate the &amp;in both leading to a net reduction in code size The resultant code would then also be suitable for exit value computation We miss a bunch of rotate opportunities on various including ppc</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2README_8txt_source.html#l00567">README.txt:567</a></div></div>
<div class="ttc" id="alib_2Analysis_2README_8txt_html_ad653fe29624f0fa310dc84ea76df46fe"><div class="ttname"><a href="lib_2Analysis_2README_8txt.html#ad653fe29624f0fa310dc84ea76df46fe">arithmetic</a></div><div class="ttdeci">Analysis the ScalarEvolution expression for r is&lt; loop &gt; Outside the this could be evaluated simply however ScalarEvolution currently evaluates it it involves i65 arithmetic</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Analysis_2README_8txt_source.html#l00015">README.txt:15</a></div></div>
<div class="ttc" id="aStackColoring_8cpp_html_ad95860b0cf8da9d86f5683f19fafbb32"><div class="ttname"><a href="StackColoring_8cpp.html#ad95860b0cf8da9d86f5683f19fafbb32">slots</a></div><div class="ttdeci">Merge disjoint stack slots</div><div class="ttdef"><b>Definition:</b> <a href="StackColoring_8cpp_source.html#l00555">StackColoring.cpp:555</a></div></div>
<div class="ttc" id="alib_2Target_2README_8txt_html_a5cef66dcb1fc369e64240a0bff194597"><div class="ttname"><a href="lib_2Target_2README_8txt.html#a5cef66dcb1fc369e64240a0bff194597">powi</a></div><div class="ttdeci">This is blocked on not handling X *X *X powi(X, 3)(see note above). The issue is that we end up getting t</div></div>
<div class="ttc" id="alib_2Target_2README_8txt_html_a7449cedde1dc681d0c33134c7c95bcc6"><div class="ttname"><a href="lib_2Target_2README_8txt.html#a7449cedde1dc681d0c33134c7c95bcc6">y</a></div><div class="ttdeci">into llvm powi allowing the code generator to produce balanced multiplication trees the intrinsic needs to be extended to support and second the code generator needs to be enhanced to lower these to multiplication trees Interesting testcase for add shift mul int y</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2README_8txt_source.html#l00061">README.txt:61</a></div></div>
<div class="ttc" id="anamespacellvm_html_a0f4bd88bd90f06f0e66d0b20f877cd1e"><div class="ttname"><a href="namespacellvm.html#a0f4bd88bd90f06f0e66d0b20f877cd1e">llvm::log2</a></div><div class="ttdeci">static double log2(double V)</div><div class="ttdef"><b>Definition:</b> <a href="AMDGPULibCalls_8cpp_source.html#l00794">AMDGPULibCalls.cpp:794</a></div></div>
<div class="ttc" id="alib_2Target_2X86_2README_8txt_html_a85249f8d66bede75202cd3646d2b77c3"><div class="ttname"><a href="lib_2Target_2X86_2README_8txt.html#a85249f8d66bede75202cd3646d2b77c3">throughput</a></div><div class="ttdeci">We currently emits eax Perhaps this is what we really should generate is Is imull three or four cycles eax eax The current instruction priority is based on pattern complexity The former is more complex because it folds a load so the latter will not be emitted Perhaps we should use AddedComplexity to give LEA32r a higher priority We should always try to match LEA first since the LEA matching code does some estimate to determine whether the match is profitable if we care more about code then imull is better It s two bytes shorter than movl leal On a Pentium both variants have the same characteristics with regard to throughput</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2X86_2README_8txt_source.html#l00253">README.txt:253</a></div></div>
<div class="ttc" id="alib_2Target_2X86_2README_8txt_html_a35cb1cfd1057a901c50e8205e55fd527"><div class="ttname"><a href="lib_2Target_2X86_2README_8txt.html#a35cb1cfd1057a901c50e8205e55fd527">tmp233</a></div><div class="ttdeci">&lt; i32 &gt; tmp233</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2X86_2README_8txt_source.html#l00556">README.txt:556</a></div></div>
<div class="ttc" id="alib_2Target_2PowerPC_2README_8txt_html_aab7aca753744e96d2cd66778e7d86741"><div class="ttname"><a href="lib_2Target_2PowerPC_2README_8txt.html#aab7aca753744e96d2cd66778e7d86741">blr</a></div><div class="ttdeci">cond_true lis lo16() lo16() lo16() f1 fsel f3 blr</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2PowerPC_2README_8txt_source.html#l00108">README.txt:108</a></div></div>
<div class="ttc" id="aDXContainerGlobals_8cpp_html_ace9918659ef4a022d158646784619514"><div class="ttname"><a href="DXContainerGlobals_8cpp.html#ace9918659ef4a022d158646784619514">globals</a></div><div class="ttdeci">dxil globals</div><div class="ttdef"><b>Definition:</b> <a href="DXContainerGlobals_8cpp_source.html#l00107">DXContainerGlobals.cpp:107</a></div></div>
<div class="ttc" id="aAnnotations_8cpp_html_a6bc1d3d16b23b6d89409993bd75f495d"><div class="ttname"><a href="Annotations_8cpp.html#a6bc1d3d16b23b6d89409993bd75f495d">require</a></div><div class="ttdeci">static void require(bool Assertion, const char *Msg, llvm::StringRef Code)</div><div class="ttdef"><b>Definition:</b> <a href="Annotations_8cpp_source.html#l00019">Annotations.cpp:19</a></div></div>
<div class="ttc" id="aREADME__ALTIVEC_8txt_html_a8138d0c29eae7e4ccc5b77e4c999b20e"><div class="ttname"><a href="README__ALTIVEC_8txt.html#a8138d0c29eae7e4ccc5b77e4c999b20e">v3</a></div><div class="ttdeci">we get the following basic r4 lvx v3</div><div class="ttdef"><b>Definition:</b> <a href="README__ALTIVEC_8txt_source.html#l00095">README_ALTIVEC.txt:95</a></div></div>
<div class="ttc" id="alib_2Target_2PowerPC_2README_8txt_html_a8895a2a3113ec14d3ff4ccaae3de69b1"><div class="ttname"><a href="lib_2Target_2PowerPC_2README_8txt.html#a8895a2a3113ec14d3ff4ccaae3de69b1">than</a></div><div class="ttdeci">So that lo16() r2 stb r3 blr Becomes r3 they should compile to something better than</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2PowerPC_2README_8txt_source.html#l00161">README.txt:161</a></div></div>
<div class="ttc" id="aTargetLibraryInfo_8cpp_html_aca185e6d0e9f423dbb24440206454872a0e0d4848f799861d016ae63c8fdc41e3"><div class="ttname"><a href="TargetLibraryInfo_8cpp.html#aca185e6d0e9f423dbb24440206454872a0e0d4848f799861d016ae63c8fdc41e3">Same</a></div><div class="ttdeci">@ Same</div><div class="ttdef"><b>Definition:</b> <a href="TargetLibraryInfo_8cpp_source.html#l00065">TargetLibraryInfo.cpp:65</a></div></div>
<div class="ttc" id="alib_2Target_2README_8txt_html_a69955d334349c9adad86cd95171dce4c"><div class="ttname"><a href="lib_2Target_2README_8txt.html#a69955d334349c9adad86cd95171dce4c">transform</a></div><div class="ttdeci">instcombine should handle this transform</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2README_8txt_source.html#l00262">README.txt:262</a></div></div>
<div class="ttc" id="alib_2Target_2X86_2README_8txt_html_a56c9db45beb30274a14b02303322dbba"><div class="ttname"><a href="lib_2Target_2X86_2README_8txt.html#a56c9db45beb30274a14b02303322dbba">flds</a></div><div class="ttdeci">esp eax movl ecx ecx cvtsi2ss xmm0 eax cvtsi2ss xmm1 xmm0 addss xmm0 movss flds(%esp, 1) 0000002d addl $0x04</div></div>
<div class="ttc" id="alib_2CodeGen_2README_8txt_html_a347b3eaeb1cc29643e5e37f11fdbb3fb"><div class="ttname"><a href="lib_2CodeGen_2README_8txt.html#a347b3eaeb1cc29643e5e37f11fdbb3fb">However</a></div><div class="ttdeci">Common register allocation spilling lr str ldr sxth r3 ldr mla r4 can lr mov lr str ldr sxth r3 mla r4 and then merge mul and lr str ldr sxth r3 mla r4 It also increase the likelihood the store may become dead bb27 Successors according to LLVM ID Predecessors according to mbb&lt; bb27, 0x8b0a7c0 &gt; Note ADDri is not a two address instruction However</div><div class="ttdef"><b>Definition:</b> <a href="lib_2CodeGen_2README_8txt_source.html#l00043">README.txt:43</a></div></div>
<div class="ttc" id="anamespacellvm_1_1MCID_html_ab357441fcd1ea1f9b0d27c12700f6023a2b016c207343046b2bac45e69e76dcec"><div class="ttname"><a href="namespacellvm_1_1MCID.html#ab357441fcd1ea1f9b0d27c12700f6023a2b016c207343046b2bac45e69e76dcec">llvm::MCID::Add</a></div><div class="ttdeci">@ Add</div><div class="ttdef"><b>Definition:</b> <a href="MCInstrDesc_8h_source.html#l00186">MCInstrDesc.h:186</a></div></div>
<div class="ttc" id="anamespacellvm_1_1ISD_html_a22ea9cec080dd5f4f47ba234c2f59110a047178c3b2c6a5df40ae22a407b8aca9"><div class="ttname"><a href="namespacellvm_1_1ISD.html#a22ea9cec080dd5f4f47ba234c2f59110a047178c3b2c6a5df40ae22a407b8aca9">llvm::ISD::STORE</a></div><div class="ttdeci">@ STORE</div><div class="ttdef"><b>Definition:</b> <a href="ISDOpcodes_8h_source.html#l00966">ISDOpcodes.h:966</a></div></div>
<div class="ttc" id="alib_2Target_2ARM_2README_8txt_html_ae8089d69ac7b6d4c2727bb3f9b7e54f6"><div class="ttname"><a href="lib_2Target_2ARM_2README_8txt.html#ae8089d69ac7b6d4c2727bb3f9b7e54f6">bic</a></div><div class="ttdeci">We currently LCPI0_0 and r2 ldr LCPI0_1 and r2 orr r0 bx lr We should be able to replace the second ldr and with a bic(i.e. reuse the constant which was already loaded). Not sure what 's necessary to do that. The code generated for bswap on armv4/5(CPUs without rev) is less than ideal</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2ARM_2README_8txt_source.html#l00604">README.txt:604</a></div></div>
<div class="ttc" id="anamespacellvm_html_af3a2b03b115846b5339469ce1e603976a02bce93bff905887ad2233110bf9c49e"><div class="ttname"><a href="namespacellvm.html#af3a2b03b115846b5339469ce1e603976a02bce93bff905887ad2233110bf9c49e">llvm::FunctionReturnThunksKind::Keep</a></div><div class="ttdeci">@ Keep</div><div class="ttdoc">No function return thunk.</div></div>
<div class="ttc" id="aclassStringView_html_ae8fa8baca6ed81993c3a4833854937a0"><div class="ttname"><a href="classStringView.html#ae8fa8baca6ed81993c3a4833854937a0">StringView::begin</a></div><div class="ttdeci">const char * begin() const</div><div class="ttdef"><b>Definition:</b> <a href="StringView_8h_source.html#l00109">StringView.h:109</a></div></div>
<div class="ttc" id="alib_2Target_2X86_2README_8txt_html_ad9747491f76eaf30d30d961b1b7d9b4e"><div class="ttname"><a href="lib_2Target_2X86_2README_8txt.html#ad9747491f76eaf30d30d961b1b7d9b4e">andb</a></div><div class="ttdeci">bar al andb</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2X86_2README_8txt_source.html#l01401">README.txt:1401</a></div></div>
<div class="ttc" id="aREADME__ALTIVEC_8txt_html_ac16493547f980699ca24adec8870bce9"><div class="ttname"><a href="README__ALTIVEC_8txt.html#ac16493547f980699ca24adec8870bce9">v4</a></div><div class="ttdeci">we get the following basic r4 lvx r3 vcmpeqfp v4</div><div class="ttdef"><b>Definition:</b> <a href="README__ALTIVEC_8txt_source.html#l00096">README_ALTIVEC.txt:96</a></div></div>
<div class="ttc" id="alib_2Target_2README_8txt_html_a66529b13967f1d18538dfa09dfb603d8"><div class="ttname"><a href="lib_2Target_2README_8txt.html#a66529b13967f1d18538dfa09dfb603d8">arguments</a></div><div class="ttdeci">we compile this esp call L1 $pb L1 esp je LBB1_2 esp ret but is currently always computed in the entry block It would be better to sink the picbase computation down into the block for the as it is the only one that uses it This happens for a lot of code with early outs Another example is loads of arguments</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2README_8txt_source.html#l00425">README.txt:425</a></div></div>
<div class="ttc" id="aREADME-SSE_8txt_html_a26453c881beeb33cd589962e4c10b791"><div class="ttname"><a href="README-SSE_8txt.html#a26453c881beeb33cd589962e4c10b791">horrible</a></div><div class="ttdeci">into eax xorps xmm0 xmm0 eax xmm0 eax xmm0 ret esp eax movdqa xmm0 xmm0 esp const ret align it should be movdqa xmm0 xmm0 We should transform a shuffle of two vectors of constants into a single vector of constants insertelement of a constant into a vector of constants should also result in a vector of constants e g VecISelBug ll We compiled it to something horrible</div><div class="ttdef"><b>Definition:</b> <a href="README-SSE_8txt_source.html#l00672">README-SSE.txt:672</a></div></div>
<div class="ttc" id="alib_2Target_2X86_2README_8txt_html_a82149c97ea37050346bdc9a259830e23"><div class="ttname"><a href="lib_2Target_2X86_2README_8txt.html#a82149c97ea37050346bdc9a259830e23">shifts</a></div><div class="ttdeci">http eax xorl edx cl sete al setne dl sall eax sall edx But that requires good bit subreg support this might be better It s an extra but it s one instruction and doesn t stress bit subreg eax eax movl edx edx sall eax sall cl edx bit shifts(in general) expand to really bad code. Instead of using cmovs</div></div>
<div class="ttc" id="aregcomp_8c_html_a3a32062110fa975b1721c449fa7863dc"><div class="ttname"><a href="regcomp_8c.html#a3a32062110fa975b1721c449fa7863dc">never</a></div><div class="ttdeci">#define never</div><div class="ttdef"><b>Definition:</b> <a href="regcomp_8c_source.html#l00286">regcomp.c:286</a></div></div>
<div class="ttc" id="alib_2Target_2ARM_2README_8txt_html_a823c1a2fe345c7561f3592fe6b25300c"><div class="ttname"><a href="lib_2Target_2ARM_2README_8txt.html#a823c1a2fe345c7561f3592fe6b25300c">v6</a></div><div class="ttdeci">Should compile to use and accumulates this with a bit value We currently get this with both v4 and v6</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2ARM_2README_8txt_source.html#l00431">README.txt:431</a></div></div>
<div class="ttc" id="alib_2Target_2ARM_2README_8txt_html_a0923c429b0c515f4ace7a106c97935d4"><div class="ttname"><a href="lib_2Target_2ARM_2README_8txt.html#a0923c429b0c515f4ace7a106c97935d4">This</a></div><div class="ttdeci">the resulting code requires compare and branches when and if the revised code is with conditional branches instead of More there is a byte word extend before each where there should be only and the condition codes are not remembered when the same two values are compared twice More LSR enhancements i8 and i32 load store addressing modes are identical This</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2ARM_2README_8txt_source.html#l00418">README.txt:418</a></div></div>
<div class="ttc" id="alib_2Target_2X86_2README_8txt_html_a817f593f22d6f72037f5ab5c9972df61"><div class="ttname"><a href="lib_2Target_2X86_2README_8txt.html#a817f593f22d6f72037f5ab5c9972df61">commutative</a></div><div class="ttdeci">http eax xorl edx cl sete al setne dl sall eax sall edx But that requires good bit subreg support this might be better It s an extra but it s one instruction and doesn t stress bit subreg eax eax movl edx edx sall eax sall cl edx bit we should expand to a conditional branch like GCC produces Some isel and Sequencing of Instructions Scheduling for reduced register pressure E g Minimum Register Instruction Sequence load p Because the compare isn t commutative</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2X86_2README_8txt_source.html#l00077">README.txt:77</a></div></div>
<div class="ttc" id="aHWAddressSanitizer_8cpp_html_aeaa43ab635ee98b9e2055d0f217558c2af12bc59169afda2918e9f23e3501c2b6"><div class="ttname"><a href="HWAddressSanitizer_8cpp.html#aeaa43ab635ee98b9e2055d0f217558c2af12bc59169afda2918e9f23e3501c2b6">instr</a></div><div class="ttdeci">@ instr</div><div class="ttdef"><b>Definition:</b> <a href="HWAddressSanitizer_8cpp_source.html#l00194">HWAddressSanitizer.cpp:194</a></div></div>
<div class="ttc" id="alib_2Target_2Sparc_2README_8txt_html_a2c0145babf6af6381d10cc5d1b3da327"><div class="ttname"><a href="lib_2Target_2Sparc_2README_8txt.html#a2c0145babf6af6381d10cc5d1b3da327">g0</a></div><div class="ttdeci">To do *Keep the address of the constant pool in a register instead of forming its address all of the time *We can fold small constant offsets into the hi lo references to constant pool addresses as well *When in V9 register allocate icc *[0-3] Add support for isel ing UMUL_LOHI instead of marking it as Expand *Emit the Branch on Integer Register with Prediction instructions It s not clear how to write a pattern for this int o6 subcc l0 bne LBBt1_2 ! F nop l0 st g0</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2Sparc_2README_8txt_source.html#l00034">README.txt:34</a></div></div>
<div class="ttc" id="alib_2Target_2README_8txt_html_a2f8a4b86e78933bdfaa1cbe2f8fa09f6"><div class="ttname"><a href="lib_2Target_2README_8txt.html#a2f8a4b86e78933bdfaa1cbe2f8fa09f6">X</a></div><div class="ttdeci">instcombine should handle this C2 when X</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2README_8txt_source.html#l00263">README.txt:263</a></div></div>
<div class="ttc" id="anamespacellvm_html_ae23e16c67aeaf23c68bf86fe04df42ee"><div class="ttname"><a href="namespacellvm.html#ae23e16c67aeaf23c68bf86fe04df42ee">llvm::CannotBeNegativeZero</a></div><div class="ttdeci">bool CannotBeNegativeZero(const Value *V, const TargetLibraryInfo *TLI, unsigned Depth=0)</div><div class="ttdoc">Return true if we can prove that the specified FP value is never equal to -0.0.</div><div class="ttdef"><b>Definition:</b> <a href="ValueTracking_8cpp_source.html#l03518">ValueTracking.cpp:3518</a></div></div>
<div class="ttc" id="alib_2Target_2X86_2README_8txt_html_af6ee8cc29ae2f4773e37b974ae81f038"><div class="ttname"><a href="lib_2Target_2X86_2README_8txt.html#af6ee8cc29ae2f4773e37b974ae81f038">movl</a></div><div class="ttdeci">Instead of the following for memset char edx movl</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2X86_2README_8txt_source.html#l00117">README.txt:117</a></div></div>
<div class="ttc" id="alib_2Target_2ARM_2README_8txt_html_aa92b368e825c3d6388fbfe0fff7e5d30"><div class="ttname"><a href="lib_2Target_2ARM_2README_8txt.html#aa92b368e825c3d6388fbfe0fff7e5d30">align</a></div><div class="ttdeci">mov r0 ldr L5 sub r0 lr needed for prologue ldmia ip add bx lr r2 The last stmia stores r2 into the address passed in there is one additional stmia that stores and r2 to some stack location The store is dead The llvm gcc generated code looks like align</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2ARM_2README_8txt_source.html#l00236">README.txt:236</a></div></div>
<div class="ttc" id="anamespacellvm_1_1numbers_html_a9473b507816be4056a158a41cfb86807"><div class="ttname"><a href="namespacellvm_1_1numbers.html#a9473b507816be4056a158a41cfb86807">llvm::numbers::phi</a></div><div class="ttdeci">constexpr double phi</div><div class="ttdef"><b>Definition:</b> <a href="MathExtras_8h_source.html#l00045">MathExtras.h:45</a></div></div>
<div class="ttc" id="alib_2Target_2ARM_2README_8txt_html_a065f5cc56ee85cb3639cce3dab796775"><div class="ttname"><a href="lib_2Target_2ARM_2README_8txt.html#a065f5cc56ee85cb3639cce3dab796775">r5</a></div><div class="ttdeci">_bar mov r0 mov r5</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2ARM_2README_8txt_source.html#l00154">README.txt:154</a></div></div>
<div class="ttc" id="alib_2Target_2ARM_2README_8txt_html_acfb6b9e2b00e34da4313b463c341e597"><div class="ttname"><a href="lib_2Target_2ARM_2README_8txt.html#acfb6b9e2b00e34da4313b463c341e597">s1</a></div><div class="ttdeci">int s1</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2ARM_2README_8txt_source.html#l00182">README.txt:182</a></div></div>
<div class="ttc" id="aREADME-SSE_8txt_html_afd6f6f24b23f9cb36763c45a21e92080"><div class="ttname"><a href="README-SSE_8txt.html#afd6f6f24b23f9cb36763c45a21e92080">Currently</a></div><div class="ttdeci">into xmm2 addss xmm2 xmm1 xmm3 addss xmm3 movaps xmm0 unpcklps xmm0 ret seems silly when it could just be one addps Expand libm rounding functions main should enable SSE DAZ mode and other fast SSE modes Think about doing i64 math in SSE regs on x86 This testcase should have no SSE instructions in and only one load from a constant double ret double C Currently</div><div class="ttdef"><b>Definition:</b> <a href="README-SSE_8txt_source.html#l00089">README-SSE.txt:89</a></div></div>
<div class="ttc" id="alib_2Target_2X86_2README_8txt_html_a7facf4895d2069412e7bb798d4b5eca8"><div class="ttname"><a href="lib_2Target_2X86_2README_8txt.html#a7facf4895d2069412e7bb798d4b5eca8">xmm4</a></div><div class="ttdeci">gets compiled into this on rsp movaps rsp movaps rsp movaps rsp movaps xmm4</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2X86_2README_8txt_source.html#l01118">README.txt:1118</a></div></div>
<div class="ttc" id="alib_2Target_2README_8txt_html_adb347d0589d7caa171d4c01d67697458"><div class="ttname"><a href="lib_2Target_2README_8txt.html#adb347d0589d7caa171d4c01d67697458">mode</a></div><div class="ttdeci">We should investigate an instruction sinking pass Consider this silly example in pic mode</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2README_8txt_source.html#l00400">README.txt:400</a></div></div>
<div class="ttc" id="aREADME-SSE_8txt_html_aae2d2977835e891eef9c1569d44462d7"><div class="ttname"><a href="README-SSE_8txt.html#aae2d2977835e891eef9c1569d44462d7">used</a></div><div class="ttdeci">This might compile to this xmm1 xorps xmm0 movss xmm0 ret Now consider if the code caused xmm1 to get spilled This might produce this xmm1 movaps xmm0 movaps xmm1 movss xmm0 ret since the reload is only used by these we could fold it into the producing something like xmm1 movaps xmm0 ret saving two instructions The basic idea is that a reload from a spill if only one byte chunk is used</div><div class="ttdef"><b>Definition:</b> <a href="README-SSE_8txt_source.html#l00270">README-SSE.txt:270</a></div></div>
<div class="ttc" id="alib_2Target_2X86_2README_8txt_html_a809aa08f1d799a5ed298e68bd3fac0c7"><div class="ttname"><a href="lib_2Target_2X86_2README_8txt.html#a809aa08f1d799a5ed298e68bd3fac0c7">exit</a></div><div class="ttdeci">declare void exit(i32) noreturn nounwind This compiles into</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2X86_2README_8txt_source.html#l01072">README.txt:1072</a></div></div>
<div class="ttc" id="aclassStringView_html_a934c67d07c59bf2f3f5e3018e1e56b53"><div class="ttname"><a href="classStringView.html#a934c67d07c59bf2f3f5e3018e1e56b53">StringView::dropFront</a></div><div class="ttdeci">StringView dropFront(size_t N=1) const</div><div class="ttdef"><b>Definition:</b> <a href="StringView_8h_source.html#l00058">StringView.h:58</a></div></div>
<div class="ttc" id="anamespacellvm_1_1TPLoop_html_aec6cc0f26afef38af689286c2a436277a4a8e194cc347b9c63c21d17e50cb354d"><div class="ttname"><a href="namespacellvm_1_1TPLoop.html#aec6cc0f26afef38af689286c2a436277a4a8e194cc347b9c63c21d17e50cb354d">llvm::TPLoop::Allow</a></div><div class="ttdeci">@ Allow</div><div class="ttdef"><b>Definition:</b> <a href="ARMTargetTransformInfo_8h_source.html#l00054">ARMTargetTransformInfo.h:54</a></div></div>
<div class="ttc" id="ainclude_2llvm_2Demangle_2README_8txt_html_ac6cd01dd04b802f55532b569e3d4af94"><div class="ttname"><a href="include_2llvm_2Demangle_2README_8txt.html#ac6cd01dd04b802f55532b569e3d4af94">differences</a></div><div class="ttdeci">Itanium Name Demangler i e convert the string _Z1fv into and both[sub] projects need to demangle but neither can depend on each other *libcxxabi needs the demangler to implement which is part of the itanium ABI spec *LLVM needs a copy for a bunch of and cannot rely on the system s __cxa_demangle because it a might not be and b may not be up to date on the latest language features The copy of the demangler in LLVM has some extra stuff that aren t needed in which depend on the shared generic components Despite these differences</div><div class="ttdef"><b>Definition:</b> <a href="include_2llvm_2Demangle_2README_8txt_source.html#l00033">README.txt:33</a></div></div>
<div class="ttc" id="alib_2Target_2X86_2README_8txt_html_ae8ff42fa7eb30eaefb0acf803ac8714c"><div class="ttname"><a href="lib_2Target_2X86_2README_8txt.html#ae8ff42fa7eb30eaefb0acf803ac8714c">looking</a></div><div class="ttdeci">Should compile edi setae al movzbl eax ret on instead of the rather stupid looking</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2X86_2README_8txt_source.html#l00543">README.txt:543</a></div></div>
<div class="ttc" id="aregcomp_8c_html_a0240ac851181b84ac374872dc5434ee4"><div class="ttname"><a href="regcomp_8c.html#a0240ac851181b84ac374872dc5434ee4">N</a></div><div class="ttdeci">#define N</div></div>
<div class="ttc" id="alib_2CodeGen_2README_8txt_html_afa864f0f6145846a80b9e27066e95dd4"><div class="ttname"><a href="lib_2CodeGen_2README_8txt.html#afa864f0f6145846a80b9e27066e95dd4">mov</a></div><div class="ttdeci">Common register allocation spilling lr str ldr sxth r3 ldr mla r4 can lr mov lr str ldr sxth r3 mla r4 and then merge mul and mov</div><div class="ttdef"><b>Definition:</b> <a href="lib_2CodeGen_2README_8txt_source.html#l00023">README.txt:23</a></div></div>
<div class="ttc" id="alib_2Target_2WebAssembly_2README_8txt_html_af8355ffb75feaa7935899689e31dadf5"><div class="ttname"><a href="lib_2Target_2WebAssembly_2README_8txt.html#af8355ffb75feaa7935899689e31dadf5">musl</a></div><div class="ttdeci">The object format emitted by the WebAssembly backed is documented see the home and packaging for producing WebAssembly applications that can run in browsers and other environments wasi sdk provides a more minimal C C SDK based on llvm and a libc based on musl</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2WebAssembly_2README_8txt_source.html#l00020">README.txt:20</a></div></div>
<div class="ttc" id="aAArch64ISelDAGToDAG_8cpp_html_a2098a5fa6ada61b6c4a1f210ad84e4a1a4ebada6a2af2bcba53ded1d7b414f081"><div class="ttname"><a href="AArch64ISelDAGToDAG_8cpp.html#a2098a5fa6ada61b6c4a1f210ad84e4a1a4ebada6a2af2bcba53ded1d7b414f081">SelectTypeKind::FP</a></div><div class="ttdeci">@ FP</div></div>
<div class="ttc" id="alib_2Target_2ARM_2README_8txt_html_ad34c196412ad9a6a78795035f587fa26"><div class="ttname"><a href="lib_2Target_2ARM_2README_8txt.html#ad34c196412ad9a6a78795035f587fa26">support</a></div><div class="ttdeci">Reimplement select in terms of SEL *We would really like to support but we need to prove that the add doesn t need to overflow between the two bit chunks *Implement pre post increment support(e.g. PR935) *Implement smarter const ant generation for binops with large immediates. A few ARMv6T2 ops should be pattern matched</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2ARM_2README_8txt_source.html#l00010">README.txt:10</a></div></div>
<div class="ttc" id="alib_2Target_2X86_2README_8txt_html_abf89f09e76ca3bcfb207cddc821f3299"><div class="ttname"><a href="lib_2Target_2X86_2README_8txt.html#abf89f09e76ca3bcfb207cddc821f3299">shift</a></div><div class="ttdeci">http eax xorl edx cl sete al setne dl sall eax sall edx But that requires good bit subreg support this might be better It s an extra shift</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2X86_2README_8txt_source.html#l00030">README.txt:30</a></div></div>
<div class="ttc" id="alib_2Target_2ARM_2README_8txt_html_a99d4c77c6a5298070bb9e4e4904d9dfe"><div class="ttname"><a href="lib_2Target_2ARM_2README_8txt.html#a99d4c77c6a5298070bb9e4e4904d9dfe">generate</a></div><div class="ttdeci">We currently generate</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2ARM_2README_8txt_source.html#l00597">README.txt:597</a></div></div>
<div class="ttc" id="alib_2Target_2X86_2README_8txt_html_a6fd9dd6916101f0fc80f878f76b9f6e9"><div class="ttname"><a href="lib_2Target_2X86_2README_8txt.html#a6fd9dd6916101f0fc80f878f76b9f6e9">cmpb</a></div><div class="ttdeci">&lt; i32 &gt; ret i32 tmp10 ecx cmpb</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2X86_2README_8txt_source.html#l00992">README.txt:992</a></div></div>
<div class="ttc" id="alib_2Target_2ARM_2README_8txt_html_ac3302d36e5507ecfe3ed8ba03d5e320c"><div class="ttname"><a href="lib_2Target_2ARM_2README_8txt.html#ac3302d36e5507ecfe3ed8ba03d5e320c">stack</a></div><div class="ttdeci">S is passed via registers r2 But gcc stores them to the stack</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2ARM_2README_8txt_source.html#l00189">README.txt:189</a></div></div>
<div class="ttc" id="aclassStringView_html_ae65a04775aac67a1e107b451d0451bc6"><div class="ttname"><a href="classStringView.html#ae65a04775aac67a1e107b451d0451bc6">StringView::empty</a></div><div class="ttdeci">bool empty() const</div><div class="ttdef"><b>Definition:</b> <a href="StringView_8h_source.html#l00112">StringView.h:112</a></div></div>
<div class="ttc" id="alib_2Target_2ARM_2README_8txt_html_a853716015b99747c10b31bfb4241df91"><div class="ttname"><a href="lib_2Target_2ARM_2README_8txt.html#a853716015b99747c10b31bfb4241df91">PPC</a></div><div class="ttdeci">should just be implemented with a CLZ instruction Since there are other e PPC</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2ARM_2README_8txt_source.html#l00709">README.txt:709</a></div></div>
<div class="ttc" id="alib_2Target_2X86_2README_8txt_html_a0da3a4543384036945892d698dc7e079"><div class="ttname"><a href="lib_2Target_2X86_2README_8txt.html#a0da3a4543384036945892d698dc7e079">first_one</a></div><div class="ttdeci">The following code is currently eax eax ecx jb LBB1_2 eax movzbl first_one(%eax)</div></div>
<div class="ttc" id="alib_2Target_2X86_2README_8txt_html_a81506d0b948e09ff1321fdbcb0ee6d01"><div class="ttname"><a href="lib_2Target_2X86_2README_8txt.html#a81506d0b948e09ff1321fdbcb0ee6d01">al</a></div><div class="ttdeci">http eax xorl edx cl sete al setne dl sall eax sall edx But that requires good bit subreg support this might be better It s an extra but it s one instruction and doesn t stress bit subreg eax eax movl edx edx sall eax sall cl edx bit we should expand to a conditional branch like GCC produces Some isel and Sequencing of Instructions Scheduling for reduced register pressure E g Minimum Register Instruction Sequence load p Because the compare isn t it is not matched with the load on both sides The dag combiner should be made smart enough to canonicalize the load into the RHS of a compare when it can invert the result of the compare for free In many LLVM generates code like eax cmpl esp setl al movzbl al</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2X86_2README_8txt_source.html#l00089">README.txt:89</a></div></div>
<div class="ttc" id="alib_2Target_2README_8txt_html_a373be2bad265486d0323e451a28153fd"><div class="ttname"><a href="lib_2Target_2README_8txt.html#a373be2bad265486d0323e451a28153fd">canonical</a></div><div class="ttdeci">This is blocked on not handling X *X *X which is the same number of multiplies and is canonical</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2README_8txt_source.html#l00070">README.txt:70</a></div></div>
<div class="ttc" id="alib_2Target_2X86_2README_8txt_html_adb6c03afcd6e6c18f921c10ce41bdf80"><div class="ttname"><a href="lib_2Target_2X86_2README_8txt.html#adb6c03afcd6e6c18f921c10ce41bdf80">neg</a></div><div class="ttdeci">We currently generate a but we really shouldn eax ecx xorl edx divl ecx eax divl ecx movl eax ret A similar code sequence works for division We currently compile i32 v2 eax eax jo LBB1_2 neg</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2X86_2README_8txt_source.html#l01271">README.txt:1271</a></div></div>
<div class="ttc" id="aREADME-SSE_8txt_html_ae08edf2a0482a5d008070bbd72580a40"><div class="ttname"><a href="README-SSE_8txt.html#ae08edf2a0482a5d008070bbd72580a40">early</a></div><div class="ttdeci">the custom lowered code happens to be but we shouldn t have to custom lower anything This is probably related to&lt; 2 x i64 &gt; ops being so bad LLVM currently generates stack realignment when it is not necessary needed The problem is that we need to know about stack alignment too early</div><div class="ttdef"><b>Definition:</b> <a href="README-SSE_8txt_source.html#l00486">README-SSE.txt:486</a></div></div>
<div class="ttc" id="alib_2Target_2X86_2README_8txt_html_adeaf2c180bb152a88c26651526063f99"><div class="ttname"><a href="lib_2Target_2X86_2README_8txt.html#adeaf2c180bb152a88c26651526063f99">tmp231232</a></div><div class="ttdeci">&lt; i32 &gt; tmp231232</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2X86_2README_8txt_source.html#l00556">README.txt:556</a></div></div>
<div class="ttc" id="alib_2Target_2X86_2README_8txt_html_a751e570be9981fc075f53f59e6de3132"><div class="ttname"><a href="lib_2Target_2X86_2README_8txt.html#a751e570be9981fc075f53f59e6de3132">andl</a></div><div class="ttdeci">esp eax movl ecx ecx cvtsi2ss xmm0 andl</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2X86_2README_8txt_source.html#l00302">README.txt:302</a></div></div>
<div class="ttc" id="alib_2Target_2X86_2README_8txt_html_a85332438aa4750c13aab6b4040237e5a"><div class="ttname"><a href="lib_2Target_2X86_2README_8txt.html#a85332438aa4750c13aab6b4040237e5a">easy</a></div><div class="ttdeci">For the entry BB esp pxor xmm0 xmm1 ucomisd xmm1 setnp al sete cl testb al jne LBB1_5 xmm2 cvtss2sd xmm3 ucomisd xmm0 ja LBB1_3 xmm2 xmm0 ret We should sink the load into xmm3 into the LBB1_2 block This should be pretty easy</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2X86_2README_8txt_source.html#l00525">README.txt:525</a></div></div>
<div class="ttc" id="aLowerMatrixIntrinsics_8cpp_html_a976c8a852b4c6e1aebefedebcc2a5212"><div class="ttname"><a href="LowerMatrixIntrinsics_8cpp.html#a976c8a852b4c6e1aebefedebcc2a5212">minimal</a></div><div class="ttdeci">lower matrix intrinsics minimal</div><div class="ttdef"><b>Definition:</b> <a href="LowerMatrixIntrinsics_8cpp_source.html#l02490">LowerMatrixIntrinsics.cpp:2490</a></div></div>
<div class="ttc" id="ablake3__impl_8h_html_a78823051d1dad34b9b3d8120112e674d"><div class="ttname"><a href="blake3__impl_8h.html#a78823051d1dad34b9b3d8120112e674d">IV</a></div><div class="ttdeci">static const uint32_t IV[8]</div><div class="ttdef"><b>Definition:</b> <a href="blake3__impl_8h_source.html#l00077">blake3_impl.h:77</a></div></div>
<div class="ttc" id="alib_2Target_2ARM_2README_8txt_html_a07b085f08dc2f0db6577bcfa5d720ab6"><div class="ttname"><a href="lib_2Target_2ARM_2README_8txt.html#a07b085f08dc2f0db6577bcfa5d720ab6">operations</a></div><div class="ttdeci">Should compile r2 movcc movcs str strb mov lr r1 movcs movcc mov lr r1 str mov mov cmp r1 movlo r2 str bx lr r0 mov mov cmp r0 movhs r2 mov r1 bx lr Some of the NEON intrinsics may be appropriate for more general either as target independent intrinsics or perhaps elsewhere in the ARM backend Some of them may also be lowered to target independent and perhaps some new SDNodes could be added For and absolute value operations are well defined and standard operations</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2ARM_2README_8txt_source.html#l00490">README.txt:490</a></div></div>
<div class="ttc" id="anamespacellvm_html_a6b0ac1fa4f05de76413c5e0ca6334035"><div class="ttname"><a href="namespacellvm.html#a6b0ac1fa4f05de76413c5e0ca6334035">llvm::reverse</a></div><div class="ttdeci">auto reverse(ContainerTy &amp;&amp;C)</div><div class="ttdef"><b>Definition:</b> <a href="STLExtras_8h_source.html#l00484">STLExtras.h:484</a></div></div>
<div class="ttc" id="aAMDGPUPrintfRuntimeBinding_8cpp_html_a69bb70228d1f1da94577e5ddcaa20a29"><div class="ttname"><a href="AMDGPUPrintfRuntimeBinding_8cpp.html#a69bb70228d1f1da94577e5ddcaa20a29">lowering</a></div><div class="ttdeci">amdgpu printf runtime AMDGPU Printf lowering</div><div class="ttdef"><b>Definition:</b> <a href="AMDGPUPrintfRuntimeBinding_8cpp_source.html#l00090">AMDGPUPrintfRuntimeBinding.cpp:90</a></div></div>
<div class="ttc" id="aclassStringView_html"><div class="ttname"><a href="classStringView.html">StringView</a></div><div class="ttdef"><b>Definition:</b> <a href="StringView_8h_source.html#l00025">StringView.h:25</a></div></div>
<div class="ttc" id="anamespacellvm_1_1msgpack_html_afdae9da66bac09f4b2bfc0fd9f0559e6"><div class="ttname"><a href="namespacellvm_1_1msgpack.html#afdae9da66bac09f4b2bfc0fd9f0559e6">llvm::msgpack::Type</a></div><div class="ttdeci">Type</div><div class="ttdoc">MessagePack types as defined in the standard, with the exception of Integer being divided into a sign...</div><div class="ttdef"><b>Definition:</b> <a href="MsgPackReader_8h_source.html#l00048">MsgPackReader.h:48</a></div></div>
<div class="ttc" id="alib_2Target_2ARM_2README_8txt_html_a682ab71eba3f533da7f4082861abfa6f"><div class="ttname"><a href="lib_2Target_2ARM_2README_8txt.html#a682ab71eba3f533da7f4082861abfa6f">r12</a></div><div class="ttdeci">llvm ldr ldrb r12</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2ARM_2README_8txt_source.html#l00127">README.txt:127</a></div></div>
<div class="ttc" id="alib_2Target_2X86_2README_8txt_html_a17377643d3461c259350ba09410f5f22"><div class="ttname"><a href="lib_2Target_2X86_2README_8txt.html#a17377643d3461c259350ba09410f5f22">tmp583584</a></div><div class="ttdeci">&lt; i8 * &gt; tmp583584</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2X86_2README_8txt_source.html#l00561">README.txt:561</a></div></div>
<div class="ttc" id="aHexagonGenPredicate_8cpp_html_a0de1bf31f56b17312cc34b911d86faa4"><div class="ttname"><a href="HexagonGenPredicate_8cpp.html#a0de1bf31f56b17312cc34b911d86faa4">pred</a></div><div class="ttdeci">hexagon gen pred</div><div class="ttdef"><b>Definition:</b> <a href="HexagonGenPredicate_8cpp_source.html#l00134">HexagonGenPredicate.cpp:134</a></div></div>
<div class="ttc" id="alib_2Target_2README_8txt_html_a61e3352b507034570df5d83e074402fd"><div class="ttname"><a href="lib_2Target_2README_8txt.html#a61e3352b507034570df5d83e074402fd">instcombine</a></div><div class="ttdeci">but this requires TBAA This isn t recognized as bswap by instcombine(yes, it really is bswap)</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2README_8txt_source.html#l00191">README.txt:191</a></div></div>
<div class="ttc" id="alib_2Target_2WebAssembly_2README_8txt_html_a61226fa05e1758fc6dd5eea2e25f7982"><div class="ttname"><a href="lib_2Target_2WebAssembly_2README_8txt.html#a61226fa05e1758fc6dd5eea2e25f7982">page</a></div><div class="ttdeci">The object format emitted by the WebAssembly backed is documented see the home page</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2WebAssembly_2README_8txt_source.html#l00016">README.txt:16</a></div></div>
<div class="ttc" id="alib_2Target_2Sparc_2README_8txt_html_ac3f862906f3d8d19b5acb04ba070bd44"><div class="ttname"><a href="lib_2Target_2Sparc_2README_8txt.html#ac3f862906f3d8d19b5acb04ba070bd44">i0</a></div><div class="ttdeci">To do *Keep the address of the constant pool in a register instead of forming its address all of the time *We can fold small constant offsets into the hi lo references to constant pool addresses as well *When in V9 register allocate icc *[0-3] Add support for isel ing UMUL_LOHI instead of marking it as Expand *Emit the Branch on Integer Register with Prediction instructions It s not clear how to write a pattern for this int o6 subcc i0</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2Sparc_2README_8txt_source.html#l00027">README.txt:27</a></div></div>
<div class="ttc" id="alib_2Target_2X86_2README_8txt_html_aa1d713c4929bd4a6ade58ed6d0a94e18"><div class="ttname"><a href="lib_2Target_2X86_2README_8txt.html#aa1d713c4929bd4a6ade58ed6d0a94e18">tmp621622</a></div><div class="ttdeci">&lt; i32 &gt; tmp621622</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2X86_2README_8txt_source.html#l00564">README.txt:564</a></div></div>
<div class="ttc" id="alib_2Target_2X86_2README_8txt_html_a970bf9d5586214e6159f351ee4d50d05"><div class="ttname"><a href="lib_2Target_2X86_2README_8txt.html#a970bf9d5586214e6159f351ee4d50d05">addl</a></div><div class="ttdeci">is currently compiled esp esp jne LBB1_1 addl</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2X86_2README_8txt_source.html#l00397">README.txt:397</a></div></div>
<div class="ttc" id="alib_2CodeGen_2README_8txt_html_a09776db24cf586ec9f1e18f3bae14099"><div class="ttname"><a href="lib_2CodeGen_2README_8txt.html#a09776db24cf586ec9f1e18f3bae14099">BB</a></div><div class="ttdeci">Common register allocation spilling lr str ldr sxth r3 ldr mla r4 can lr mov lr str ldr sxth r3 mla r4 and then merge mul and lr str ldr sxth r3 mla r4 It also increase the likelihood the store may become dead bb27 Successors according to LLVM BB</div><div class="ttdef"><b>Definition:</b> <a href="lib_2CodeGen_2README_8txt_source.html#l00039">README.txt:39</a></div></div>
<div class="ttc" id="alib_2Target_2PowerPC_2README_8txt_html_ade29c20cb8af8f2ab2edba746ff3f5e4"><div class="ttname"><a href="lib_2Target_2PowerPC_2README_8txt.html#ade29c20cb8af8f2ab2edba746ff3f5e4">f2</a></div><div class="ttdeci">cond_true lis lo16() lo16() lo16() f1 fsel f2</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2PowerPC_2README_8txt_source.html#l00105">README.txt:105</a></div></div>
<div class="ttc" id="alib_2Target_2README_8txt_html_ac23ad17abc8e532fd42fd45cdb487744"><div class="ttname"><a href="lib_2Target_2README_8txt.html#ac23ad17abc8e532fd42fd45cdb487744">b0</a></div><div class="ttdeci">int b0</div></div>
<div class="ttc" id="alib_2CodeGen_2README_8txt_html_a3fef6e4a83d2d619d46298f2ea45ca6d"><div class="ttname"><a href="lib_2CodeGen_2README_8txt.html#a3fef6e4a83d2d619d46298f2ea45ca6d">problem</a></div><div class="ttdeci">Common register allocation spilling problem</div><div class="ttdef"><b>Definition:</b> <a href="lib_2CodeGen_2README_8txt_source.html#l00005">README.txt:5</a></div></div>
<div class="ttc" id="aREADME-SSE_8txt_html_aab39054d94a440b7b09d0458d26767f3"><div class="ttname"><a href="README-SSE_8txt.html#aab39054d94a440b7b09d0458d26767f3">tmp11</a></div><div class="ttdeci">&lt; i128 &gt;&lt; i128 &gt; tmp11</div><div class="ttdef"><b>Definition:</b> <a href="README-SSE_8txt_source.html#l00792">README-SSE.txt:792</a></div></div>
<div class="ttc" id="ainclude_2llvm_2Demangle_2README_8txt_html_a9cb0c93da8300337dbb7dfe980112f24"><div class="ttname"><a href="include_2llvm_2Demangle_2README_8txt.html#a9cb0c93da8300337dbb7dfe980112f24">changes</a></div><div class="ttdeci">test_demangle and llvm unittest Demangle The llvm directory should only get tests for stuff not included in the core library In the future we should probably move all the tests to LLVM It is also a really good idea to run libFuzzer after non trivial changes</div><div class="ttdef"><b>Definition:</b> <a href="include_2llvm_2Demangle_2README_8txt_source.html#l00060">README.txt:60</a></div></div>
<div class="ttc" id="alib_2Target_2ARM_2README_8txt_html_ab771f8a39dba21a97127e869838c92a4"><div class="ttname"><a href="lib_2Target_2ARM_2README_8txt.html#ab771f8a39dba21a97127e869838c92a4">stmia</a></div><div class="ttdeci">add sub stmia L5 ldr r0 bl L_printf $stub Instead of a stmia</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2ARM_2README_8txt_source.html#l00204">README.txt:204</a></div></div>
<div class="ttc" id="alib_2Target_2X86_2README_8txt_html_a96ccf5cfb52d627161ce94e8098cb91a"><div class="ttname"><a href="lib_2Target_2X86_2README_8txt.html#a96ccf5cfb52d627161ce94e8098cb91a">nounwind</a></div><div class="ttdeci">this lets us change the cmpl into a which is and eliminate the shift We compile this i32 i32 i8 zeroext d nounwind</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2X86_2README_8txt_source.html#l00973">README.txt:973</a></div></div>
<div class="ttc" id="alib_2Target_2X86_2README_8txt_html_a50cdffb346dd4c265077f333cde8c90c"><div class="ttname"><a href="lib_2Target_2X86_2README_8txt.html#a50cdffb346dd4c265077f333cde8c90c">iPTR</a></div><div class="ttdeci">gets compiled into this on rsp movaps rsp movaps rsp movaps rsp movaps rsp movaps rsp movaps rsp movaps rsp movaps rsp movq rsp movq rsp movq rsp movq rsp movq rsp rax movq rsp rax movq rsp rsp rsp eax eax jbe LBB1_3 rcx rax movq rsp eax rsp ret ecx eax rcx movl rsp jmp LBB1_2 gcc rsp rax movq rsp rsp movq rsp rax movq rsp eax eax jb L6 rdx eax rsp ret p2align edx rdx eax movl rsp eax rsp ret and it gets compiled into this on ebp esp eax movl ebp eax movl ebp eax esp popl ebp ret gcc ebp eax popl ebp ret Teach tblgen not to check bitconvert source type in some cases This allows us to consolidate the following patterns in X86InstrMMX iPTR</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2X86_2README_8txt_source.html#l01205">README.txt:1205</a></div></div>
<div class="ttc" id="aBlockVerifier_8cpp_html_ae45c7d73c0ff5d177b59153ffae77f84"><div class="ttname"><a href="BlockVerifier_8cpp.html#ae45c7d73c0ff5d177b59153ffae77f84">From</a></div><div class="ttdeci">BlockVerifier::State From</div><div class="ttdef"><b>Definition:</b> <a href="BlockVerifier_8cpp_source.html#l00055">BlockVerifier.cpp:55</a></div></div>
<div class="ttc" id="alib_2Target_2README_8txt_html_a34d3cc61972fee545eef549e7d4a1022"><div class="ttname"><a href="lib_2Target_2README_8txt.html#a34d3cc61972fee545eef549e7d4a1022">PR16157</a></div><div class="ttdeci">This is blocked on not handling X *X *X which is the same number of multiplies and is because the *X has multiple uses Here s a simple X1 B ret i32 C Reassociate should handle the example in GCC PR16157</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2README_8txt_source.html#l00084">README.txt:84</a></div></div>
<div class="ttc" id="alib_2Target_2ARM_2README_8txt_html_ae430ee5ab66d7b98e0c8506aa0733d10"><div class="ttname"><a href="lib_2Target_2ARM_2README_8txt.html#ae430ee5ab66d7b98e0c8506aa0733d10">larger</a></div><div class="ttdeci">the resulting code requires compare and branches when and if the revised code is larger</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2ARM_2README_8txt_source.html#l00397">README.txt:397</a></div></div>
<div class="ttc" id="alib_2Target_2X86_2README_8txt_html_a437450e3817745a1aaf814b5c9434c1e"><div class="ttname"><a href="lib_2Target_2X86_2README_8txt.html#a437450e3817745a1aaf814b5c9434c1e">movsbl</a></div><div class="ttdeci">we currently eax movsbl(%esp)</div></div>
<div class="ttc" id="alib_2Target_2X86_2README_8txt_html_a785c9dfdb866450ed1036beafcf494e6"><div class="ttname"><a href="lib_2Target_2X86_2README_8txt.html#a785c9dfdb866450ed1036beafcf494e6">callee</a></div><div class="ttdeci">Here we don t need to write any variables to the top of the stack since they don t overwrite each other int callee(int32 arg1, int32 arg2)</div></div>
<div class="ttc" id="aREADME-Thumb_8txt_html_aa36a842dc9742127230b93f16e106ddd"><div class="ttname"><a href="README-Thumb_8txt.html#aa36a842dc9742127230b93f16e106ddd">abort</a></div><div class="ttdeci">*Add support for compiling functions in both ARM and Thumb then taking the smallest *Add support for compiling individual basic blocks in thumb when in a larger ARM function This can be used for presumed cold like paths to abort(failure path of asserts)</div></div>
<div class="ttc" id="alib_2Target_2README_8txt_html_a6d5b86cb24bf024e107bda83f8557a00"><div class="ttname"><a href="lib_2Target_2README_8txt.html#a6d5b86cb24bf024e107bda83f8557a00">setlt</a></div><div class="ttdeci">This would be a win on but not x86 or ppc64 setlt(loadi8 Phi)</div></div>
<div class="ttc" id="alib_2Target_2X86_2README_8txt_html_a6271cc3a15654fc128d8e7c588e7c604"><div class="ttname"><a href="lib_2Target_2X86_2README_8txt.html#a6271cc3a15654fc128d8e7c588e7c604">FirstOnet</a></div><div class="ttdeci">int FirstOnet(unsigned long long arg1)</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2X86_2README_8txt_source.html#l00944">README.txt:944</a></div></div>
<div class="ttc" id="alib_2Target_2PowerPC_2README_8txt_html_a9ac886834400037de3b5d158b1afe0d1"><div class="ttname"><a href="lib_2Target_2PowerPC_2README_8txt.html#a9ac886834400037de3b5d158b1afe0d1">code</a></div><div class="ttdeci">entry mr r2 blr This could be reduced to the much andc r2 r3 slwi or r2 rlwimi stw r3 blr We could collapse a bunch of those ORs and ANDs and generate the following equivalent code</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2PowerPC_2README_8txt_source.html#l00282">README.txt:282</a></div></div>
<div class="ttc" id="alib_2Target_2X86_2README_8txt_html_a2b27a71be51aa01268d023ee33f8e87d"><div class="ttname"><a href="lib_2Target_2X86_2README_8txt.html#a2b27a71be51aa01268d023ee33f8e87d">cycles</a></div><div class="ttdeci">the multiplication has a latency of four cycles</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2X86_2README_8txt_source.html#l00253">README.txt:253</a></div></div>
<div class="ttc" id="aclassStringView_html_ac6a261495b8a876756bd5554efc7a80f"><div class="ttname"><a href="classStringView.html#ac6a261495b8a876756bd5554efc7a80f">StringView::consumeFront</a></div><div class="ttdeci">bool consumeFront(StringView S)</div><div class="ttdef"><b>Definition:</b> <a href="StringView_8h_source.html#l00092">StringView.h:92</a></div></div>
<div class="ttc" id="aREADME-SSE_8txt_html_a7246178f42b1eaef4e9bba10a9f39323"><div class="ttname"><a href="README-SSE_8txt.html#a7246178f42b1eaef4e9bba10a9f39323">spill</a></div><div class="ttdeci">the custom lowered code happens to be but we shouldn t have to custom lower anything This is probably related to&lt; 2 x i64 &gt; ops being so bad LLVM currently generates stack realignment when it is not necessary needed The problem is that we need to know about stack alignment too before RA runs At that point we don t whether there will be vector spill</div><div class="ttdef"><b>Definition:</b> <a href="README-SSE_8txt_source.html#l00489">README-SSE.txt:489</a></div></div>
<div class="ttc" id="aclassStringView_html_a0160a9a200781152345163439bb90b38"><div class="ttname"><a href="classStringView.html#a0160a9a200781152345163439bb90b38">StringView::StringView</a></div><div class="ttdeci">StringView(const char *First_, const char *Last_)</div><div class="ttdef"><b>Definition:</b> <a href="StringView_8h_source.html#l00034">StringView.h:34</a></div></div>
<div class="ttc" id="alib_2Target_2README_8txt_html_af3a4e8c94127ff27b004aa01fb262b33"><div class="ttname"><a href="lib_2Target_2README_8txt.html#af3a4e8c94127ff27b004aa01fb262b33">Alt</a></div><div class="ttdeci">bool Alt</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2README_8txt_source.html#l00468">README.txt:468</a></div></div>
<div class="ttc" id="alib_2Target_2ARM_2README_8txt_html_a901ce7389ca67dd79b8ab5b53c4a7da8"><div class="ttname"><a href="lib_2Target_2ARM_2README_8txt.html#a901ce7389ca67dd79b8ab5b53c4a7da8">d</a></div><div class="ttdeci">the resulting code requires compare and branches when and if the revised code is with conditional branches instead of More there is a byte word extend before each where there should be only and the condition codes are not remembered when the same two values are compared twice More LSR enhancements i8 and i32 load store addressing modes are identical int int int d</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2ARM_2README_8txt_source.html#l00418">README.txt:418</a></div></div>
<div class="ttc" id="alib_2Target_2PowerPC_2README_8txt_html_ada850988c84db1ddff56d958ea833f5b"><div class="ttname"><a href="lib_2Target_2PowerPC_2README_8txt.html#ada850988c84db1ddff56d958ea833f5b">r11</a></div><div class="ttdeci">entry mflr r11 ***stw r11</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2PowerPC_2README_8txt_source.html#l00300">README.txt:300</a></div></div>
<div class="ttc" id="alib_2Target_2README_8txt_html_ab335e668fd33542ea14a2c7b527e64d3"><div class="ttname"><a href="lib_2Target_2README_8txt.html#ab335e668fd33542ea14a2c7b527e64d3">n</a></div><div class="ttdeci">The same transformation can work with an even modulo with the addition of a and shrink the compare RHS by the same amount Unless the target supports that transformation probably isn t worthwhile The transformation can also easily be made to work with non zero equality for n</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2README_8txt_source.html#l00685">README.txt:685</a></div></div>
<div class="ttc" id="alib_2Target_2X86_2README_8txt_html_a28623f3a9b25b0ddf3660467c9b40f38"><div class="ttname"><a href="lib_2Target_2X86_2README_8txt.html#a28623f3a9b25b0ddf3660467c9b40f38">optimization</a></div><div class="ttdeci">bar al al movzbl eax ret Missed optimization</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2X86_2README_8txt_source.html#l01411">README.txt:1411</a></div></div>
<div class="ttc" id="alib_2Target_2PowerPC_2README_8txt_html_a03839492807f9a086ebaddf732c71e7b"><div class="ttname"><a href="lib_2Target_2PowerPC_2README_8txt.html#a03839492807f9a086ebaddf732c71e7b">if</a></div><div class="ttdeci">if(sum+x&lt; x) z++</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2README_8txt_source.html#l00176">README.txt:176</a></div></div>
<div class="ttc" id="aREADME__ALTIVEC_8txt_html_ac2bca51fd633d11e41373896183538f6"><div class="ttname"><a href="README__ALTIVEC_8txt.html#ac2bca51fd633d11e41373896183538f6">registers</a></div><div class="ttdeci">Implement PPCInstrInfo::isLoadFromStackSlot isStoreToStackSlot for vector registers</div><div class="ttdef"><b>Definition:</b> <a href="README__ALTIVEC_8txt_source.html#l00004">README_ALTIVEC.txt:4</a></div></div>
<div class="ttc" id="aREADME-SSE_8txt_html_a22e7866be85852a21786d1c32d5999a6"><div class="ttname"><a href="README-SSE_8txt.html#a22e7866be85852a21786d1c32d5999a6">model</a></div><div class="ttdeci">This currently compiles esp xmm0 movsd esp eax eax esp ret We should use not the dag combiner This is because dagcombine2 needs to be able to see through the X86ISD::Wrapper which DAGCombine can t really do The code for turning x load into a single vector load is target independent and should be moved to the dag combiner The code for turning x load into a vector load can only handle a direct load from a global or a direct load from the stack It should be generalized to handle any load from where P can be anything The alignment inference code cannot handle loads from globals in static non mode because it doesn t look through the extra dyld stub load If you try vec_align ll without relocation model</div><div class="ttdef"><b>Definition:</b> <a href="README-SSE_8txt_source.html#l00414">README-SSE.txt:414</a></div></div>
<div class="ttc" id="alib_2Target_2README_8txt_html_ac44f9b3e1a84f4ae2264360efdebbd00"><div class="ttname"><a href="lib_2Target_2README_8txt.html#ac44f9b3e1a84f4ae2264360efdebbd00">functions</a></div><div class="ttdeci">aka conv or ret i32 or6 or even i depending on the speed of the multiplier The best way to handle this is to canonicalize it to a multiply in IR and have codegen handle lowering multiplies to shifts on cpus where shifts are faster We do a number of simplifications in simplify libcalls to strength reduce standard library functions</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2README_8txt_source.html#l00631">README.txt:631</a></div></div>
<div class="ttc" id="aARCBranchFinalize_8cpp_html_a14311558a7445776def2d5bc13161ba3"><div class="ttname"><a href="ARCBranchFinalize_8cpp.html#a14311558a7445776def2d5bc13161ba3">branches</a></div><div class="ttdeci">arc branch ARC finalize branches</div><div class="ttdef"><b>Definition:</b> <a href="ARCBranchFinalize_8cpp_source.html#l00066">ARCBranchFinalize.cpp:66</a></div></div>
<div class="ttc" id="alib_2Target_2README_8txt_html_afdf2770d4d0e00f3875afd6e7c61aa9d"><div class="ttname"><a href="lib_2Target_2README_8txt.html#afdf2770d4d0e00f3875afd6e7c61aa9d">X86</a></div><div class="ttdeci">Unrolling by would eliminate the &amp;in both leading to a net reduction in code size The resultant code would then also be suitable for exit value computation We miss a bunch of rotate opportunities on various including etc On X86</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2README_8txt_source.html#l00568">README.txt:568</a></div></div>
<div class="ttc" id="alib_2Target_2WebAssembly_2README_8txt_html_a79ea041233b5866026c3071dfc464ec0"><div class="ttname"><a href="lib_2Target_2WebAssembly_2README_8txt.html#a79ea041233b5866026c3071dfc464ec0">copy</a></div><div class="ttdeci">we should consider alternate ways to model stack dependencies Lots of things could be done in WebAssemblyTargetTransformInfo cpp there are numerous optimization related hooks that can be overridden in WebAssemblyTargetLowering Instead of the OptimizeReturned which should consider preserving the returned attribute through to MachineInstrs and extending the MemIntrinsicResults pass to do this optimization on calls too That would also let the WebAssemblyPeephole pass clean up dead defs for such as it does for stores Consider implementing and or getMachineCombinerPatterns Find a clean way to fix the problem which leads to the Shrink Wrapping pass being run after the WebAssembly PEI pass When setting multiple variables to the same we currently get code like const It could be done with a smaller encoding like local tee $pop5 local copy</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2WebAssembly_2README_8txt_source.html#l00101">README.txt:101</a></div></div>
<div class="ttc" id="anamespacellvm_html_a2816e84a08c108d18bc4665bc1817e01"><div class="ttname"><a href="namespacellvm.html#a2816e84a08c108d18bc4665bc1817e01">llvm::abs</a></div><div class="ttdeci">APFloat abs(APFloat X)</div><div class="ttdoc">Returns the absolute value of the argument.</div><div class="ttdef"><b>Definition:</b> <a href="APFloat_8h_source.html#l01332">APFloat.h:1332</a></div></div>
<div class="ttc" id="alib_2Target_2WebAssembly_2README_8txt_html_a1e4dc01b2e53f435ebc94d6bd0f33796"><div class="ttname"><a href="lib_2Target_2WebAssembly_2README_8txt.html#a1e4dc01b2e53f435ebc94d6bd0f33796">emscripten</a></div><div class="ttdeci">The object format emitted by the WebAssembly backed is documented see the home and packaging for producing WebAssembly applications that can run in browsers and other environments wasi sdk provides a more minimal C C SDK based on llvm and a libc based on for producing WebAssemmbly applictions that use the WASI ABI Rust provides WebAssembly support integrated into Cargo There are two main which provides a relatively minimal environment that has an emphasis on being native wasm32 unknown emscripten</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2WebAssembly_2README_8txt_source.html#l00026">README.txt:26</a></div></div>
<div class="ttc" id="alib_2Target_2ARM_2README_8txt_html_a76ab33dc07902ff6db42657321a22154"><div class="ttname"><a href="lib_2Target_2ARM_2README_8txt.html#a76ab33dc07902ff6db42657321a22154">r2</a></div><div class="ttdeci">llvm ldr r2</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2ARM_2README_8txt_source.html#l00126">README.txt:126</a></div></div>
<div class="ttc" id="alib_2Target_2PowerPC_2README_8txt_html_aedc03c509f8675fe4598af61b18f5489"><div class="ttname"><a href="lib_2Target_2PowerPC_2README_8txt.html#aedc03c509f8675fe4598af61b18f5489">_foo</a></div><div class="ttdeci">So that _foo</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2PowerPC_2README_8txt_source.html#l00132">README.txt:132</a></div></div>
<div class="ttc" id="alib_2Target_2README_8txt_html_aae67c508d4f0716516f5c412c5592556"><div class="ttname"><a href="lib_2Target_2README_8txt.html#aae67c508d4f0716516f5c412c5592556">result</a></div><div class="ttdeci">then result</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2README_8txt_source.html#l00355">README.txt:355</a></div></div>
<div class="ttc" id="alib_2Target_2PowerPC_2README_8txt_html_a48b7bab6e856fc5a11b20a99e47afb46"><div class="ttname"><a href="lib_2Target_2PowerPC_2README_8txt.html#a48b7bab6e856fc5a11b20a99e47afb46">produce</a></div><div class="ttdeci">bb420 i The CBE manages to produce</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2PowerPC_2README_8txt_source.html#l00049">README.txt:49</a></div></div>
<div class="ttc" id="alib_2CodeGen_2README_8txt_html_a3625bbe909f59184d26d2652d7f5119b"><div class="ttname"><a href="lib_2CodeGen_2README_8txt.html#a3625bbe909f59184d26d2652d7f5119b">libcall</a></div><div class="ttdeci">Common register allocation spilling lr str ldr sxth r3 ldr mla r4 can lr mov lr str ldr sxth r3 mla r4 and then merge mul and lr str ldr sxth r3 mla r4 It also increase the likelihood the store may become dead bb27 Successors according to LLVM ID Predecessors according to mbb&lt; bb27, 0x8b0a7c0 &gt; Note ADDri is not a two address instruction its result reg1037 is an operand of the PHI node in bb76 and its operand reg1039 is the result of the PHI node We should treat it as a two address code and make sure the ADDri is scheduled after any node that reads reg1039 Use info(i.e. register scavenger) to assign it a free register to allow reuse the collector could move the objects and invalidate the derived pointer This is bad enough in the first but safe points can crop up unpredictably **array_addr i32 n y store obj obj **nth_el If the i64 division is lowered to a libcall</div><div class="ttdef"><b>Definition:</b> <a href="lib_2CodeGen_2README_8txt_source.html#l00127">README.txt:127</a></div></div>
<div class="ttc" id="anamespaceshuffles_html_a9d83fc18d0aabf83c6fc9c7cc2138bd5"><div class="ttname"><a href="namespaceshuffles.html#a9d83fc18d0aabf83c6fc9c7cc2138bd5">shuffles::lo</a></div><div class="ttdeci">ArrayRef&lt; int &gt; lo(ArrayRef&lt; int &gt; Vuu)</div><div class="ttdef"><b>Definition:</b> <a href="HexagonISelDAGToDAGHVX_8cpp_source.html#l00813">HexagonISelDAGToDAGHVX.cpp:813</a></div></div>
<div class="ttc" id="alib_2Target_2X86_2README_8txt_html_adc433544e34d93fdcd7fe4b4ce6446a5"><div class="ttname"><a href="lib_2Target_2X86_2README_8txt.html#adc433544e34d93fdcd7fe4b4ce6446a5">LBB0_2</a></div><div class="ttdeci">&lt; i32 &gt; ret i32 tmp10 ecx esp je LBB0_2 eax addl eax ret LBB0_2</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2X86_2README_8txt_source.html#l00999">README.txt:999</a></div></div>
<div class="ttc" id="aNaryReassociate_8cpp_html_aaa35e44fa424e6bd06e6fa74efd060b9"><div class="ttname"><a href="NaryReassociate_8cpp.html#aaa35e44fa424e6bd06e6fa74efd060b9">reassociate</a></div><div class="ttdeci">nary reassociate</div><div class="ttdef"><b>Definition:</b> <a href="NaryReassociate_8cpp_source.html#l00162">NaryReassociate.cpp:162</a></div></div>
<div class="ttc" id="aMustExecute_8cpp_html_ac00fd2bd5d2febf1f9988294a6c56b33"><div class="ttname"><a href="MustExecute_8cpp.html#ac00fd2bd5d2febf1f9988294a6c56b33">entry</a></div><div class="ttdeci">print Instructions which execute on loop entry</div><div class="ttdef"><b>Definition:</b> <a href="MustExecute_8cpp_source.html#l00346">MustExecute.cpp:346</a></div></div>
<div class="ttc" id="alib_2Support_2Unix_2README_8txt_html_a91749ec0330a4667d62ff05db9dca76b"><div class="ttname"><a href="lib_2Support_2Unix_2README_8txt.html#a91749ec0330a4667d62ff05db9dca76b">Also</a></div><div class="ttdeci">llvm lib Support Unix the directory structure underneath this directory could look like only those directories actually needing to be created should be created Also</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Support_2Unix_2README_8txt_source.html#l00014">README.txt:14</a></div></div>
<div class="ttc" id="aregcomp_8c_html_a12c2040f25d8e3a7b9e1c2024c618cb6"><div class="ttname"><a href="regcomp_8c.html#a12c2040f25d8e3a7b9e1c2024c618cb6">INF</a></div><div class="ttdeci">#define INF</div></div>
<div class="ttc" id="anamespacellvm_1_1support_html_ae0a227ae1b2ada1da82b40479251862caf4dde139c69886de52e29ed6ac2bc963"><div class="ttname"><a href="namespacellvm_1_1support.html#ae0a227ae1b2ada1da82b40479251862caf4dde139c69886de52e29ed6ac2bc963">llvm::support::big</a></div><div class="ttdeci">@ big</div><div class="ttdef"><b>Definition:</b> <a href="Endian_8h_source.html#l00027">Endian.h:27</a></div></div>
<div class="ttc" id="alib_2Target_2X86_2README_8txt_html_a508550a3010fe71be1527ae07b5902bb"><div class="ttname"><a href="lib_2Target_2X86_2README_8txt.html#a508550a3010fe71be1527ae07b5902bb">faster</a></div><div class="ttdeci">_test eax eax ret Leaf functions that require one byte spill slot have a prolog like esp and an epilog like esp popl esi ret It would be and potentially faster</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2X86_2README_8txt_source.html#l00479">README.txt:479</a></div></div>
<div class="ttc" id="alib_2Target_2X86_2README_8txt_html_a91ba164a01527d0e71b4bd045766aa44"><div class="ttname"><a href="lib_2Target_2X86_2README_8txt.html#a91ba164a01527d0e71b4bd045766aa44">ebx</a></div><div class="ttdeci">http eax xorl edx cl sete al setne dl sall eax sall edx But that requires good bit subreg support this might be better It s an extra but it s one instruction and doesn t stress bit subreg eax eax movl edx edx sall eax sall cl edx bit we should expand to a conditional branch like GCC produces Some isel and Sequencing of Instructions Scheduling for reduced register pressure E g Minimum Register Instruction Sequence load p Because the compare isn t it is not matched with the load on both sides The dag combiner should be made smart enough to canonicalize the load into the RHS of a compare when it can invert the result of the compare for free In many LLVM generates code like eax cmpl esp setl al movzbl eax ret on some it is more efficient to do ebx xor eax cmpl ebx</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2X86_2README_8txt_source.html#l00097">README.txt:97</a></div></div>
<div class="ttc" id="alib_2Target_2README_8txt_html_ace6b37d5eaf50e6fd3465513bc022e93"><div class="ttname"><a href="lib_2Target_2README_8txt.html#ace6b37d5eaf50e6fd3465513bc022e93">of</a></div><div class="ttdeci">Add support for conditional and other related patterns Instead of</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2README_8txt_source.html#l00134">README.txt:134</a></div></div>
<div class="ttc" id="alib_2Target_2ARM_2README_8txt_html_adc3e7e5309d3be60f3218928d26a2a5c"><div class="ttname"><a href="lib_2Target_2ARM_2README_8txt.html#adc3e7e5309d3be60f3218928d26a2a5c">__Z11no_overflowjj</a></div><div class="ttdeci">Should compile r2 movcc movcs str strb mov lr r1 movcs movcc mov lr r1 str mov mov cmp r1 movlo r2 str bx lr __Z11no_overflowjj</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2ARM_2README_8txt_source.html#l00474">README.txt:474</a></div></div>
<div class="ttc" id="aRuntimeDyldELF_8cpp_html_a79ab15165c16fbf94d6fd33bd890ea7e"><div class="ttname"><a href="RuntimeDyldELF_8cpp.html#a79ab15165c16fbf94d6fd33bd890ea7e">write</a></div><div class="ttdeci">static void write(bool isBE, void *P, T V)</div><div class="ttdef"><b>Definition:</b> <a href="RuntimeDyldELF_8cpp_source.html#l00037">RuntimeDyldELF.cpp:37</a></div></div>
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Aug 7 2023 09:45:13 for LLVM by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
