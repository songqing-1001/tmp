<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>LLVM: include/llvm/ADT/STLExtras.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">LLVM
   &#160;<span id="projectnumber">17.0.0git</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_d44c64559bbebec7f509842c48db8b23.html">include</a></li><li class="navelem"><a class="el" href="dir_dcde91663b8816e1e2311938ccd8f690.html">llvm</a></li><li class="navelem"><a class="el" href="dir_32453792af2ba70c54e3ccae3a790d1b.html">ADT</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#namespaces">Namespaces</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">STLExtras.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &quot;<a class="el" href="Hashing_8h_source.html">llvm/ADT/Hashing.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="STLForwardCompat_8h_source.html">llvm/ADT/STLForwardCompat.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="STLFunctionalExtras_8h_source.html">llvm/ADT/STLFunctionalExtras.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="identity_8h_source.html">llvm/ADT/identity.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="iterator_8h_source.html">llvm/ADT/iterator.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="iterator__range_8h_source.html">llvm/ADT/iterator_range.h</a>&quot;</code><br />
<code>#include &quot;llvm/Config/abi-breaking.h&quot;</code><br />
<code>#include &quot;<a class="el" href="Support_2ErrorHandling_8h_source.html">llvm/Support/ErrorHandling.h</a>&quot;</code><br />
<code>#include &lt;algorithm&gt;</code><br />
<code>#include &lt;cassert&gt;</code><br />
<code>#include &lt;cstddef&gt;</code><br />
<code>#include &lt;cstdint&gt;</code><br />
<code>#include &lt;cstdlib&gt;</code><br />
<code>#include &lt;functional&gt;</code><br />
<code>#include &lt;initializer_list&gt;</code><br />
<code>#include &lt;iterator&gt;</code><br />
<code>#include &lt;limits&gt;</code><br />
<code>#include &lt;memory&gt;</code><br />
<code>#include &lt;optional&gt;</code><br />
<code>#include &lt;tuple&gt;</code><br />
<code>#include &lt;type_traits&gt;</code><br />
<code>#include &lt;utility&gt;</code><br />
</div><div class="textblock"><div class="dynheader">
Include dependency graph for STLExtras.h:</div>
<div class="dyncontent">
<div class="center"><img src="STLExtras_8h__incl.png" border="0" usemap="#include_2llvm_2ADT_2STLExtras_8h" alt=""/></div>
</div>
</div>
<p><a href="STLExtras_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structllvm_1_1SameType.html">llvm::SameType&lt; T, T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structllvm_1_1make__const__ptr.html">llvm::make_const_ptr&lt; T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structllvm_1_1make__const__ref.html">llvm::make_const_ref&lt; T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structllvm_1_1detail_1_1detector.html">llvm::detail::detector&lt; class, Op, Args &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structllvm_1_1detail_1_1detector_3_01std_1_1void__t_3_01Op_3_01Args_8_8_8_01_4_01_4_00_01Op_00_01Args_8_8_8_01_4.html">llvm::detail::detector&lt; std::void_t&lt; Op&lt; Args... &gt; &gt;, Op, Args... &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structllvm_1_1function__traits.html">llvm::function_traits&lt; T, isClass &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class provides various trait information about a callable object.  <a href="structllvm_1_1function__traits.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structllvm_1_1function__traits_3_01ReturnType_07ClassType_1_1_5_08_07Args_8_8_8_08_01const_00_01false_01_4.html">llvm::function_traits&lt; ReturnType(ClassType::*)(Args...) const, false &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload for class function types.  <a href="structllvm_1_1function__traits_3_01ReturnType_07ClassType_1_1_5_08_07Args_8_8_8_08_01const_00_01false_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structllvm_1_1function__traits_3_01ReturnType_07ClassType_1_1_5_08_07Args_8_8_8_08_00_01false_01_4.html">llvm::function_traits&lt; ReturnType(ClassType::*)(Args...), false &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload for class function types.  <a href="structllvm_1_1function__traits_3_01ReturnType_07ClassType_1_1_5_08_07Args_8_8_8_08_00_01false_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structllvm_1_1function__traits_3_01ReturnType_07_5_08_07Args_8_8_8_08_00_01false_01_4.html">llvm::function_traits&lt; ReturnType(*)(Args...), false &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload for non-class function types.  <a href="structllvm_1_1function__traits_3_01ReturnType_07_5_08_07Args_8_8_8_08_00_01false_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structllvm_1_1function__traits_3_01ReturnType_07_5const_08_07Args_8_8_8_08_00_01false_01_4.html">llvm::function_traits&lt; ReturnType(*const)(Args...), false &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structllvm_1_1function__traits_3_01ReturnType_07_6_08_07Args_8_8_8_08_00_01false_01_4.html">llvm::function_traits&lt; ReturnType(&amp;)(Args...), false &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload for non-class function type references.  <a href="structllvm_1_1function__traits_3_01ReturnType_07_6_08_07Args_8_8_8_08_00_01false_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structllvm_1_1detail_1_1TypesAreDistinct.html">llvm::detail::TypesAreDistinct&lt; T, Us &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structllvm_1_1detail_1_1TypesAreDistinct.html">llvm::detail::TypesAreDistinct&lt; T, Us &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structllvm_1_1detail_1_1TypesAreDistinct_3_01T_01_4.html">llvm::detail::TypesAreDistinct&lt; T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structllvm_1_1TypesAreDistinct.html">llvm::TypesAreDistinct&lt; Ts &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if all types in Ts are distinct.  <a href="structllvm_1_1TypesAreDistinct.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structllvm_1_1TypesAreDistinct_3_4.html">llvm::TypesAreDistinct&lt;&gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structllvm_1_1TypesAreDistinct.html">llvm::TypesAreDistinct&lt; Ts &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if all types in Ts are distinct.  <a href="structllvm_1_1TypesAreDistinct.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structllvm_1_1FirstIndexOfType.html">llvm::FirstIndexOfType&lt; T, Us &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the first index where a type appears in a list of types.  <a href="structllvm_1_1FirstIndexOfType.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structllvm_1_1FirstIndexOfType_3_01T_00_01U_00_01Us_8_8_8_01_4.html">llvm::FirstIndexOfType&lt; T, U, Us... &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structllvm_1_1FirstIndexOfType_3_01T_00_01T_00_01Us_8_8_8_01_4.html">llvm::FirstIndexOfType&lt; T, T, Us... &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1callable__detail_1_1Callable.html">llvm::callable_detail::Callable&lt; T, bool &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Templated storage wrapper for a callable.  <a href="classllvm_1_1callable__detail_1_1Callable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1callable__detail_1_1Callable_3_01T_00_01true_01_4.html">llvm::callable_detail::Callable&lt; T, true &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1mapped__iterator.html">llvm::mapped_iterator&lt; ItTy, FuncTy, ReferenceTy &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1mapped__iterator__base.html">llvm::mapped_iterator_base&lt; DerivedT, ItTy, ReferenceTy &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A base type of mapped iterator, that is useful for building derived iterators that do not need/want to store the map function (as in <a class="el" href="classllvm_1_1mapped__iterator.html">mapped_iterator</a>).  <a href="classllvm_1_1mapped__iterator__base.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1has__rbegin__impl.html">llvm::has_rbegin_impl&lt; Ty &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper to determine if type <a class="el" href="classT.html">T</a> has a member called <a class="el" href="namespacellvm_1_1sys_1_1path.html#a61cb6d6afaefe6f98af9e82d977ad9b9" title="Get reverse begin iterator over path.">rbegin()</a>.  <a href="classllvm_1_1has__rbegin__impl.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structllvm_1_1has__rbegin.html">llvm::has_rbegin&lt; Ty &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Metafunction to determine if <a class="el" href="classT.html">T</a>&amp; or <a class="el" href="classT.html">T</a> has a member called <a class="el" href="namespacellvm_1_1sys_1_1path.html#a61cb6d6afaefe6f98af9e82d977ad9b9" title="Get reverse begin iterator over path.">rbegin()</a>.  <a href="structllvm_1_1has__rbegin.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1filter__iterator__base.html">llvm::filter_iterator_base&lt; WrappedIteratorT, PredicateT, IterTag &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An iterator adaptor that filters the elements of given inner iterators.  <a href="classllvm_1_1filter__iterator__base.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1filter__iterator__impl.html">llvm::filter_iterator_impl&lt; WrappedIteratorT, PredicateT, IterTag &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization of <a class="el" href="classllvm_1_1filter__iterator__base.html" title="An iterator adaptor that filters the elements of given inner iterators.">filter_iterator_base</a> for forward iteration only.  <a href="classllvm_1_1filter__iterator__impl.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1filter__iterator__impl_3_01WrappedIteratorT_00_01PredicateT_00_01std_1_1bidirectional__iterator__tag_01_4.html">llvm::filter_iterator_impl&lt; WrappedIteratorT, PredicateT, std::bidirectional_iterator_tag &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization of <a class="el" href="classllvm_1_1filter__iterator__base.html" title="An iterator adaptor that filters the elements of given inner iterators.">filter_iterator_base</a> for bidirectional iteration.  <a href="classllvm_1_1filter__iterator__impl_3_01WrappedIteratorT_00_01PredicateT_00_01std_1_1bidirectional__iterator__tag_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structllvm_1_1detail_1_1fwd__or__bidi__tag__impl.html">llvm::detail::fwd_or_bidi_tag_impl&lt; is_bidirectional &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structllvm_1_1detail_1_1fwd__or__bidi__tag__impl_3_01true_01_4.html">llvm::detail::fwd_or_bidi_tag_impl&lt; true &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structllvm_1_1detail_1_1fwd__or__bidi__tag.html">llvm::detail::fwd_or_bidi_tag&lt; IterT &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper which sets its type member to forward_iterator_tag if the category of <code>IterT</code> does not derive from bidirectional_iterator_tag, and to bidirectional_iterator_tag otherwise.  <a href="structllvm_1_1detail_1_1fwd__or__bidi__tag.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1early__inc__iterator__impl.html">llvm::early_inc_iterator_impl&lt; WrappedIteratorT &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A pseudo-iterator adaptor that is designed to implement "early increment" style loops.  <a href="classllvm_1_1early__inc__iterator__impl.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structllvm_1_1detail_1_1ZipTupleType.html">llvm::detail::ZipTupleType&lt; Iters &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structllvm_1_1detail_1_1zip__common.html">llvm::detail::zip_common&lt; ZipType, Iters &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structllvm_1_1detail_1_1zip__first.html">llvm::detail::zip_first&lt; Iters &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1detail_1_1zip__shortest.html">llvm::detail::zip_shortest&lt; Iters &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1detail_1_1zippy.html">llvm::detail::zippy&lt; ItType, Args &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structllvm_1_1detail_1_1ZipLongestItemType.html">llvm::detail::ZipLongestItemType&lt; Iter &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structllvm_1_1detail_1_1ZipLongestTupleType.html">llvm::detail::ZipLongestTupleType&lt; Iters &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1detail_1_1zip__longest__iterator.html">llvm::detail::zip_longest_iterator&lt; Iters &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1detail_1_1zip__longest__range.html">llvm::detail::zip_longest_range&lt; Args &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1concat__iterator.html">llvm::concat_iterator&lt; ValueT, IterTs &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterator wrapper that concatenates sequences together.  <a href="classllvm_1_1concat__iterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1detail_1_1concat__range.html">llvm::detail::concat_range&lt; ValueT, RangeTs &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper to store a sequence of ranges being concatenated and access them.  <a href="classllvm_1_1detail_1_1concat__range.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1indexed__accessor__iterator.html">llvm::indexed_accessor_iterator&lt; DerivedT, BaseT, T, PointerT, ReferenceT &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A utility class used to implement an iterator that contains some base object and an index.  <a href="classllvm_1_1indexed__accessor__iterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1detail_1_1indexed__accessor__range__base.html">llvm::detail::indexed_accessor_range_base&lt; DerivedT, BaseT, T, PointerT, ReferenceT &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The class represents the base of a range of indexed_accessor_iterators.  <a href="classllvm_1_1detail_1_1indexed__accessor__range__base.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1detail_1_1indexed__accessor__range__base_1_1iterator.html">llvm::detail::indexed_accessor_range_base&lt; DerivedT, BaseT, T, PointerT, ReferenceT &gt;::iterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An iterator element of this range.  <a href="classllvm_1_1detail_1_1indexed__accessor__range__base_1_1iterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1indexed__accessor__range.html">llvm::indexed_accessor_range&lt; DerivedT, BaseT, T, PointerT, ReferenceT &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class provides an implementation of a range of indexed_accessor_iterators where the base is not indexable.  <a href="classllvm_1_1indexed__accessor__range.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1detail_1_1first__or__second__type.html">llvm::detail::first_or_second_type&lt; EltTy, FirstTy &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a reference to the first or second member of a reference.  <a href="classllvm_1_1detail_1_1first__or__second__type.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structllvm_1_1less__first.html">llvm::less_first</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classllvm_1_1Function.html">Function</a> object to check whether the first component of a std::pair compares less than the first component of another std::pair.  <a href="structllvm_1_1less__first.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structllvm_1_1less__second.html">llvm::less_second</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classllvm_1_1Function.html">Function</a> object to check whether the second component of a std::pair compares less than the second component of another std::pair.  <a href="structllvm_1_1less__second.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structllvm_1_1on__first.html">llvm::on_first&lt; FuncTy &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classllvm_1_1Function.html">Function</a> object to apply a binary function to the first component of a std::pair.  <a href="structllvm_1_1on__first.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structllvm_1_1rank.html">llvm::rank&lt; N &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility type to build an inheritance chain that makes it easy to rank overload candidates.  <a href="structllvm_1_1rank.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structllvm_1_1rank_3_010_01_4.html">llvm::rank&lt; 0 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structllvm_1_1detail_1_1Visitor.html">llvm::detail::Visitor&lt; Ts &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structllvm_1_1detail_1_1Visitor_3_01HeadT_00_01TailTs_8_8_8_01_4.html">llvm::detail::Visitor&lt; HeadT, TailTs... &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structllvm_1_1detail_1_1Visitor_3_01HeadT_01_4.html">llvm::detail::Visitor&lt; HeadT &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structllvm_1_1FreeDeleter.html">llvm::FreeDeleter</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structllvm_1_1pair__hash.html">llvm::pair_hash&lt; First, Second &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structllvm_1_1deref.html">llvm::deref&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Binary functor that adapts to any other binary functor after dereferencing operands.  <a href="structllvm_1_1deref.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1detail_1_1enumerator__iter.html">llvm::detail::enumerator_iter&lt; R &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structllvm_1_1detail_1_1result__pair.html">llvm::detail::result_pair&lt; R &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1detail_1_1enumerator__iter.html">llvm::detail::enumerator_iter&lt; R &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1detail_1_1enumerator.html">llvm::detail::enumerator&lt; R &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstd_1_1tuple__size_3_01llvm_1_1detail_1_1result__pair_3_01R_01_4_01_4.html">std::tuple_size&lt; llvm::detail::result_pair&lt; R &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstd_1_1tuple__element_3_01i_00_01llvm_1_1detail_1_1result__pair_3_01R_01_4_01_4.html">std::tuple_element&lt; i, llvm::detail::result_pair&lt; R &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacellvm"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacellvm.html">llvm</a></td></tr>
<tr class="memdesc:namespacellvm"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an optimization pass for GlobalISel generic memory operations. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacellvm_1_1detail"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacellvm_1_1detail.html">llvm::detail</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacellvm_1_1callable__detail"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacellvm_1_1callable__detail.html">llvm::callable_detail</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacellvm_1_1adl__detail"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacellvm_1_1adl__detail.html">llvm::adl_detail</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacestd"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestd.html">std</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ab3b502d4bf94f1adf7cfe50e0a2a0283"><td class="memTemplParams" colspan="2">template&lt;typename RangeT &gt; </td></tr>
<tr class="memitem:ab3b502d4bf94f1adf7cfe50e0a2a0283"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellvm_1_1detail.html#ab3b502d4bf94f1adf7cfe50e0a2a0283">llvm::detail::IterOfRange</a> = decltype(std::begin(std::declval&lt; RangeT &amp; &gt;()))</td></tr>
<tr class="separator:ab3b502d4bf94f1adf7cfe50e0a2a0283"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87b13495d5a43d47c9c0cf41d7144e1e"><td class="memTemplParams" colspan="2">template&lt;typename RangeT &gt; </td></tr>
<tr class="memitem:a87b13495d5a43d47c9c0cf41d7144e1e"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellvm_1_1detail.html#a87b13495d5a43d47c9c0cf41d7144e1e">llvm::detail::ValueOfRange</a> = std::remove_reference_t&lt; decltype(*std::begin(std::declval&lt; RangeT &amp; &gt;()))&gt;</td></tr>
<tr class="separator:a87b13495d5a43d47c9c0cf41d7144e1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5222d74738fef771d06ccec12e74cf97"><td class="memTemplParams" colspan="2">template&lt;template&lt; class... &gt; class Op, class... Args&gt; </td></tr>
<tr class="memitem:a5222d74738fef771d06ccec12e74cf97"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellvm.html#a5222d74738fef771d06ccec12e74cf97">llvm::is_detected</a> = typename detail::detector&lt; void, Op, Args... &gt;::value_t</td></tr>
<tr class="memdesc:a5222d74738fef771d06ccec12e74cf97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Detects if a given trait holds for some set of arguments 'Args'.  <a href="namespacellvm.html#a5222d74738fef771d06ccec12e74cf97">More...</a><br /></td></tr>
<tr class="separator:a5222d74738fef771d06ccec12e74cf97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc7b089876f826997a368b1fea8ff6c0"><td class="memTemplParams" colspan="2">template&lt;typename T , typename... Ts&gt; </td></tr>
<tr class="memitem:abc7b089876f826997a368b1fea8ff6c0"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellvm.html#abc7b089876f826997a368b1fea8ff6c0">llvm::is_one_of</a> = std::disjunction&lt; std::is_same&lt; <a class="el" href="classT.html">T</a>, Ts &gt;... &gt;</td></tr>
<tr class="memdesc:abc7b089876f826997a368b1fea8ff6c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">traits class for checking whether type <a class="el" href="classT.html">T</a> is one of any of the given types in the variadic list.  <a href="namespacellvm.html#abc7b089876f826997a368b1fea8ff6c0">More...</a><br /></td></tr>
<tr class="separator:abc7b089876f826997a368b1fea8ff6c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0906f96b26750ec1ef88a840fb363d31"><td class="memTemplParams" colspan="2">template&lt;typename T , typename... Ts&gt; </td></tr>
<tr class="memitem:a0906f96b26750ec1ef88a840fb363d31"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellvm.html#a0906f96b26750ec1ef88a840fb363d31">llvm::are_base_of</a> = std::conjunction&lt; std::is_base_of&lt; <a class="el" href="classT.html">T</a>, Ts &gt;... &gt;</td></tr>
<tr class="memdesc:a0906f96b26750ec1ef88a840fb363d31"><td class="mdescLeft">&#160;</td><td class="mdescRight">traits class for checking whether type <a class="el" href="classT.html">T</a> is a base class for all the given types in the variadic list.  <a href="namespacellvm.html#a0906f96b26750ec1ef88a840fb363d31">More...</a><br /></td></tr>
<tr class="separator:a0906f96b26750ec1ef88a840fb363d31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac82e29b9b3866b5fb0b0c0bb697f31b2"><td class="memTemplParams" colspan="2">template&lt;size_t I, typename... Ts&gt; </td></tr>
<tr class="memitem:ac82e29b9b3866b5fb0b0c0bb697f31b2"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellvm.html#ac82e29b9b3866b5fb0b0c0bb697f31b2">llvm::TypeAtIndex</a> = std::tuple_element_t&lt; <a class="el" href="MD5_8cpp.html#ac0eafdc9ee161b71e7af98af736952fd">I</a>, std::tuple&lt; Ts... &gt; &gt;</td></tr>
<tr class="memdesc:ac82e29b9b3866b5fb0b0c0bb697f31b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the type at a given index in a list of types.  <a href="namespacellvm.html#ac82e29b9b3866b5fb0b0c0bb697f31b2">More...</a><br /></td></tr>
<tr class="separator:ac82e29b9b3866b5fb0b0c0bb697f31b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96f911b322bfcce64d7060236901adbb"><td class="memTemplParams" colspan="2">template&lt;typename WrappedIteratorT , typename PredicateT &gt; </td></tr>
<tr class="memitem:a96f911b322bfcce64d7060236901adbb"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellvm.html#a96f911b322bfcce64d7060236901adbb">llvm::filter_iterator</a> = filter_iterator_impl&lt; <a class="el" href="classWrappedIteratorT.html">WrappedIteratorT</a>, <a class="el" href="classPredicateT.html">PredicateT</a>, typename detail::fwd_or_bidi_tag&lt; <a class="el" href="classWrappedIteratorT.html">WrappedIteratorT</a> &gt;::<a class="el" href="README-X86-64_8txt.html#aac3add0badd5c39bebc02df0b5d9bdcf">type</a> &gt;</td></tr>
<tr class="memdesc:a96f911b322bfcce64d7060236901adbb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines filter_iterator to a suitable specialization of <a class="el" href="classllvm_1_1filter__iterator__impl.html" title="Specialization of filter_iterator_base for forward iteration only.">filter_iterator_impl</a>, based on the underlying iterator's category.  <a href="namespacellvm.html#a96f911b322bfcce64d7060236901adbb">More...</a><br /></td></tr>
<tr class="separator:a96f911b322bfcce64d7060236901adbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24a049eea1730aaac6d72c50fbfe238a"><td class="memTemplParams" colspan="2">template&lt;typename ZipType , typename... Iters&gt; </td></tr>
<tr class="memitem:a24a049eea1730aaac6d72c50fbfe238a"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellvm_1_1detail.html#a24a049eea1730aaac6d72c50fbfe238a">llvm::detail::zip_traits</a> = iterator_facade_base&lt; ZipType, std::common_type_t&lt; std::bidirectional_iterator_tag, typename std::iterator_traits&lt; Iters &gt;::iterator_category... &gt;, typename ZipTupleType&lt; Iters... &gt;::<a class="el" href="README-X86-64_8txt.html#aac3add0badd5c39bebc02df0b5d9bdcf">type</a>, typename std::iterator_traits&lt; std::tuple_element_t&lt; 0, std::tuple&lt; Iters... &gt; &gt;&gt;::difference_type, typename ZipTupleType&lt; Iters... &gt;::<a class="el" href="README-X86-64_8txt.html#aac3add0badd5c39bebc02df0b5d9bdcf">type</a> *, typename ZipTupleType&lt; Iters... &gt;::<a class="el" href="README-X86-64_8txt.html#aac3add0badd5c39bebc02df0b5d9bdcf">type</a> &gt;</td></tr>
<tr class="separator:a24a049eea1730aaac6d72c50fbfe238a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5db5c4526a7906abfcd9e871e2559532"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a5db5c4526a7906abfcd9e871e2559532"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellvm_1_1detail.html#a5db5c4526a7906abfcd9e871e2559532">llvm::detail::sort_trivially_copyable</a> = std::conjunction&lt; std::is_pointer&lt; <a class="el" href="classT.html">T</a> &gt;, std::is_trivially_copyable&lt; typename std::iterator_traits&lt; <a class="el" href="classT.html">T</a> &gt;::value_type &gt; &gt;</td></tr>
<tr class="separator:a5db5c4526a7906abfcd9e871e2559532"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:af5aeb11199c6224e0dd1140204c40985"><td class="memTemplParams" colspan="2">template&lt;typename EnumTy1 , typename EnumTy2 , typename UT1  = std::enable_if_t&lt;std::is_enum&lt;EnumTy1&gt;::value,                                          std::underlying_type_t&lt;EnumTy1&gt;&gt;, typename UT2  = std::enable_if_t&lt;std::is_enum&lt;EnumTy2&gt;::value,                                          std::underlying_type_t&lt;EnumTy2&gt;&gt;&gt; </td></tr>
<tr class="memitem:af5aeb11199c6224e0dd1140204c40985"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellvm.html#af5aeb11199c6224e0dd1140204c40985">llvm::addEnumValues</a> (EnumTy1 <a class="el" href="X86PartialReduction_8cpp.html#a9e1483f7215664a2315c53c3558d9a8d">LHS</a>, EnumTy2 <a class="el" href="X86PartialReduction_8cpp.html#a87b8bfbbe9d8f7146d7f20a5fb42efd0">RHS</a>)</td></tr>
<tr class="memdesc:af5aeb11199c6224e0dd1140204c40985"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper which adds two underlying types of enumeration type.  <a href="namespacellvm.html#af5aeb11199c6224e0dd1140204c40985">More...</a><br /></td></tr>
<tr class="separator:af5aeb11199c6224e0dd1140204c40985"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f3e5084005cf0e5014e0ca7504ce399"><td class="memTemplParams" colspan="2">template&lt;typename ContainerTy &gt; </td></tr>
<tr class="memitem:a5f3e5084005cf0e5014e0ca7504ce399"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellvm_1_1adl__detail.html#a5f3e5084005cf0e5014e0ca7504ce399">llvm::adl_detail::adl_begin</a> (ContainerTy &amp;&amp;container)</td></tr>
<tr class="separator:a5f3e5084005cf0e5014e0ca7504ce399"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3969ddf16bfd23b6be1a0662cd383a5"><td class="memTemplParams" colspan="2">template&lt;typename ContainerTy &gt; </td></tr>
<tr class="memitem:af3969ddf16bfd23b6be1a0662cd383a5"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellvm_1_1adl__detail.html#af3969ddf16bfd23b6be1a0662cd383a5">llvm::adl_detail::adl_end</a> (ContainerTy &amp;&amp;container)</td></tr>
<tr class="separator:af3969ddf16bfd23b6be1a0662cd383a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36acc760326b76ec4fd78ea77c0d73aa"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a36acc760326b76ec4fd78ea77c0d73aa"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellvm_1_1adl__detail.html#a36acc760326b76ec4fd78ea77c0d73aa">llvm::adl_detail::adl_swap</a> (<a class="el" href="classT.html">T</a> &amp;&amp;lhs, <a class="el" href="classT.html">T</a> &amp;&amp;rhs) noexcept(noexcept(swap(std::declval&lt; <a class="el" href="classT.html">T</a> &gt;(), std::declval&lt; <a class="el" href="classT.html">T</a> &gt;())))</td></tr>
<tr class="separator:a36acc760326b76ec4fd78ea77c0d73aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58c992e206fc7bcb9be2d30be1381dc1"><td class="memTemplParams" colspan="2">template&lt;typename ContainerTy &gt; </td></tr>
<tr class="memitem:a58c992e206fc7bcb9be2d30be1381dc1"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellvm.html#a58c992e206fc7bcb9be2d30be1381dc1">llvm::adl_begin</a> (ContainerTy &amp;&amp;container)</td></tr>
<tr class="separator:a58c992e206fc7bcb9be2d30be1381dc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab61654c6c0f8b807e684fc0cea37c05f"><td class="memTemplParams" colspan="2">template&lt;typename ContainerTy &gt; </td></tr>
<tr class="memitem:ab61654c6c0f8b807e684fc0cea37c05f"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellvm.html#ab61654c6c0f8b807e684fc0cea37c05f">llvm::adl_end</a> (ContainerTy &amp;&amp;container)</td></tr>
<tr class="separator:ab61654c6c0f8b807e684fc0cea37c05f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87387cf1d55dabf01ef630a5a90c6859"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a87387cf1d55dabf01ef630a5a90c6859"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellvm.html#a87387cf1d55dabf01ef630a5a90c6859">llvm::adl_swap</a> (<a class="el" href="classT.html">T</a> &amp;&amp;lhs, <a class="el" href="classT.html">T</a> &amp;&amp;rhs) noexcept(noexcept(adl_detail::adl_swap(std::declval&lt; <a class="el" href="classT.html">T</a> &gt;(), std::declval&lt; <a class="el" href="classT.html">T</a> &gt;())))</td></tr>
<tr class="separator:a87387cf1d55dabf01ef630a5a90c6859"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88027543aef5a9bc0d82bc5e5e3506c3"><td class="memTemplParams" colspan="2">template&lt;typename ContainerTy &gt; </td></tr>
<tr class="memitem:a88027543aef5a9bc0d82bc5e5e3506c3"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellvm.html#a88027543aef5a9bc0d82bc5e5e3506c3">llvm::hasSingleElement</a> (ContainerTy &amp;&amp;<a class="el" href="README__ALTIVEC_8txt.html#a9aacd9146afe44bf656cd664e2a88c8c">C</a>)</td></tr>
<tr class="memdesc:a88027543aef5a9bc0d82bc5e5e3506c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the given container only contains a single element.  <a href="namespacellvm.html#a88027543aef5a9bc0d82bc5e5e3506c3">More...</a><br /></td></tr>
<tr class="separator:a88027543aef5a9bc0d82bc5e5e3506c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02981de53fb6ffd384d39addc4d25f37"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a02981de53fb6ffd384d39addc4d25f37"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellvm.html#a02981de53fb6ffd384d39addc4d25f37">llvm::drop_begin</a> (<a class="el" href="classT.html">T</a> &amp;&amp;RangeOrContainer, size_t <a class="el" href="regcomp_8c.html#a0240ac851181b84ac374872dc5434ee4">N</a>=1)</td></tr>
<tr class="memdesc:a02981de53fb6ffd384d39addc4d25f37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a range covering <code>RangeOrContainer</code> with the first N elements excluded.  <a href="namespacellvm.html#a02981de53fb6ffd384d39addc4d25f37">More...</a><br /></td></tr>
<tr class="separator:a02981de53fb6ffd384d39addc4d25f37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b64313b5c1907066b7bab1c60a2ea08"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a9b64313b5c1907066b7bab1c60a2ea08"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellvm.html#a9b64313b5c1907066b7bab1c60a2ea08">llvm::drop_end</a> (<a class="el" href="classT.html">T</a> &amp;&amp;RangeOrContainer, size_t <a class="el" href="regcomp_8c.html#a0240ac851181b84ac374872dc5434ee4">N</a>=1)</td></tr>
<tr class="memdesc:a9b64313b5c1907066b7bab1c60a2ea08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a range covering <code>RangeOrContainer</code> with the last N elements excluded.  <a href="namespacellvm.html#a9b64313b5c1907066b7bab1c60a2ea08">More...</a><br /></td></tr>
<tr class="separator:a9b64313b5c1907066b7bab1c60a2ea08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4bd116b41e412b1e0a91599be3c2b7a"><td class="memTemplParams" colspan="2">template&lt;class ItTy , class FuncTy &gt; </td></tr>
<tr class="memitem:ae4bd116b41e412b1e0a91599be3c2b7a"><td class="memTemplItemLeft" align="right" valign="top">mapped_iterator&lt; <a class="el" href="classItTy.html">ItTy</a>, FuncTy &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellvm.html#ae4bd116b41e412b1e0a91599be3c2b7a">llvm::map_iterator</a> (<a class="el" href="classItTy.html">ItTy</a> <a class="el" href="MD5_8cpp.html#ac0eafdc9ee161b71e7af98af736952fd">I</a>, FuncTy <a class="el" href="MD5_8cpp.html#a96d73bbd7af15cb1fc38c3f4a3bd82e9">F</a>)</td></tr>
<tr class="separator:ae4bd116b41e412b1e0a91599be3c2b7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51c7cbd21e1104ee6841c18d7daa6edb"><td class="memTemplParams" colspan="2">template&lt;class ContainerTy , class FuncTy &gt; </td></tr>
<tr class="memitem:a51c7cbd21e1104ee6841c18d7daa6edb"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellvm.html#a51c7cbd21e1104ee6841c18d7daa6edb">llvm::map_range</a> (ContainerTy &amp;&amp;<a class="el" href="README__ALTIVEC_8txt.html#a9aacd9146afe44bf656cd664e2a88c8c">C</a>, FuncTy <a class="el" href="MD5_8cpp.html#a96d73bbd7af15cb1fc38c3f4a3bd82e9">F</a>)</td></tr>
<tr class="separator:a51c7cbd21e1104ee6841c18d7daa6edb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b0ac1fa4f05de76413c5e0ca6334035"><td class="memTemplParams" colspan="2">template&lt;typename ContainerTy &gt; </td></tr>
<tr class="memitem:a6b0ac1fa4f05de76413c5e0ca6334035"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellvm.html#a6b0ac1fa4f05de76413c5e0ca6334035">llvm::reverse</a> (ContainerTy &amp;&amp;<a class="el" href="README__ALTIVEC_8txt.html#a9aacd9146afe44bf656cd664e2a88c8c">C</a>)</td></tr>
<tr class="separator:a6b0ac1fa4f05de76413c5e0ca6334035"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a943f22024cba236f495239754ca3c74b"><td class="memTemplParams" colspan="2">template&lt;typename RangeT , typename PredicateT &gt; </td></tr>
<tr class="memitem:a943f22024cba236f495239754ca3c74b"><td class="memTemplItemLeft" align="right" valign="top">iterator_range&lt; filter_iterator&lt; detail::IterOfRange&lt; RangeT &gt;, <a class="el" href="classPredicateT.html">PredicateT</a> &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellvm.html#a943f22024cba236f495239754ca3c74b">llvm::make_filter_range</a> (RangeT &amp;&amp;Range, <a class="el" href="classPredicateT.html">PredicateT</a> Pred)</td></tr>
<tr class="memdesc:a943f22024cba236f495239754ca3c74b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience function that takes a range of elements and a predicate, and return a new filter_iterator range.  <a href="namespacellvm.html#a943f22024cba236f495239754ca3c74b">More...</a><br /></td></tr>
<tr class="separator:a943f22024cba236f495239754ca3c74b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8154638df88e4eaa568b67b23d463dac"><td class="memTemplParams" colspan="2">template&lt;typename RangeT &gt; </td></tr>
<tr class="memitem:a8154638df88e4eaa568b67b23d463dac"><td class="memTemplItemLeft" align="right" valign="top">iterator_range&lt; early_inc_iterator_impl&lt; detail::IterOfRange&lt; RangeT &gt; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellvm.html#a8154638df88e4eaa568b67b23d463dac">llvm::make_early_inc_range</a> (RangeT &amp;&amp;Range)</td></tr>
<tr class="memdesc:a8154638df88e4eaa568b67b23d463dac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a range that does early increment to allow mutation of the underlying range without disrupting iteration.  <a href="namespacellvm.html#a8154638df88e4eaa568b67b23d463dac">More...</a><br /></td></tr>
<tr class="separator:a8154638df88e4eaa568b67b23d463dac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d10fe510ced2849a8074fe81e5d04ce"><td class="memTemplParams" colspan="2">template&lt;typename R , typename UnaryPredicate &gt; </td></tr>
<tr class="memitem:a0d10fe510ced2849a8074fe81e5d04ce"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellvm.html#a0d10fe510ced2849a8074fe81e5d04ce">llvm::all_of</a> (R &amp;&amp;Range, UnaryPredicate <a class="el" href="README-SSE_8txt.html#a63d206a063eefcdf8c318ded97b65020">P</a>)</td></tr>
<tr class="memdesc:a0d10fe510ced2849a8074fe81e5d04ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provide wrappers to std::all_of which take ranges instead of having to pass begin/end explicitly.  <a href="namespacellvm.html#a0d10fe510ced2849a8074fe81e5d04ce">More...</a><br /></td></tr>
<tr class="separator:a0d10fe510ced2849a8074fe81e5d04ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61d13d6824ec46c31260a4fd0997eda0"><td class="memTemplParams" colspan="2">template&lt;typename R , typename UnaryPredicate &gt; </td></tr>
<tr class="memitem:a61d13d6824ec46c31260a4fd0997eda0"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellvm.html#a61d13d6824ec46c31260a4fd0997eda0">llvm::any_of</a> (R &amp;&amp;Range, UnaryPredicate <a class="el" href="README-SSE_8txt.html#a63d206a063eefcdf8c318ded97b65020">P</a>)</td></tr>
<tr class="memdesc:a61d13d6824ec46c31260a4fd0997eda0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provide wrappers to std::any_of which take ranges instead of having to pass begin/end explicitly.  <a href="namespacellvm.html#a61d13d6824ec46c31260a4fd0997eda0">More...</a><br /></td></tr>
<tr class="separator:a61d13d6824ec46c31260a4fd0997eda0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad78da75bd1f157e72100f97d1ecdc756"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ad78da75bd1f157e72100f97d1ecdc756"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellvm.html#ad78da75bd1f157e72100f97d1ecdc756">llvm::all_equal</a> (std::initializer_list&lt; <a class="el" href="classT.html">T</a> &gt; Values)</td></tr>
<tr class="memdesc:ad78da75bd1f157e72100f97d1ecdc756"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if all Values in the initializer lists are equal or the list.  <a href="namespacellvm.html#ad78da75bd1f157e72100f97d1ecdc756">More...</a><br /></td></tr>
<tr class="separator:ad78da75bd1f157e72100f97d1ecdc756"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2edb650de7b28add81349f5abf7ed7aa"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , typename... Args&gt; </td></tr>
<tr class="memitem:a2edb650de7b28add81349f5abf7ed7aa"><td class="memTemplItemLeft" align="right" valign="top">detail::zippy&lt; detail::zip_shortest, <a class="el" href="classT.html">T</a>, U, Args... &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellvm.html#a2edb650de7b28add81349f5abf7ed7aa">llvm::zip</a> (<a class="el" href="classT.html">T</a> &amp;&amp;<a class="el" href="README-SSE_8txt.html#a50fd53d9a3e55ae78555e11827355565">t</a>, U &amp;&amp;u, Args &amp;&amp;...<a class="el" href="NVPTXLowerArgs_8cpp.html#a4d6da696b3c753c5e5fbcc4d21d4cb71">args</a>)</td></tr>
<tr class="memdesc:a2edb650de7b28add81349f5abf7ed7aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">zip iterator for two or more iteratable types.  <a href="namespacellvm.html#a2edb650de7b28add81349f5abf7ed7aa">More...</a><br /></td></tr>
<tr class="separator:a2edb650de7b28add81349f5abf7ed7aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6667728d56665c39db665e57b3910f77"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , typename... Args&gt; </td></tr>
<tr class="memitem:a6667728d56665c39db665e57b3910f77"><td class="memTemplItemLeft" align="right" valign="top">detail::zippy&lt; detail::zip_first, <a class="el" href="classT.html">T</a>, U, Args... &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellvm.html#a6667728d56665c39db665e57b3910f77">llvm::zip_equal</a> (<a class="el" href="classT.html">T</a> &amp;&amp;<a class="el" href="README-SSE_8txt.html#a50fd53d9a3e55ae78555e11827355565">t</a>, U &amp;&amp;u, Args &amp;&amp;...<a class="el" href="NVPTXLowerArgs_8cpp.html#a4d6da696b3c753c5e5fbcc4d21d4cb71">args</a>)</td></tr>
<tr class="memdesc:a6667728d56665c39db665e57b3910f77"><td class="mdescLeft">&#160;</td><td class="mdescRight">zip iterator that assumes that all iteratees have the same length.  <a href="namespacellvm.html#a6667728d56665c39db665e57b3910f77">More...</a><br /></td></tr>
<tr class="separator:a6667728d56665c39db665e57b3910f77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a658afaced2fe025f29333d9670baf0d2"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , typename... Args&gt; </td></tr>
<tr class="memitem:a658afaced2fe025f29333d9670baf0d2"><td class="memTemplItemLeft" align="right" valign="top">detail::zippy&lt; detail::zip_first, <a class="el" href="classT.html">T</a>, U, Args... &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellvm.html#a658afaced2fe025f29333d9670baf0d2">llvm::zip_first</a> (<a class="el" href="classT.html">T</a> &amp;&amp;<a class="el" href="README-SSE_8txt.html#a50fd53d9a3e55ae78555e11827355565">t</a>, U &amp;&amp;u, Args &amp;&amp;...<a class="el" href="NVPTXLowerArgs_8cpp.html#a4d6da696b3c753c5e5fbcc4d21d4cb71">args</a>)</td></tr>
<tr class="memdesc:a658afaced2fe025f29333d9670baf0d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">zip iterator that, for the sake of efficiency, assumes the first iteratee to be the shortest.  <a href="namespacellvm.html#a658afaced2fe025f29333d9670baf0d2">More...</a><br /></td></tr>
<tr class="separator:a658afaced2fe025f29333d9670baf0d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a999d703cc02d4b597056c3d718c9ed7b"><td class="memTemplParams" colspan="2">template&lt;typename Iter &gt; </td></tr>
<tr class="memitem:a999d703cc02d4b597056c3d718c9ed7b"><td class="memTemplItemLeft" align="right" valign="top">Iter&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellvm_1_1detail.html#a999d703cc02d4b597056c3d718c9ed7b">llvm::detail::next_or_end</a> (<a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> Iter &amp;<a class="el" href="MD5_8cpp.html#ac0eafdc9ee161b71e7af98af736952fd">I</a>, <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> Iter &amp;End)</td></tr>
<tr class="separator:a999d703cc02d4b597056c3d718c9ed7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2cdea13dc43dac7a18124862937f707"><td class="memTemplParams" colspan="2">template&lt;typename Iter &gt; </td></tr>
<tr class="memitem:ae2cdea13dc43dac7a18124862937f707"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellvm_1_1detail.html#ae2cdea13dc43dac7a18124862937f707">llvm::detail::deref_or_none</a> (<a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> Iter &amp;<a class="el" href="MD5_8cpp.html#ac0eafdc9ee161b71e7af98af736952fd">I</a>, <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> Iter &amp;End) -&gt; std::optional&lt; std::remove_const_t&lt; std::remove_reference_t&lt; decltype(*<a class="el" href="MD5_8cpp.html#ac0eafdc9ee161b71e7af98af736952fd">I</a>)&gt;&gt;&gt;</td></tr>
<tr class="separator:ae2cdea13dc43dac7a18124862937f707"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08d489c353ad27e8894ae2a04ab52a3a"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , typename... Args&gt; </td></tr>
<tr class="memitem:a08d489c353ad27e8894ae2a04ab52a3a"><td class="memTemplItemLeft" align="right" valign="top">detail::zip_longest_range&lt; <a class="el" href="classT.html">T</a>, U, Args... &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellvm.html#a08d489c353ad27e8894ae2a04ab52a3a">llvm::zip_longest</a> (<a class="el" href="classT.html">T</a> &amp;&amp;<a class="el" href="README-SSE_8txt.html#a50fd53d9a3e55ae78555e11827355565">t</a>, U &amp;&amp;u, Args &amp;&amp;... <a class="el" href="NVPTXLowerArgs_8cpp.html#a4d6da696b3c753c5e5fbcc4d21d4cb71">args</a>)</td></tr>
<tr class="memdesc:a08d489c353ad27e8894ae2a04ab52a3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterate over two or more iterators at the same time.  <a href="namespacellvm.html#a08d489c353ad27e8894ae2a04ab52a3a">More...</a><br /></td></tr>
<tr class="separator:a08d489c353ad27e8894ae2a04ab52a3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad41e0eef31b6a383647c6b3cb7f1c5cd"><td class="memTemplParams" colspan="2">template&lt;typename ValueT , typename... RangeTs&gt; </td></tr>
<tr class="memitem:ad41e0eef31b6a383647c6b3cb7f1c5cd"><td class="memTemplItemLeft" align="right" valign="top">detail::concat_range&lt; <a class="el" href="classValueT.html">ValueT</a>, RangeTs... &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellvm.html#ad41e0eef31b6a383647c6b3cb7f1c5cd">llvm::concat</a> (RangeTs &amp;&amp;... Ranges)</td></tr>
<tr class="memdesc:ad41e0eef31b6a383647c6b3cb7f1c5cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concatenated range across two or more ranges.  <a href="namespacellvm.html#ad41e0eef31b6a383647c6b3cb7f1c5cd">More...</a><br /></td></tr>
<tr class="separator:ad41e0eef31b6a383647c6b3cb7f1c5cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f02feabe2798347395e53d18da48f96"><td class="memTemplParams" colspan="2">template&lt;typename ContainerTy &gt; </td></tr>
<tr class="memitem:a7f02feabe2798347395e53d18da48f96"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellvm.html#a7f02feabe2798347395e53d18da48f96">llvm::make_first_range</a> (ContainerTy &amp;&amp;<a class="el" href="lib_2Target_2X86_2README_8txt.html#ae0323a9039add2978bf5b49550572c7c">c</a>)</td></tr>
<tr class="memdesc:a7f02feabe2798347395e53d18da48f96"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a container of pairs, return a range over the first elements.  <a href="namespacellvm.html#a7f02feabe2798347395e53d18da48f96">More...</a><br /></td></tr>
<tr class="separator:a7f02feabe2798347395e53d18da48f96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe90bd018550a621549fa13700c0f762"><td class="memTemplParams" colspan="2">template&lt;typename ContainerTy &gt; </td></tr>
<tr class="memitem:abe90bd018550a621549fa13700c0f762"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellvm.html#abe90bd018550a621549fa13700c0f762">llvm::make_second_range</a> (ContainerTy &amp;&amp;<a class="el" href="lib_2Target_2X86_2README_8txt.html#ae0323a9039add2978bf5b49550572c7c">c</a>)</td></tr>
<tr class="memdesc:abe90bd018550a621549fa13700c0f762"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a container of pairs, return a range over the second elements.  <a href="namespacellvm.html#abe90bd018550a621549fa13700c0f762">More...</a><br /></td></tr>
<tr class="separator:abe90bd018550a621549fa13700c0f762"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adddb600e248343bd5a75e3251f7885b6"><td class="memTemplParams" colspan="2">template&lt;typename... CallableTs&gt; </td></tr>
<tr class="memitem:adddb600e248343bd5a75e3251f7885b6"><td class="memTemplItemLeft" align="right" valign="top">constexpr decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellvm.html#adddb600e248343bd5a75e3251f7885b6">llvm::makeVisitor</a> (CallableTs &amp;&amp;...Callables)</td></tr>
<tr class="memdesc:adddb600e248343bd5a75e3251f7885b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an opaquely-typed Callable object whose operator() overload set is the sum of the operator() overload sets of each CallableT in CallableTs.  <a href="namespacellvm.html#adddb600e248343bd5a75e3251f7885b6">More...</a><br /></td></tr>
<tr class="separator:adddb600e248343bd5a75e3251f7885b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a457abdc792a2b697c1031f09edb8492f"><td class="memTemplParams" colspan="2">template&lt;class Iterator , class RNG &gt; </td></tr>
<tr class="memitem:a457abdc792a2b697c1031f09edb8492f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellvm.html#a457abdc792a2b697c1031f09edb8492f">llvm::shuffle</a> (Iterator first, Iterator last, RNG &amp;&amp;<a class="el" href="lib_2Target_2README_8txt.html#a89f43f4a69dab6c955c870796d7711bc">g</a>)</td></tr>
<tr class="separator:a457abdc792a2b697c1031f09edb8492f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33ebcf9fb4ed8e3831a2cf44500c8894"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a33ebcf9fb4ed8e3831a2cf44500c8894"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="lib_2Target_2ARM_2README_8txt.html#a2e877f6acf2d65a965545e1e5af5f7da">int</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellvm.html#a33ebcf9fb4ed8e3831a2cf44500c8894">llvm::array_pod_sort_comparator</a> (<a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> void *P1, <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> void *<a class="el" href="README-SSE_8txt.html#ae7fc2fb0e2d536219c1193f1a178e7db">P2</a>)</td></tr>
<tr class="memdesc:a33ebcf9fb4ed8e3831a2cf44500c8894"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adapt std::less&lt;T&gt; for array_pod_sort.  <a href="namespacellvm.html#a33ebcf9fb4ed8e3831a2cf44500c8894">More...</a><br /></td></tr>
<tr class="separator:a33ebcf9fb4ed8e3831a2cf44500c8894"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add1eb5637dd671428b6f138ed3db6428"><td class="memTemplParams" colspan="2">template&lt;class IteratorTy &gt; </td></tr>
<tr class="memitem:add1eb5637dd671428b6f138ed3db6428"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellvm.html#add1eb5637dd671428b6f138ed3db6428">llvm::array_pod_sort</a> (IteratorTy Start, IteratorTy End)</td></tr>
<tr class="memdesc:add1eb5637dd671428b6f138ed3db6428"><td class="mdescLeft">&#160;</td><td class="mdescRight">array_pod_sort - This sorts an array with the specified start and end extent.  <a href="namespacellvm.html#add1eb5637dd671428b6f138ed3db6428">More...</a><br /></td></tr>
<tr class="separator:add1eb5637dd671428b6f138ed3db6428"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5788f17f70ece4dcb34154325ce7126"><td class="memTemplParams" colspan="2">template&lt;class IteratorTy &gt; </td></tr>
<tr class="memitem:ae5788f17f70ece4dcb34154325ce7126"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellvm.html#ae5788f17f70ece4dcb34154325ce7126">llvm::array_pod_sort</a> (IteratorTy Start, IteratorTy End, <a class="el" href="lib_2Target_2ARM_2README_8txt.html#a2e877f6acf2d65a965545e1e5af5f7da">int</a>(*<a class="el" href="README__P9_8txt.html#a42a82adf8d40243d6a0a28972c9f7df1">Compare</a>)(<a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> typename std::iterator_traits&lt; IteratorTy &gt;::value_type *, <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> typename std::iterator_traits&lt; IteratorTy &gt;::value_type *))</td></tr>
<tr class="separator:ae5788f17f70ece4dcb34154325ce7126"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74cdbd1e4f731e7d7cd83461b8b1de0b"><td class="memTemplParams" colspan="2">template&lt;typename IteratorTy &gt; </td></tr>
<tr class="memitem:a74cdbd1e4f731e7d7cd83461b8b1de0b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellvm.html#a74cdbd1e4f731e7d7cd83461b8b1de0b">llvm::sort</a> (IteratorTy Start, IteratorTy End)</td></tr>
<tr class="separator:a74cdbd1e4f731e7d7cd83461b8b1de0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af591c14ddf8fa76705d1243a47a3bc57"><td class="memTemplParams" colspan="2">template&lt;typename Container &gt; </td></tr>
<tr class="memitem:af591c14ddf8fa76705d1243a47a3bc57"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellvm.html#af591c14ddf8fa76705d1243a47a3bc57">llvm::sort</a> (Container &amp;&amp;<a class="el" href="README__ALTIVEC_8txt.html#a9aacd9146afe44bf656cd664e2a88c8c">C</a>)</td></tr>
<tr class="separator:af591c14ddf8fa76705d1243a47a3bc57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84aac64c34ffe3da7c08eb061d9feb7a"><td class="memTemplParams" colspan="2">template&lt;typename IteratorTy , typename Compare &gt; </td></tr>
<tr class="memitem:a84aac64c34ffe3da7c08eb061d9feb7a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellvm.html#a84aac64c34ffe3da7c08eb061d9feb7a">llvm::sort</a> (IteratorTy Start, IteratorTy End, <a class="el" href="README__P9_8txt.html#a42a82adf8d40243d6a0a28972c9f7df1">Compare</a> Comp)</td></tr>
<tr class="separator:a84aac64c34ffe3da7c08eb061d9feb7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a200e8e1b1e54f27f91fbf8b32d526cda"><td class="memTemplParams" colspan="2">template&lt;typename Container , typename Compare &gt; </td></tr>
<tr class="memitem:a200e8e1b1e54f27f91fbf8b32d526cda"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellvm.html#a200e8e1b1e54f27f91fbf8b32d526cda">llvm::sort</a> (Container &amp;&amp;<a class="el" href="README__ALTIVEC_8txt.html#a9aacd9146afe44bf656cd664e2a88c8c">C</a>, <a class="el" href="README__P9_8txt.html#a42a82adf8d40243d6a0a28972c9f7df1">Compare</a> Comp)</td></tr>
<tr class="separator:a200e8e1b1e54f27f91fbf8b32d526cda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10f3d955592ae2bc745f57e5b48ae115"><td class="memTemplParams" colspan="2">template&lt;typename R &gt; </td></tr>
<tr class="memitem:a10f3d955592ae2bc745f57e5b48ae115"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellvm.html#a10f3d955592ae2bc745f57e5b48ae115">llvm::size</a> (R &amp;&amp;Range, std::enable_if_t&lt; std::is_base_of&lt; std::random_access_iterator_tag, typename std::iterator_traits&lt; decltype(Range.begin())&gt;::iterator_category &gt;::value, void &gt; *=nullptr)</td></tr>
<tr class="memdesc:a10f3d955592ae2bc745f57e5b48ae115"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the size of a range.  <a href="namespacellvm.html#a10f3d955592ae2bc745f57e5b48ae115">More...</a><br /></td></tr>
<tr class="separator:a10f3d955592ae2bc745f57e5b48ae115"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b2a153b655ed78a07468297eb4c6256"><td class="memTemplParams" colspan="2">template&lt;typename R , typename UnaryFunction &gt; </td></tr>
<tr class="memitem:a0b2a153b655ed78a07468297eb4c6256"><td class="memTemplItemLeft" align="right" valign="top">UnaryFunction&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellvm.html#a0b2a153b655ed78a07468297eb4c6256">llvm::for_each</a> (R &amp;&amp;Range, UnaryFunction <a class="el" href="MD5_8cpp.html#a96d73bbd7af15cb1fc38c3f4a3bd82e9">F</a>)</td></tr>
<tr class="memdesc:a0b2a153b655ed78a07468297eb4c6256"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provide wrappers to std::for_each which take ranges instead of having to pass begin/end explicitly.  <a href="namespacellvm.html#a0b2a153b655ed78a07468297eb4c6256">More...</a><br /></td></tr>
<tr class="separator:a0b2a153b655ed78a07468297eb4c6256"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7dc3069afa2ce5ea62ac2eb183e51c00"><td class="memTemplParams" colspan="2">template&lt;typename R , typename UnaryPredicate &gt; </td></tr>
<tr class="memitem:a7dc3069afa2ce5ea62ac2eb183e51c00"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellvm.html#a7dc3069afa2ce5ea62ac2eb183e51c00">llvm::none_of</a> (R &amp;&amp;Range, UnaryPredicate <a class="el" href="README-SSE_8txt.html#a63d206a063eefcdf8c318ded97b65020">P</a>)</td></tr>
<tr class="memdesc:a7dc3069afa2ce5ea62ac2eb183e51c00"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provide wrappers to std::none_of which take ranges instead of having to pass begin/end explicitly.  <a href="namespacellvm.html#a7dc3069afa2ce5ea62ac2eb183e51c00">More...</a><br /></td></tr>
<tr class="separator:a7dc3069afa2ce5ea62ac2eb183e51c00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a086e9fbdb06276db7753101a08a63adf"><td class="memTemplParams" colspan="2">template&lt;typename R , typename T &gt; </td></tr>
<tr class="memitem:a086e9fbdb06276db7753101a08a63adf"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellvm.html#a086e9fbdb06276db7753101a08a63adf">llvm::find</a> (R &amp;&amp;Range, <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classT.html">T</a> &amp;Val)</td></tr>
<tr class="memdesc:a086e9fbdb06276db7753101a08a63adf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provide wrappers to std::find which take ranges instead of having to pass begin/end explicitly.  <a href="namespacellvm.html#a086e9fbdb06276db7753101a08a63adf">More...</a><br /></td></tr>
<tr class="separator:a086e9fbdb06276db7753101a08a63adf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac78c09ae232b2ce188ff590d51e3c268"><td class="memTemplParams" colspan="2">template&lt;typename R , typename UnaryPredicate &gt; </td></tr>
<tr class="memitem:ac78c09ae232b2ce188ff590d51e3c268"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellvm.html#ac78c09ae232b2ce188ff590d51e3c268">llvm::find_if</a> (R &amp;&amp;Range, UnaryPredicate <a class="el" href="README-SSE_8txt.html#a63d206a063eefcdf8c318ded97b65020">P</a>)</td></tr>
<tr class="memdesc:ac78c09ae232b2ce188ff590d51e3c268"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provide wrappers to std::find_if which take ranges instead of having to pass begin/end explicitly.  <a href="namespacellvm.html#ac78c09ae232b2ce188ff590d51e3c268">More...</a><br /></td></tr>
<tr class="separator:ac78c09ae232b2ce188ff590d51e3c268"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b49849160e7f089916f83c52511da9e"><td class="memTemplParams" colspan="2">template&lt;typename R , typename UnaryPredicate &gt; </td></tr>
<tr class="memitem:a7b49849160e7f089916f83c52511da9e"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellvm.html#a7b49849160e7f089916f83c52511da9e">llvm::find_if_not</a> (R &amp;&amp;Range, UnaryPredicate <a class="el" href="README-SSE_8txt.html#a63d206a063eefcdf8c318ded97b65020">P</a>)</td></tr>
<tr class="separator:a7b49849160e7f089916f83c52511da9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ec2517b6489e71067be03afebb4d350"><td class="memTemplParams" colspan="2">template&lt;typename R , typename UnaryPredicate &gt; </td></tr>
<tr class="memitem:a9ec2517b6489e71067be03afebb4d350"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellvm.html#a9ec2517b6489e71067be03afebb4d350">llvm::remove_if</a> (R &amp;&amp;Range, UnaryPredicate <a class="el" href="README-SSE_8txt.html#a63d206a063eefcdf8c318ded97b65020">P</a>)</td></tr>
<tr class="memdesc:a9ec2517b6489e71067be03afebb4d350"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provide wrappers to std::remove_if which take ranges instead of having to pass begin/end explicitly.  <a href="namespacellvm.html#a9ec2517b6489e71067be03afebb4d350">More...</a><br /></td></tr>
<tr class="separator:a9ec2517b6489e71067be03afebb4d350"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d13fd05401d8eb0c97b9864a0eb6028"><td class="memTemplParams" colspan="2">template&lt;typename R , typename OutputIt , typename UnaryPredicate &gt; </td></tr>
<tr class="memitem:a4d13fd05401d8eb0c97b9864a0eb6028"><td class="memTemplItemLeft" align="right" valign="top">OutputIt&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellvm.html#a4d13fd05401d8eb0c97b9864a0eb6028">llvm::copy_if</a> (R &amp;&amp;Range, OutputIt Out, UnaryPredicate <a class="el" href="README-SSE_8txt.html#a63d206a063eefcdf8c318ded97b65020">P</a>)</td></tr>
<tr class="memdesc:a4d13fd05401d8eb0c97b9864a0eb6028"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provide wrappers to std::copy_if which take ranges instead of having to pass begin/end explicitly.  <a href="namespacellvm.html#a4d13fd05401d8eb0c97b9864a0eb6028">More...</a><br /></td></tr>
<tr class="separator:a4d13fd05401d8eb0c97b9864a0eb6028"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d656b33a5c7b6fad918190999c5ce5d"><td class="memTemplParams" colspan="2">template&lt;typename T , typename R , typename Predicate &gt; </td></tr>
<tr class="memitem:a3d656b33a5c7b6fad918190999c5ce5d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classT.html">T</a> *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellvm.html#a3d656b33a5c7b6fad918190999c5ce5d">llvm::find_singleton</a> (R &amp;&amp;Range, Predicate <a class="el" href="README-SSE_8txt.html#a63d206a063eefcdf8c318ded97b65020">P</a>, bool AllowRepeats=<a class="el" href="UnifyLoopExits_8cpp.html#a889d7f30f6c65b4b325c18f14f4272c3">false</a>)</td></tr>
<tr class="memdesc:a3d656b33a5c7b6fad918190999c5ce5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the single value in <code>Range</code> that satisfies <code>P</code>(&lt;member of <code>Range&gt;</code> *, AllowRepeats)-&gt;<a class="el" href="classT.html">T</a> * returning nullptr when no values or multiple values were found.  <a href="namespacellvm.html#a3d656b33a5c7b6fad918190999c5ce5d">More...</a><br /></td></tr>
<tr class="separator:a3d656b33a5c7b6fad918190999c5ce5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f7d1ff9c9de8c630d6d57bcb3a5df77"><td class="memTemplParams" colspan="2">template&lt;typename T , typename R , typename Predicate &gt; </td></tr>
<tr class="memitem:a2f7d1ff9c9de8c630d6d57bcb3a5df77"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classT.html">T</a> *, bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellvm.html#a2f7d1ff9c9de8c630d6d57bcb3a5df77">llvm::find_singleton_nested</a> (R &amp;&amp;Range, Predicate <a class="el" href="README-SSE_8txt.html#a63d206a063eefcdf8c318ded97b65020">P</a>, bool AllowRepeats=<a class="el" href="UnifyLoopExits_8cpp.html#a889d7f30f6c65b4b325c18f14f4272c3">false</a>)</td></tr>
<tr class="memdesc:a2f7d1ff9c9de8c630d6d57bcb3a5df77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a pair consisting of the single value in <code>Range</code> that satisfies <code>P</code>(&lt;member of <code>Range&gt;</code> *, AllowRepeats)-&gt;std::pair&lt;T*, bool&gt; returning nullptr when no values or multiple values were found, and a bool indicating whether multiple values were found to cause the nullptr.  <a href="namespacellvm.html#a2f7d1ff9c9de8c630d6d57bcb3a5df77">More...</a><br /></td></tr>
<tr class="separator:a2f7d1ff9c9de8c630d6d57bcb3a5df77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb650e853db0ddbb60411b885c499737"><td class="memTemplParams" colspan="2">template&lt;typename R , typename OutputIt &gt; </td></tr>
<tr class="memitem:abb650e853db0ddbb60411b885c499737"><td class="memTemplItemLeft" align="right" valign="top">OutputIt&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellvm.html#abb650e853db0ddbb60411b885c499737">llvm::copy</a> (R &amp;&amp;Range, OutputIt Out)</td></tr>
<tr class="separator:abb650e853db0ddbb60411b885c499737"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6714f2d64a5ef87e519f6efb70d4316"><td class="memTemplParams" colspan="2">template&lt;typename R , typename OutputIt , typename UnaryPredicate , typename T &gt; </td></tr>
<tr class="memitem:ab6714f2d64a5ef87e519f6efb70d4316"><td class="memTemplItemLeft" align="right" valign="top">OutputIt&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellvm.html#ab6714f2d64a5ef87e519f6efb70d4316">llvm::replace_copy_if</a> (R &amp;&amp;Range, OutputIt Out, UnaryPredicate <a class="el" href="README-SSE_8txt.html#a63d206a063eefcdf8c318ded97b65020">P</a>, <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classT.html">T</a> &amp;NewValue)</td></tr>
<tr class="memdesc:ab6714f2d64a5ef87e519f6efb70d4316"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provide wrappers to std::replace_copy_if which take ranges instead of having to pass begin/end explicitly.  <a href="namespacellvm.html#ab6714f2d64a5ef87e519f6efb70d4316">More...</a><br /></td></tr>
<tr class="separator:ab6714f2d64a5ef87e519f6efb70d4316"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1c97b8c8035fa91c5275ffb54d41634"><td class="memTemplParams" colspan="2">template&lt;typename R , typename OutputIt , typename T &gt; </td></tr>
<tr class="memitem:ac1c97b8c8035fa91c5275ffb54d41634"><td class="memTemplItemLeft" align="right" valign="top">OutputIt&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellvm.html#ac1c97b8c8035fa91c5275ffb54d41634">llvm::replace_copy</a> (R &amp;&amp;Range, OutputIt Out, <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classT.html">T</a> &amp;OldValue, <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classT.html">T</a> &amp;NewValue)</td></tr>
<tr class="memdesc:ac1c97b8c8035fa91c5275ffb54d41634"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provide wrappers to std::replace_copy which take ranges instead of having to pass begin/end explicitly.  <a href="namespacellvm.html#ac1c97b8c8035fa91c5275ffb54d41634">More...</a><br /></td></tr>
<tr class="separator:ac1c97b8c8035fa91c5275ffb54d41634"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfc9c7ecf70f66901e439f7c04ef3dbb"><td class="memTemplParams" colspan="2">template&lt;typename R , typename OutputIt &gt; </td></tr>
<tr class="memitem:abfc9c7ecf70f66901e439f7c04ef3dbb"><td class="memTemplItemLeft" align="right" valign="top">OutputIt&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellvm.html#abfc9c7ecf70f66901e439f7c04ef3dbb">llvm::move</a> (R &amp;&amp;Range, OutputIt Out)</td></tr>
<tr class="memdesc:abfc9c7ecf70f66901e439f7c04ef3dbb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provide wrappers to std::move which take ranges instead of having to pass begin/end explicitly.  <a href="namespacellvm.html#abfc9c7ecf70f66901e439f7c04ef3dbb">More...</a><br /></td></tr>
<tr class="separator:abfc9c7ecf70f66901e439f7c04ef3dbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd1cd968cb420c82d70926920fcdc7d7"><td class="memTemplParams" colspan="2">template&lt;typename R , typename E &gt; </td></tr>
<tr class="memitem:acd1cd968cb420c82d70926920fcdc7d7"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellvm.html#acd1cd968cb420c82d70926920fcdc7d7">llvm::is_contained</a> (R &amp;&amp;Range, <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="BuiltinGCs_8cpp.html#a6742d2e0a668baf1196ec69e158d5f15">E</a> &amp;Element)</td></tr>
<tr class="memdesc:acd1cd968cb420c82d70926920fcdc7d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper function around std::find to detect if an element exists in a container.  <a href="namespacellvm.html#acd1cd968cb420c82d70926920fcdc7d7">More...</a><br /></td></tr>
<tr class="separator:acd1cd968cb420c82d70926920fcdc7d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a013dccb6c8c697db0a34aa576f9036d2"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a013dccb6c8c697db0a34aa576f9036d2"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellvm.html#a013dccb6c8c697db0a34aa576f9036d2">llvm::is_contained</a> (std::initializer_list&lt; <a class="el" href="classT.html">T</a> &gt; Set, <a class="el" href="classT.html">T</a> Value)</td></tr>
<tr class="separator:a013dccb6c8c697db0a34aa576f9036d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a864e071375fea140a5441a243372ff81"><td class="memTemplParams" colspan="2">template&lt;typename R , typename Compare &gt; </td></tr>
<tr class="memitem:a864e071375fea140a5441a243372ff81"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellvm.html#a864e071375fea140a5441a243372ff81">llvm::is_sorted</a> (R &amp;&amp;Range, <a class="el" href="README__P9_8txt.html#a42a82adf8d40243d6a0a28972c9f7df1">Compare</a> <a class="el" href="README__ALTIVEC_8txt.html#a9aacd9146afe44bf656cd664e2a88c8c">C</a>)</td></tr>
<tr class="memdesc:a864e071375fea140a5441a243372ff81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper function around std::is_sorted to check if elements in a range <code>R</code> are sorted with respect to a comparator <code>C</code>.  <a href="namespacellvm.html#a864e071375fea140a5441a243372ff81">More...</a><br /></td></tr>
<tr class="separator:a864e071375fea140a5441a243372ff81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a443134b90d575b15a5d131bc5de0ebd4"><td class="memTemplParams" colspan="2">template&lt;typename R &gt; </td></tr>
<tr class="memitem:a443134b90d575b15a5d131bc5de0ebd4"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellvm.html#a443134b90d575b15a5d131bc5de0ebd4">llvm::is_sorted</a> (R &amp;&amp;Range)</td></tr>
<tr class="memdesc:a443134b90d575b15a5d131bc5de0ebd4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper function around std::is_sorted to check if elements in a range <code>R</code> are sorted in non-descending order.  <a href="namespacellvm.html#a443134b90d575b15a5d131bc5de0ebd4">More...</a><br /></td></tr>
<tr class="separator:a443134b90d575b15a5d131bc5de0ebd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1772fd431decccb7926d484ea223db7"><td class="memTemplParams" colspan="2">template&lt;typename R , typename E &gt; </td></tr>
<tr class="memitem:ab1772fd431decccb7926d484ea223db7"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellvm.html#ab1772fd431decccb7926d484ea223db7">llvm::count</a> (R &amp;&amp;Range, <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="BuiltinGCs_8cpp.html#a6742d2e0a668baf1196ec69e158d5f15">E</a> &amp;Element)</td></tr>
<tr class="memdesc:ab1772fd431decccb7926d484ea223db7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper function around std::count to count the number of times an element <code>Element</code> occurs in the given range <code>Range</code>.  <a href="namespacellvm.html#ab1772fd431decccb7926d484ea223db7">More...</a><br /></td></tr>
<tr class="separator:ab1772fd431decccb7926d484ea223db7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac214df91cdc242f4710ea5a93939c678"><td class="memTemplParams" colspan="2">template&lt;typename R , typename UnaryPredicate &gt; </td></tr>
<tr class="memitem:ac214df91cdc242f4710ea5a93939c678"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellvm.html#ac214df91cdc242f4710ea5a93939c678">llvm::count_if</a> (R &amp;&amp;Range, UnaryPredicate <a class="el" href="README-SSE_8txt.html#a63d206a063eefcdf8c318ded97b65020">P</a>)</td></tr>
<tr class="memdesc:ac214df91cdc242f4710ea5a93939c678"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper function around std::count_if to count the number of times an element satisfying a given predicate occurs in a range.  <a href="namespacellvm.html#ac214df91cdc242f4710ea5a93939c678">More...</a><br /></td></tr>
<tr class="separator:ac214df91cdc242f4710ea5a93939c678"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a615619b0b2879029152b9a20e96624bc"><td class="memTemplParams" colspan="2">template&lt;typename R , typename OutputIt , typename UnaryFunction &gt; </td></tr>
<tr class="memitem:a615619b0b2879029152b9a20e96624bc"><td class="memTemplItemLeft" align="right" valign="top">OutputIt&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellvm.html#a615619b0b2879029152b9a20e96624bc">llvm::transform</a> (R &amp;&amp;Range, OutputIt d_first, UnaryFunction <a class="el" href="MD5_8cpp.html#a96d73bbd7af15cb1fc38c3f4a3bd82e9">F</a>)</td></tr>
<tr class="memdesc:a615619b0b2879029152b9a20e96624bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper function around std::transform to apply a function to a range and store the result elsewhere.  <a href="namespacellvm.html#a615619b0b2879029152b9a20e96624bc">More...</a><br /></td></tr>
<tr class="separator:a615619b0b2879029152b9a20e96624bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc14fa925bdbae07ef7bbd16ca82ce3d"><td class="memTemplParams" colspan="2">template&lt;typename R , typename UnaryPredicate &gt; </td></tr>
<tr class="memitem:abc14fa925bdbae07ef7bbd16ca82ce3d"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellvm.html#abc14fa925bdbae07ef7bbd16ca82ce3d">llvm::partition</a> (R &amp;&amp;Range, UnaryPredicate <a class="el" href="README-SSE_8txt.html#a63d206a063eefcdf8c318ded97b65020">P</a>)</td></tr>
<tr class="memdesc:abc14fa925bdbae07ef7bbd16ca82ce3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provide wrappers to std::partition which take ranges instead of having to pass begin/end explicitly.  <a href="namespacellvm.html#abc14fa925bdbae07ef7bbd16ca82ce3d">More...</a><br /></td></tr>
<tr class="separator:abc14fa925bdbae07ef7bbd16ca82ce3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa81eb67f09ee4944eaeeddbc54c0c0de"><td class="memTemplParams" colspan="2">template&lt;typename R , typename T &gt; </td></tr>
<tr class="memitem:aa81eb67f09ee4944eaeeddbc54c0c0de"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellvm.html#aa81eb67f09ee4944eaeeddbc54c0c0de">llvm::lower_bound</a> (R &amp;&amp;Range, <a class="el" href="classT.html">T</a> &amp;&amp;Value)</td></tr>
<tr class="memdesc:aa81eb67f09ee4944eaeeddbc54c0c0de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provide wrappers to std::lower_bound which take ranges instead of having to pass begin/end explicitly.  <a href="namespacellvm.html#aa81eb67f09ee4944eaeeddbc54c0c0de">More...</a><br /></td></tr>
<tr class="separator:aa81eb67f09ee4944eaeeddbc54c0c0de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9220eb5a5a4bb04dba101e600e080c8d"><td class="memTemplParams" colspan="2">template&lt;typename R , typename T , typename Compare &gt; </td></tr>
<tr class="memitem:a9220eb5a5a4bb04dba101e600e080c8d"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellvm.html#a9220eb5a5a4bb04dba101e600e080c8d">llvm::lower_bound</a> (R &amp;&amp;Range, <a class="el" href="classT.html">T</a> &amp;&amp;Value, <a class="el" href="README__P9_8txt.html#a42a82adf8d40243d6a0a28972c9f7df1">Compare</a> <a class="el" href="README__ALTIVEC_8txt.html#a9aacd9146afe44bf656cd664e2a88c8c">C</a>)</td></tr>
<tr class="separator:a9220eb5a5a4bb04dba101e600e080c8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b7d2ab11554bd10d15b6cb21b2c2787"><td class="memTemplParams" colspan="2">template&lt;typename R , typename T &gt; </td></tr>
<tr class="memitem:a4b7d2ab11554bd10d15b6cb21b2c2787"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellvm.html#a4b7d2ab11554bd10d15b6cb21b2c2787">llvm::upper_bound</a> (R &amp;&amp;Range, <a class="el" href="classT.html">T</a> &amp;&amp;Value)</td></tr>
<tr class="memdesc:a4b7d2ab11554bd10d15b6cb21b2c2787"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provide wrappers to std::upper_bound which take ranges instead of having to pass begin/end explicitly.  <a href="namespacellvm.html#a4b7d2ab11554bd10d15b6cb21b2c2787">More...</a><br /></td></tr>
<tr class="separator:a4b7d2ab11554bd10d15b6cb21b2c2787"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7fb90f7f42557dd188cd7ed0e4c46b8"><td class="memTemplParams" colspan="2">template&lt;typename R , typename T , typename Compare &gt; </td></tr>
<tr class="memitem:ad7fb90f7f42557dd188cd7ed0e4c46b8"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellvm.html#ad7fb90f7f42557dd188cd7ed0e4c46b8">llvm::upper_bound</a> (R &amp;&amp;Range, <a class="el" href="classT.html">T</a> &amp;&amp;Value, <a class="el" href="README__P9_8txt.html#a42a82adf8d40243d6a0a28972c9f7df1">Compare</a> <a class="el" href="README__ALTIVEC_8txt.html#a9aacd9146afe44bf656cd664e2a88c8c">C</a>)</td></tr>
<tr class="separator:ad7fb90f7f42557dd188cd7ed0e4c46b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a076f93c387f454f0db13d4bc7d4e7f9c"><td class="memTemplParams" colspan="2">template&lt;typename R &gt; </td></tr>
<tr class="memitem:a076f93c387f454f0db13d4bc7d4e7f9c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellvm.html#a076f93c387f454f0db13d4bc7d4e7f9c">llvm::stable_sort</a> (R &amp;&amp;Range)</td></tr>
<tr class="separator:a076f93c387f454f0db13d4bc7d4e7f9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fe585614b67e0237c8fdbefd475572e"><td class="memTemplParams" colspan="2">template&lt;typename R , typename Compare &gt; </td></tr>
<tr class="memitem:a0fe585614b67e0237c8fdbefd475572e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellvm.html#a0fe585614b67e0237c8fdbefd475572e">llvm::stable_sort</a> (R &amp;&amp;Range, <a class="el" href="README__P9_8txt.html#a42a82adf8d40243d6a0a28972c9f7df1">Compare</a> <a class="el" href="README__ALTIVEC_8txt.html#a9aacd9146afe44bf656cd664e2a88c8c">C</a>)</td></tr>
<tr class="separator:a0fe585614b67e0237c8fdbefd475572e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a327a399b9f6ef414a29ddeffba934d26"><td class="memTemplParams" colspan="2">template&lt;typename R , typename Predicate , typename Val  = decltype(*adl_begin(std::declval&lt;R&gt;()))&gt; </td></tr>
<tr class="memitem:a327a399b9f6ef414a29ddeffba934d26"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellvm.html#a327a399b9f6ef414a29ddeffba934d26">llvm::partition_point</a> (R &amp;&amp;Range, Predicate <a class="el" href="README-SSE_8txt.html#a63d206a063eefcdf8c318ded97b65020">P</a>)</td></tr>
<tr class="memdesc:a327a399b9f6ef414a29ddeffba934d26"><td class="mdescLeft">&#160;</td><td class="mdescRight">Binary search for the first iterator in a range where a predicate is false.  <a href="namespacellvm.html#a327a399b9f6ef414a29ddeffba934d26">More...</a><br /></td></tr>
<tr class="separator:a327a399b9f6ef414a29ddeffba934d26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48f85da577c6ce7d9aed90437dc0d07c"><td class="memTemplParams" colspan="2">template&lt;typename Range , typename Predicate &gt; </td></tr>
<tr class="memitem:a48f85da577c6ce7d9aed90437dc0d07c"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellvm.html#a48f85da577c6ce7d9aed90437dc0d07c">llvm::unique</a> (Range &amp;&amp;R, Predicate <a class="el" href="README-SSE_8txt.html#a63d206a063eefcdf8c318ded97b65020">P</a>)</td></tr>
<tr class="separator:a48f85da577c6ce7d9aed90437dc0d07c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae04157f1cd3b64e93ebd44f8f65e395c"><td class="memTemplParams" colspan="2">template&lt;typename L , typename R &gt; </td></tr>
<tr class="memitem:ae04157f1cd3b64e93ebd44f8f65e395c"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellvm.html#ae04157f1cd3b64e93ebd44f8f65e395c">llvm::equal</a> (L &amp;&amp;LRange, R &amp;&amp;RRange)</td></tr>
<tr class="memdesc:ae04157f1cd3b64e93ebd44f8f65e395c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper function around std::equal to detect if pair-wise elements between two ranges are the same.  <a href="namespacellvm.html#ae04157f1cd3b64e93ebd44f8f65e395c">More...</a><br /></td></tr>
<tr class="separator:ae04157f1cd3b64e93ebd44f8f65e395c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae201dfde8ad47abde62764f2d0d87ab9"><td class="memTemplParams" colspan="2">template&lt;typename R &gt; </td></tr>
<tr class="memitem:ae201dfde8ad47abde62764f2d0d87ab9"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellvm.html#ae201dfde8ad47abde62764f2d0d87ab9">llvm::all_equal</a> (R &amp;&amp;Range)</td></tr>
<tr class="memdesc:ae201dfde8ad47abde62764f2d0d87ab9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if all elements in Range are equal or when the Range is empty.  <a href="namespacellvm.html#ae201dfde8ad47abde62764f2d0d87ab9">More...</a><br /></td></tr>
<tr class="separator:ae201dfde8ad47abde62764f2d0d87ab9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9a7de5a04920954ac964059cfc428ad"><td class="memTemplParams" colspan="2">template&lt;typename Container , typename UnaryPredicate &gt; </td></tr>
<tr class="memitem:ac9a7de5a04920954ac964059cfc428ad"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellvm.html#ac9a7de5a04920954ac964059cfc428ad">llvm::erase_if</a> (Container &amp;<a class="el" href="README__ALTIVEC_8txt.html#a9aacd9146afe44bf656cd664e2a88c8c">C</a>, UnaryPredicate <a class="el" href="README-SSE_8txt.html#a63d206a063eefcdf8c318ded97b65020">P</a>)</td></tr>
<tr class="memdesc:ac9a7de5a04920954ac964059cfc428ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provide a container algorithm similar to C++ Library Fundamentals v2's <code>erase_if</code> which is equivalent to:  <a href="namespacellvm.html#ac9a7de5a04920954ac964059cfc428ad">More...</a><br /></td></tr>
<tr class="separator:ac9a7de5a04920954ac964059cfc428ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa82bb12b2879425012b3742487e10964"><td class="memTemplParams" colspan="2">template&lt;typename Container , typename ValueType &gt; </td></tr>
<tr class="memitem:aa82bb12b2879425012b3742487e10964"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellvm.html#aa82bb12b2879425012b3742487e10964">llvm::erase_value</a> (Container &amp;<a class="el" href="README__ALTIVEC_8txt.html#a9aacd9146afe44bf656cd664e2a88c8c">C</a>, ValueType V)</td></tr>
<tr class="memdesc:aa82bb12b2879425012b3742487e10964"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper function to remove a value from a container:  <a href="namespacellvm.html#aa82bb12b2879425012b3742487e10964">More...</a><br /></td></tr>
<tr class="separator:aa82bb12b2879425012b3742487e10964"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39d3d23a084c4544ee5903203db10e8a"><td class="memTemplParams" colspan="2">template&lt;typename Container , typename Range &gt; </td></tr>
<tr class="memitem:a39d3d23a084c4544ee5903203db10e8a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellvm.html#a39d3d23a084c4544ee5903203db10e8a">llvm::append_range</a> (Container &amp;<a class="el" href="README__ALTIVEC_8txt.html#a9aacd9146afe44bf656cd664e2a88c8c">C</a>, Range &amp;&amp;R)</td></tr>
<tr class="memdesc:a39d3d23a084c4544ee5903203db10e8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper function to append a range to a container.  <a href="namespacellvm.html#a39d3d23a084c4544ee5903203db10e8a">More...</a><br /></td></tr>
<tr class="separator:a39d3d23a084c4544ee5903203db10e8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca964c0c0aee877ecf5c5af8a47982f6"><td class="memTemplParams" colspan="2">template&lt;typename Container , typename RandomAccessIterator &gt; </td></tr>
<tr class="memitem:aca964c0c0aee877ecf5c5af8a47982f6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellvm.html#aca964c0c0aee877ecf5c5af8a47982f6">llvm::replace</a> (Container &amp;Cont, typename Container::iterator ContIt, typename Container::iterator ContEnd, RandomAccessIterator ValIt, RandomAccessIterator ValEnd)</td></tr>
<tr class="memdesc:aca964c0c0aee877ecf5c5af8a47982f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a sequence container Cont, replace the range [ContIt, ContEnd) with the range [ValIt, ValEnd) (which is not from the same container).  <a href="namespacellvm.html#aca964c0c0aee877ecf5c5af8a47982f6">More...</a><br /></td></tr>
<tr class="separator:aca964c0c0aee877ecf5c5af8a47982f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfc8234929f8be8a1fe8048eaa87a7b9"><td class="memTemplParams" colspan="2">template&lt;typename Container , typename Range  = std::initializer_list&lt;                                 typename Container::value_type&gt;&gt; </td></tr>
<tr class="memitem:acfc8234929f8be8a1fe8048eaa87a7b9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellvm.html#acfc8234929f8be8a1fe8048eaa87a7b9">llvm::replace</a> (Container &amp;Cont, typename Container::iterator ContIt, typename Container::iterator ContEnd, Range R)</td></tr>
<tr class="memdesc:acfc8234929f8be8a1fe8048eaa87a7b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a sequence container Cont, replace the range [ContIt, ContEnd) with the range R.  <a href="namespacellvm.html#acfc8234929f8be8a1fe8048eaa87a7b9">More...</a><br /></td></tr>
<tr class="separator:acfc8234929f8be8a1fe8048eaa87a7b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2145da5bde7663d745e9c3ade392809f"><td class="memTemplParams" colspan="2">template&lt;typename ForwardIterator , typename UnaryFunctor , typename NullaryFunctor , typename  = std::enable_if_t&lt;              !std::is_constructible&lt;StringRef, UnaryFunctor&gt;::value &amp;&amp;              !std::is_constructible&lt;StringRef, NullaryFunctor&gt;::value&gt;&gt; </td></tr>
<tr class="memitem:a2145da5bde7663d745e9c3ade392809f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellvm.html#a2145da5bde7663d745e9c3ade392809f">llvm::interleave</a> (ForwardIterator begin, ForwardIterator end, UnaryFunctor each_fn, NullaryFunctor between_fn)</td></tr>
<tr class="memdesc:a2145da5bde7663d745e9c3ade392809f"><td class="mdescLeft">&#160;</td><td class="mdescRight">An STL-style algorithm similar to std::for_each that applies a second functor between every pair of elements.  <a href="namespacellvm.html#a2145da5bde7663d745e9c3ade392809f">More...</a><br /></td></tr>
<tr class="separator:a2145da5bde7663d745e9c3ade392809f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad75c79282c4734018fe1482b12d03d62"><td class="memTemplParams" colspan="2">template&lt;typename Container , typename UnaryFunctor , typename NullaryFunctor , typename  = std::enable_if_t&lt;              !std::is_constructible&lt;StringRef, UnaryFunctor&gt;::value &amp;&amp;              !std::is_constructible&lt;StringRef, NullaryFunctor&gt;::value&gt;&gt; </td></tr>
<tr class="memitem:ad75c79282c4734018fe1482b12d03d62"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellvm.html#ad75c79282c4734018fe1482b12d03d62">llvm::interleave</a> (<a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> Container &amp;<a class="el" href="lib_2Target_2X86_2README_8txt.html#ae0323a9039add2978bf5b49550572c7c">c</a>, UnaryFunctor each_fn, NullaryFunctor between_fn)</td></tr>
<tr class="separator:ad75c79282c4734018fe1482b12d03d62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c567bf2276d10ac77e08571ea27aabe"><td class="memTemplParams" colspan="2">template&lt;typename Container , typename UnaryFunctor , typename StreamT , typename T  = detail::ValueOfRange&lt;Container&gt;&gt; </td></tr>
<tr class="memitem:a1c567bf2276d10ac77e08571ea27aabe"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellvm.html#a1c567bf2276d10ac77e08571ea27aabe">llvm::interleave</a> (<a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> Container &amp;<a class="el" href="lib_2Target_2X86_2README_8txt.html#ae0323a9039add2978bf5b49550572c7c">c</a>, StreamT &amp;os, UnaryFunctor each_fn, <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> StringRef &amp;separator)</td></tr>
<tr class="memdesc:a1c567bf2276d10ac77e08571ea27aabe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload of interleave for the common case of string separator.  <a href="namespacellvm.html#a1c567bf2276d10ac77e08571ea27aabe">More...</a><br /></td></tr>
<tr class="separator:a1c567bf2276d10ac77e08571ea27aabe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a474e54bf9021abdb881613524c8fdcf5"><td class="memTemplParams" colspan="2">template&lt;typename Container , typename StreamT , typename T  = detail::ValueOfRange&lt;Container&gt;&gt; </td></tr>
<tr class="memitem:a474e54bf9021abdb881613524c8fdcf5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellvm.html#a474e54bf9021abdb881613524c8fdcf5">llvm::interleave</a> (<a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> Container &amp;<a class="el" href="lib_2Target_2X86_2README_8txt.html#ae0323a9039add2978bf5b49550572c7c">c</a>, StreamT &amp;os, <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> StringRef &amp;separator)</td></tr>
<tr class="separator:a474e54bf9021abdb881613524c8fdcf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b4daeeeabc6cdcff5627aace66de8a3"><td class="memTemplParams" colspan="2">template&lt;typename Container , typename UnaryFunctor , typename StreamT , typename T  = detail::ValueOfRange&lt;Container&gt;&gt; </td></tr>
<tr class="memitem:a3b4daeeeabc6cdcff5627aace66de8a3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellvm.html#a3b4daeeeabc6cdcff5627aace66de8a3">llvm::interleaveComma</a> (<a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> Container &amp;<a class="el" href="lib_2Target_2X86_2README_8txt.html#ae0323a9039add2978bf5b49550572c7c">c</a>, StreamT &amp;os, UnaryFunctor each_fn)</td></tr>
<tr class="separator:a3b4daeeeabc6cdcff5627aace66de8a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65c3a0594ff96ff6d3dcef270a3f4a60"><td class="memTemplParams" colspan="2">template&lt;typename Container , typename StreamT , typename T  = detail::ValueOfRange&lt;Container&gt;&gt; </td></tr>
<tr class="memitem:a65c3a0594ff96ff6d3dcef270a3f4a60"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellvm.html#a65c3a0594ff96ff6d3dcef270a3f4a60">llvm::interleaveComma</a> (<a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> Container &amp;<a class="el" href="lib_2Target_2X86_2README_8txt.html#ae0323a9039add2978bf5b49550572c7c">c</a>, StreamT &amp;os)</td></tr>
<tr class="separator:a65c3a0594ff96ff6d3dcef270a3f4a60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a446b5902bb654f6a2aa7ee1faeb2f728"><td class="memTemplParams" colspan="2">template&lt;std::size_t i, typename R &gt; </td></tr>
<tr class="memitem:a446b5902bb654f6a2aa7ee1faeb2f728"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellvm_1_1detail.html#a446b5902bb654f6a2aa7ee1faeb2f728">llvm::detail::get</a> (<a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> result_pair&lt; R &gt; &amp;Pair)</td></tr>
<tr class="separator:a446b5902bb654f6a2aa7ee1faeb2f728"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b2175e18ff52174fad26b6b68818564"><td class="memTemplParams" colspan="2">template&lt;typename R &gt; </td></tr>
<tr class="memitem:a7b2175e18ff52174fad26b6b68818564"><td class="memTemplItemLeft" align="right" valign="top">detail::enumerator&lt; R &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellvm.html#a7b2175e18ff52174fad26b6b68818564">llvm::enumerate</a> (R &amp;&amp;TheRange)</td></tr>
<tr class="memdesc:a7b2175e18ff52174fad26b6b68818564"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given an input range, returns a new range whose values are are pair (A,B) such that A is the 0-based index of the item in the sequence, and B is the value from the original sequence.  <a href="namespacellvm.html#a7b2175e18ff52174fad26b6b68818564">More...</a><br /></td></tr>
<tr class="separator:a7b2175e18ff52174fad26b6b68818564"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bd8d910b6e225c350f6b9399dcbc0cb"><td class="memTemplParams" colspan="2">template&lt;typename Predicate , typename... Args&gt; </td></tr>
<tr class="memitem:a3bd8d910b6e225c350f6b9399dcbc0cb"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellvm_1_1detail.html#a3bd8d910b6e225c350f6b9399dcbc0cb">llvm::detail::all_of_zip_predicate_first</a> (Predicate &amp;&amp;<a class="el" href="README-SSE_8txt.html#a63d206a063eefcdf8c318ded97b65020">P</a>, Args &amp;&amp;...<a class="el" href="NVPTXLowerArgs_8cpp.html#a4d6da696b3c753c5e5fbcc4d21d4cb71">args</a>)</td></tr>
<tr class="separator:a3bd8d910b6e225c350f6b9399dcbc0cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74c1d066ac44bb7e47f657490ac0ca1c"><td class="memTemplParams" colspan="2">template&lt;typename... ArgsThenPredicate, size_t... InputIndexes&gt; </td></tr>
<tr class="memitem:a74c1d066ac44bb7e47f657490ac0ca1c"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellvm_1_1detail.html#a74c1d066ac44bb7e47f657490ac0ca1c">llvm::detail::all_of_zip_predicate_last</a> (std::tuple&lt; ArgsThenPredicate... &gt; argsThenPredicate, std::index_sequence&lt; InputIndexes... &gt;)</td></tr>
<tr class="separator:a74c1d066ac44bb7e47f657490ac0ca1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed5987136ead6f39e3c6c090996a95c7"><td class="memTemplParams" colspan="2">template&lt;typename... ArgsAndPredicate&gt; </td></tr>
<tr class="memitem:aed5987136ead6f39e3c6c090996a95c7"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellvm.html#aed5987136ead6f39e3c6c090996a95c7">llvm::all_of_zip</a> (ArgsAndPredicate &amp;&amp;...argsAndPredicate)</td></tr>
<tr class="memdesc:aed5987136ead6f39e3c6c090996a95c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare two zipped ranges using the provided predicate (as last argument).  <a href="namespacellvm.html#aed5987136ead6f39e3c6c090996a95c7">More...</a><br /></td></tr>
<tr class="separator:aed5987136ead6f39e3c6c090996a95c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4c230a2cefa6dcb3f0356d8a1769cb1"><td class="memTemplParams" colspan="2">template&lt;typename IterTy , typename Pred  = bool (*)(const decltype(*std::declval&lt;IterTy&gt;()) &amp;)&gt; </td></tr>
<tr class="memitem:af4c230a2cefa6dcb3f0356d8a1769cb1"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellvm.html#af4c230a2cefa6dcb3f0356d8a1769cb1">llvm::hasNItems</a> (IterTy &amp;&amp;Begin, IterTy &amp;&amp;End, <a class="el" href="ADT_2tmp_8txt.html#aa10ee7493bddf2c751ca6e05451ef410">unsigned</a> <a class="el" href="regcomp_8c.html#a0240ac851181b84ac374872dc5434ee4">N</a>, Pred &amp;&amp;ShouldBeCounted=[](<a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> decltype(*std::declval&lt; IterTy &gt;()) &amp;) { <a class="el" href="lib_2Target_2X86_2README_8txt.html#a9717e7bbecb906637e86cef6da3d83c2">return</a> <a class="el" href="WebAssemblyExceptionInfo_8cpp.html#ade2a0fe2d2d0735c83fdc3ad5be1e1f2">true</a>;}, std::enable_if_t&lt; !std::is_base_of&lt; std::random_access_iterator_tag, typename std::iterator_traits&lt; std::remove_reference_t&lt; decltype(Begin)&gt;&gt;::iterator_category &gt;::value, void &gt; *=nullptr)</td></tr>
<tr class="memdesc:af4c230a2cefa6dcb3f0356d8a1769cb1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the sequence [Begin, End) has exactly N items.  <a href="namespacellvm.html#af4c230a2cefa6dcb3f0356d8a1769cb1">More...</a><br /></td></tr>
<tr class="separator:af4c230a2cefa6dcb3f0356d8a1769cb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c4e8d0d1867c3cda2958e1844abce64"><td class="memTemplParams" colspan="2">template&lt;typename IterTy , typename Pred  = bool (*)(const decltype(*std::declval&lt;IterTy&gt;()) &amp;)&gt; </td></tr>
<tr class="memitem:a1c4e8d0d1867c3cda2958e1844abce64"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellvm.html#a1c4e8d0d1867c3cda2958e1844abce64">llvm::hasNItemsOrMore</a> (IterTy &amp;&amp;Begin, IterTy &amp;&amp;End, <a class="el" href="ADT_2tmp_8txt.html#aa10ee7493bddf2c751ca6e05451ef410">unsigned</a> <a class="el" href="regcomp_8c.html#a0240ac851181b84ac374872dc5434ee4">N</a>, Pred &amp;&amp;ShouldBeCounted=[](<a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> decltype(*std::declval&lt; IterTy &gt;()) &amp;) { <a class="el" href="lib_2Target_2X86_2README_8txt.html#a9717e7bbecb906637e86cef6da3d83c2">return</a> <a class="el" href="WebAssemblyExceptionInfo_8cpp.html#ade2a0fe2d2d0735c83fdc3ad5be1e1f2">true</a>;}, std::enable_if_t&lt; !std::is_base_of&lt; std::random_access_iterator_tag, typename std::iterator_traits&lt; std::remove_reference_t&lt; decltype(Begin)&gt;&gt;::iterator_category &gt;::value, void &gt; *=nullptr)</td></tr>
<tr class="memdesc:a1c4e8d0d1867c3cda2958e1844abce64"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the sequence [Begin, End) has N or more items.  <a href="namespacellvm.html#a1c4e8d0d1867c3cda2958e1844abce64">More...</a><br /></td></tr>
<tr class="separator:a1c4e8d0d1867c3cda2958e1844abce64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b24ebd69d40090a23b6a2717a896625"><td class="memTemplParams" colspan="2">template&lt;typename IterTy , typename Pred  = bool (*)(const decltype(*std::declval&lt;IterTy&gt;()) &amp;)&gt; </td></tr>
<tr class="memitem:a3b24ebd69d40090a23b6a2717a896625"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellvm.html#a3b24ebd69d40090a23b6a2717a896625">llvm::hasNItemsOrLess</a> (IterTy &amp;&amp;Begin, IterTy &amp;&amp;End, <a class="el" href="ADT_2tmp_8txt.html#aa10ee7493bddf2c751ca6e05451ef410">unsigned</a> <a class="el" href="regcomp_8c.html#a0240ac851181b84ac374872dc5434ee4">N</a>, Pred &amp;&amp;ShouldBeCounted=[](<a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> decltype(*std::declval&lt; IterTy &gt;()) &amp;) { <a class="el" href="lib_2Target_2X86_2README_8txt.html#a9717e7bbecb906637e86cef6da3d83c2">return</a> <a class="el" href="WebAssemblyExceptionInfo_8cpp.html#ade2a0fe2d2d0735c83fdc3ad5be1e1f2">true</a>;})</td></tr>
<tr class="memdesc:a3b24ebd69d40090a23b6a2717a896625"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the sequence [Begin, End) has N or less items.  <a href="namespacellvm.html#a3b24ebd69d40090a23b6a2717a896625">More...</a><br /></td></tr>
<tr class="separator:a3b24ebd69d40090a23b6a2717a896625"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa23468ef9810b74fa5b8d4a8f319d715"><td class="memTemplParams" colspan="2">template&lt;typename ContainerTy &gt; </td></tr>
<tr class="memitem:aa23468ef9810b74fa5b8d4a8f319d715"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellvm.html#aa23468ef9810b74fa5b8d4a8f319d715">llvm::hasNItems</a> (ContainerTy &amp;&amp;<a class="el" href="README__ALTIVEC_8txt.html#a9aacd9146afe44bf656cd664e2a88c8c">C</a>, <a class="el" href="ADT_2tmp_8txt.html#aa10ee7493bddf2c751ca6e05451ef410">unsigned</a> <a class="el" href="regcomp_8c.html#a0240ac851181b84ac374872dc5434ee4">N</a>)</td></tr>
<tr class="memdesc:aa23468ef9810b74fa5b8d4a8f319d715"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the given container has exactly N items.  <a href="namespacellvm.html#aa23468ef9810b74fa5b8d4a8f319d715">More...</a><br /></td></tr>
<tr class="separator:aa23468ef9810b74fa5b8d4a8f319d715"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7cc12beecee8ad26a54d3d81c6361af"><td class="memTemplParams" colspan="2">template&lt;typename ContainerTy &gt; </td></tr>
<tr class="memitem:ae7cc12beecee8ad26a54d3d81c6361af"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellvm.html#ae7cc12beecee8ad26a54d3d81c6361af">llvm::hasNItemsOrMore</a> (ContainerTy &amp;&amp;<a class="el" href="README__ALTIVEC_8txt.html#a9aacd9146afe44bf656cd664e2a88c8c">C</a>, <a class="el" href="ADT_2tmp_8txt.html#aa10ee7493bddf2c751ca6e05451ef410">unsigned</a> <a class="el" href="regcomp_8c.html#a0240ac851181b84ac374872dc5434ee4">N</a>)</td></tr>
<tr class="memdesc:ae7cc12beecee8ad26a54d3d81c6361af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the given container has N or more items.  <a href="namespacellvm.html#ae7cc12beecee8ad26a54d3d81c6361af">More...</a><br /></td></tr>
<tr class="separator:ae7cc12beecee8ad26a54d3d81c6361af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38328ea32bc035b0156dfb05ff54400a"><td class="memTemplParams" colspan="2">template&lt;typename ContainerTy &gt; </td></tr>
<tr class="memitem:a38328ea32bc035b0156dfb05ff54400a"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellvm.html#a38328ea32bc035b0156dfb05ff54400a">llvm::hasNItemsOrLess</a> (ContainerTy &amp;&amp;<a class="el" href="README__ALTIVEC_8txt.html#a9aacd9146afe44bf656cd664e2a88c8c">C</a>, <a class="el" href="ADT_2tmp_8txt.html#aa10ee7493bddf2c751ca6e05451ef410">unsigned</a> <a class="el" href="regcomp_8c.html#a0240ac851181b84ac374872dc5434ee4">N</a>)</td></tr>
<tr class="memdesc:a38328ea32bc035b0156dfb05ff54400a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the given container has N or less items.  <a href="namespacellvm.html#a38328ea32bc035b0156dfb05ff54400a">More...</a><br /></td></tr>
<tr class="separator:a38328ea32bc035b0156dfb05ff54400a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb2f9c935d4fc983512ebb5bd6c57c7f"><td class="memTemplParams" colspan="2">template&lt;class Ptr &gt; </td></tr>
<tr class="memitem:abb2f9c935d4fc983512ebb5bd6c57c7f"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellvm.html#abb2f9c935d4fc983512ebb5bd6c57c7f">llvm::to_address</a> (<a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="TargetLibraryInfo_8cpp.html#aca185e6d0e9f423dbb24440206454872a11dbf501abf829b3ab7049c2d3a8a053">Ptr</a> &amp;<a class="el" href="README-SSE_8txt.html#a63d206a063eefcdf8c318ded97b65020">P</a>)</td></tr>
<tr class="memdesc:abb2f9c935d4fc983512ebb5bd6c57c7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a raw pointer that represents the same address as the argument.  <a href="namespacellvm.html#abb2f9c935d4fc983512ebb5bd6c57c7f">More...</a><br /></td></tr>
<tr class="separator:abb2f9c935d4fc983512ebb5bd6c57c7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa8e53d2dbdc0b31ef5eab3d27ce6edf"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:afa8e53d2dbdc0b31ef5eab3d27ce6edf"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classT.html">T</a> *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellvm.html#afa8e53d2dbdc0b31ef5eab3d27ce6edf">llvm::to_address</a> (<a class="el" href="classT.html">T</a> *<a class="el" href="README-SSE_8txt.html#a63d206a063eefcdf8c318ded97b65020">P</a>)</td></tr>
<tr class="separator:afa8e53d2dbdc0b31ef5eab3d27ce6edf"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:abbd7c0fe6b299efc8f6a4e69eb280d0a"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:abbd7c0fe6b299efc8f6a4e69eb280d0a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="lib_2Target_2ARM_2README_8txt.html#a2e877f6acf2d65a965545e1e5af5f7da">int</a>(*)(<a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> void *, <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> void *)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellvm.html#abbd7c0fe6b299efc8f6a4e69eb280d0a">llvm::get_array_pod_sort_comparator</a> (<a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classT.html">T</a> &amp;)</td></tr>
<tr class="memdesc:abbd7c0fe6b299efc8f6a4e69eb280d0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">get_array_pod_sort_comparator - This is an internal helper function used to get type deduction of <a class="el" href="classT.html">T</a> right.  <a href="namespacellvm.html#abbd7c0fe6b299efc8f6a4e69eb280d0a">More...</a><br /></td></tr>
<tr class="separator:abbd7c0fe6b299efc8f6a4e69eb280d0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This file contains some templates that are useful if you are working with the STL at all.</p>
<p>No library is required when using these functions. </p>

<p class="definition">Definition in file <a class="el" href="STLExtras_8h_source.html">STLExtras.h</a>.</p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Aug 7 2023 10:40:40 for LLVM by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
