<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>LLVM: lib/Target/PowerPC/TargetInfo/PowerPCTargetInfo.cpp Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">LLVM
   &#160;<span id="projectnumber">17.0.0git</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_97aefd0d527b934f1d99a682da8fe6a9.html">lib</a></li><li class="navelem"><a class="el" href="dir_794e483eb1cc7921d35fd149d9cc325b.html">Target</a></li><li class="navelem"><a class="el" href="dir_1854d513cb8eef295481a59a854f7656.html">PowerPC</a></li><li class="navelem"><a class="el" href="dir_9caa13905757761738893b9bf4320c4b.html">TargetInfo</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">PowerPCTargetInfo.cpp</div>  </div>
</div><!--header-->
<div class="contents">
<a href="PowerPCTargetInfo_8cpp.html">Go to the documentation of this file.</a><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;<span class="comment">//===-- PowerPCTargetInfo.cpp - PowerPC Target Implementation -------------===//</span></div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;<span class="comment">//</span></div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;<span class="comment">// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.</span></div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;<span class="comment">// See https://llvm.org/LICENSE.txt for license information.</span></div>
<div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;<span class="comment">// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception</span></div>
<div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;<span class="comment">//</span></div>
<div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;<span class="comment">//===----------------------------------------------------------------------===//</span></div>
<div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160; </div>
<div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;<span class="preprocessor">#include &quot;<a class="code" href="PowerPCTargetInfo_8h.html">TargetInfo/PowerPCTargetInfo.h</a>&quot;</span></div>
<div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;<span class="preprocessor">#include &quot;<a class="code" href="TargetRegistry_8h.html">llvm/MC/TargetRegistry.h</a>&quot;</span></div>
<div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;<span class="keyword">using namespace </span><a class="code" href="namespacellvm.html">llvm</a>;</div>
<div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160; </div>
<div class="line"><a name="l00013"></a><span class="lineno"><a class="line" href="namespacellvm.html#a40d02b699f329a22af7ee94757772da6">   13</a></span>&#160;<a class="code" href="classllvm_1_1Target.html">Target</a> &amp;<a class="code" href="namespacellvm.html#a40d02b699f329a22af7ee94757772da6">llvm::getThePPC32Target</a>() {</div>
<div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;  <span class="keyword">static</span> <a class="code" href="classllvm_1_1Target.html">Target</a> ThePPC32Target;</div>
<div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;  <span class="keywordflow">return</span> ThePPC32Target;</div>
<div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160;}</div>
<div class="line"><a name="l00017"></a><span class="lineno"><a class="line" href="namespacellvm.html#abf184ce24b39916585fc680cc607020e">   17</a></span>&#160;<a class="code" href="classllvm_1_1Target.html">Target</a> &amp;<a class="code" href="namespacellvm.html#abf184ce24b39916585fc680cc607020e">llvm::getThePPC32LETarget</a>() {</div>
<div class="line"><a name="l00018"></a><span class="lineno">   18</span>&#160;  <span class="keyword">static</span> <a class="code" href="classllvm_1_1Target.html">Target</a> ThePPC32LETarget;</div>
<div class="line"><a name="l00019"></a><span class="lineno">   19</span>&#160;  <span class="keywordflow">return</span> ThePPC32LETarget;</div>
<div class="line"><a name="l00020"></a><span class="lineno">   20</span>&#160;}</div>
<div class="line"><a name="l00021"></a><span class="lineno"><a class="line" href="namespacellvm.html#a9e1d3cdb4ff5a68e526fe202ddeee9cb">   21</a></span>&#160;<a class="code" href="classllvm_1_1Target.html">Target</a> &amp;<a class="code" href="namespacellvm.html#a9e1d3cdb4ff5a68e526fe202ddeee9cb">llvm::getThePPC64Target</a>() {</div>
<div class="line"><a name="l00022"></a><span class="lineno">   22</span>&#160;  <span class="keyword">static</span> <a class="code" href="classllvm_1_1Target.html">Target</a> ThePPC64Target;</div>
<div class="line"><a name="l00023"></a><span class="lineno">   23</span>&#160;  <span class="keywordflow">return</span> ThePPC64Target;</div>
<div class="line"><a name="l00024"></a><span class="lineno">   24</span>&#160;}</div>
<div class="line"><a name="l00025"></a><span class="lineno"><a class="line" href="namespacellvm.html#a0a02f22932de8ec49a01c4cab074fd12">   25</a></span>&#160;<a class="code" href="classllvm_1_1Target.html">Target</a> &amp;<a class="code" href="namespacellvm.html#a0a02f22932de8ec49a01c4cab074fd12">llvm::getThePPC64LETarget</a>() {</div>
<div class="line"><a name="l00026"></a><span class="lineno">   26</span>&#160;  <span class="keyword">static</span> <a class="code" href="classllvm_1_1Target.html">Target</a> ThePPC64LETarget;</div>
<div class="line"><a name="l00027"></a><span class="lineno">   27</span>&#160;  <span class="keywordflow">return</span> ThePPC64LETarget;</div>
<div class="line"><a name="l00028"></a><span class="lineno">   28</span>&#160;}</div>
<div class="line"><a name="l00029"></a><span class="lineno">   29</span>&#160; </div>
<div class="line"><a name="l00030"></a><span class="lineno"><a class="line" href="PowerPCTargetInfo_8cpp.html#a5a55d83958fff6797dcc5c5325734fdb">   30</a></span>&#160;<span class="keyword">extern</span> <span class="stringliteral">&quot;C&quot;</span> <a class="code" href="Compiler_8h.html#adeb6f14d9f377993d79fae2efb34ecac">LLVM_EXTERNAL_VISIBILITY</a> <span class="keywordtype">void</span> <a class="code" href="PowerPCTargetInfo_8cpp.html#a5a55d83958fff6797dcc5c5325734fdb">LLVMInitializePowerPCTargetInfo</a>() {</div>
<div class="line"><a name="l00031"></a><span class="lineno">   31</span>&#160;  <a class="code" href="structllvm_1_1RegisterTarget.html">RegisterTarget</a>&lt;<a class="code" href="classllvm_1_1Triple.html#a547abd13f7a3c063aa72c8192a868154ab22bd0f2fbea54c80774becf8d6aa704">Triple::ppc</a>, <span class="comment">/*HasJIT=*/</span><span class="keyword">true</span>&gt; <a class="code" href="namespacellvm_1_1RISCVFenceField.html#a147be9e9780c1e33363ea572d4c7b25fa05c79fbfc58d9dd2851c467a1ef166bf">W</a>(<a class="code" href="namespacellvm.html#a40d02b699f329a22af7ee94757772da6">getThePPC32Target</a>(), <span class="stringliteral">&quot;ppc32&quot;</span>,</div>
<div class="line"><a name="l00032"></a><span class="lineno">   32</span>&#160;                                                 <span class="stringliteral">&quot;PowerPC 32&quot;</span>, <span class="stringliteral">&quot;PPC&quot;</span>);</div>
<div class="line"><a name="l00033"></a><span class="lineno">   33</span>&#160; </div>
<div class="line"><a name="l00034"></a><span class="lineno">   34</span>&#160;  <a class="code" href="structllvm_1_1RegisterTarget.html">RegisterTarget</a>&lt;<a class="code" href="classllvm_1_1Triple.html#a547abd13f7a3c063aa72c8192a868154a440d963f2b5dc6b1268643771492a905">Triple::ppcle</a>, <span class="comment">/*HasJIT=*/</span><span class="keyword">true</span>&gt; <a class="code" href="ErlangGCPrinter_8cpp.html#a74b474c0616ab55c1d9487f11fd31d26">X</a>(</div>
<div class="line"><a name="l00035"></a><span class="lineno">   35</span>&#160;      <a class="code" href="namespacellvm.html#abf184ce24b39916585fc680cc607020e">getThePPC32LETarget</a>(), <span class="stringliteral">&quot;ppc32le&quot;</span>, <span class="stringliteral">&quot;PowerPC 32 LE&quot;</span>, <span class="stringliteral">&quot;PPC&quot;</span>);</div>
<div class="line"><a name="l00036"></a><span class="lineno">   36</span>&#160; </div>
<div class="line"><a name="l00037"></a><span class="lineno">   37</span>&#160;  <a class="code" href="structllvm_1_1RegisterTarget.html">RegisterTarget</a>&lt;<a class="code" href="classllvm_1_1Triple.html#a547abd13f7a3c063aa72c8192a868154aab15cb6de66f724829436a3466411993">Triple::ppc64</a>, <span class="comment">/*HasJIT=*/</span><span class="keyword">true</span>&gt; <a class="code" href="OcamlGCPrinter_8cpp.html#afcf2f797ed287a723263583c9b1c1bce">Y</a>(<a class="code" href="namespacellvm.html#a9e1d3cdb4ff5a68e526fe202ddeee9cb">getThePPC64Target</a>(), <span class="stringliteral">&quot;ppc64&quot;</span>,</div>
<div class="line"><a name="l00038"></a><span class="lineno">   38</span>&#160;                                                   <span class="stringliteral">&quot;PowerPC 64&quot;</span>, <span class="stringliteral">&quot;PPC&quot;</span>);</div>
<div class="line"><a name="l00039"></a><span class="lineno">   39</span>&#160; </div>
<div class="line"><a name="l00040"></a><span class="lineno">   40</span>&#160;  <a class="code" href="structllvm_1_1RegisterTarget.html">RegisterTarget</a>&lt;<a class="code" href="classllvm_1_1Triple.html#a547abd13f7a3c063aa72c8192a868154a4c6fec6469969e44d4af328ef7782c46">Triple::ppc64le</a>, <span class="comment">/*HasJIT=*/</span><span class="keyword">true</span>&gt; <a class="code" href="namespacellvm_1_1ARCCC.html#a9a81d9a1b379cf08150b22e81d7dd006aceb189306b941666e679bf556207c1e4">Z</a>(</div>
<div class="line"><a name="l00041"></a><span class="lineno">   41</span>&#160;      <a class="code" href="namespacellvm.html#a0a02f22932de8ec49a01c4cab074fd12">getThePPC64LETarget</a>(), <span class="stringliteral">&quot;ppc64le&quot;</span>, <span class="stringliteral">&quot;PowerPC 64 LE&quot;</span>, <span class="stringliteral">&quot;PPC&quot;</span>);</div>
<div class="line"><a name="l00042"></a><span class="lineno">   42</span>&#160;}</div>
</div><!-- fragment --></div><!-- contents -->
<div class="ttc" id="alib_2Target_2README_8txt_html_acb559820d9ca11295b4500f179ef6392"><div class="ttname"><a href="lib_2Target_2README_8txt.html#acb559820d9ca11295b4500f179ef6392">i</a></div><div class="ttdeci">i</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2README_8txt_source.html#l00029">README.txt:29</a></div></div>
<div class="ttc" id="aLocalizer_8cpp_html_a428090a453f41a199ef67fc3f2179fbc"><div class="ttname"><a href="Localizer_8cpp.html#a428090a453f41a199ef67fc3f2179fbc">use</a></div><div class="ttdeci">Move duplicate certain instructions close to their use</div><div class="ttdef"><b>Definition:</b> <a href="Localizer_8cpp_source.html#l00032">Localizer.cpp:32</a></div></div>
<div class="ttc" id="aREADME-SSE_8txt_html_a5218c30225690afef9b8089038abccd4"><div class="ttname"><a href="README-SSE_8txt.html#a5218c30225690afef9b8089038abccd4">byte</a></div><div class="ttdeci">SSE Variable shift can be custom lowered to something like which uses a small table unaligned load shuffle instead of going through memory byte</div><div class="ttdef"><b>Definition:</b> <a href="README-SSE_8txt_source.html#l00011">README-SSE.txt:11</a></div></div>
<div class="ttc" id="alib_2Target_2X86_2README_8txt_html_a9a315d042512705500b545a6c6acb2bd"><div class="ttname"><a href="lib_2Target_2X86_2README_8txt.html#a9a315d042512705500b545a6c6acb2bd">set</a></div><div class="ttdeci">We currently generate a but we really shouldn eax ecx xorl edx divl ecx eax divl ecx movl eax ret A similar code sequence works for division We currently compile i32 v2 eax eax jo LBB1_2 atomic and others It is also currently not done for read modify write instructions It is also current not done if the OF or CF flags are needed The shift operators have the complication that when the shift count is EFLAGS is not set</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2X86_2README_8txt_source.html#l01277">README.txt:1277</a></div></div>
<div class="ttc" id="alib_2Target_2ARM_2README_8txt_html_a307e4ed3fc3a19c7f966256d60fe229f"><div class="ttname"><a href="lib_2Target_2ARM_2README_8txt.html#a307e4ed3fc3a19c7f966256d60fe229f">behavior</a></div><div class="ttdeci">should just be implemented with a CLZ instruction Since there are other e that share this behavior</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2ARM_2README_8txt_source.html#l00709">README.txt:709</a></div></div>
<div class="ttc" id="alib_2Target_2ARM_2README_8txt_html_aa660bb6aec19f6cb361a36080a776dfb"><div class="ttname"><a href="lib_2Target_2ARM_2README_8txt.html#aa660bb6aec19f6cb361a36080a776dfb">is</a></div><div class="ttdeci">should just be implemented with a CLZ instruction Since there are other e that share this it would be best to implement this in a target independent as zero is the default value for the binary encoder e add r0 add r5 Register operands should be distinct That is</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2ARM_2README_8txt_source.html#l00725">README.txt:725</a></div></div>
<div class="ttc" id="alib_2Target_2README_8txt_html_a86a8d7c35fb9eeb53412ca9bca388e99"><div class="ttname"><a href="lib_2Target_2README_8txt.html#a86a8d7c35fb9eeb53412ca9bca388e99">as</a></div><div class="ttdeci">compiles conv shl5 shl ret i32 or10 it would be better as</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2README_8txt_source.html#l00615">README.txt:615</a></div></div>
<div class="ttc" id="aREADME__ALTIVEC_8txt_html_a9d3ba236d13373cde794da2023acc7a0"><div class="ttname"><a href="README__ALTIVEC_8txt.html#a9d3ba236d13373cde794da2023acc7a0">Attrs</a></div><div class="ttdeci">Function Attrs</div><div class="ttdef"><b>Definition:</b> <a href="README__ALTIVEC_8txt_source.html#l00215">README_ALTIVEC.txt:215</a></div></div>
<div class="ttc" id="aNVPTXISelLowering_8cpp_html_ae1a90b5d85643644483b2ca70da4d13faed3fa7a5efe80dad3ea3d86cc14be246"><div class="ttname"><a href="NVPTXISelLowering_8cpp.html#ae1a90b5d85643644483b2ca70da4d13faed3fa7a5efe80dad3ea3d86cc14be246">Signed</a></div><div class="ttdeci">@ Signed</div><div class="ttdef"><b>Definition:</b> <a href="NVPTXISelLowering_8cpp_source.html#l04884">NVPTXISelLowering.cpp:4884</a></div></div>
<div class="ttc" id="alib_2Target_2X86_2README_8txt_html_ae6a03db7c9e76cfd0ea4bc4b6b61d721"><div class="ttname"><a href="lib_2Target_2X86_2README_8txt.html#ae6a03db7c9e76cfd0ea4bc4b6b61d721">readnone</a></div><div class="ttdeci">We generate the following IR with i32 b nounwind readnone</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2X86_2README_8txt_source.html#l01443">README.txt:1443</a></div></div>
<div class="ttc" id="alib_2Target_2WebAssembly_2README_8txt_html_a2ff42d8940320394fe7c9ebefd235621"><div class="ttname"><a href="lib_2Target_2WebAssembly_2README_8txt.html#a2ff42d8940320394fe7c9ebefd235621">constant</a></div><div class="ttdeci">we should consider alternate ways to model stack dependencies Lots of things could be done in WebAssemblyTargetTransformInfo cpp there are numerous optimization related hooks that can be overridden in WebAssemblyTargetLowering Instead of the OptimizeReturned which should consider preserving the returned attribute through to MachineInstrs and extending the MemIntrinsicResults pass to do this optimization on calls too That would also let the WebAssemblyPeephole pass clean up dead defs for such as it does for stores Consider implementing and or getMachineCombinerPatterns Find a clean way to fix the problem which leads to the Shrink Wrapping pass being run after the WebAssembly PEI pass When setting multiple variables to the same constant</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2WebAssembly_2README_8txt_source.html#l00091">README.txt:91</a></div></div>
<div class="ttc" id="anamespacellvm_1_1object_html_a42e5b6ee6f67085d2115b2ea44588c47a21197b49151a350ee6714622ed988cc7"><div class="ttname"><a href="namespacellvm_1_1object.html#a42e5b6ee6f67085d2115b2ea44588c47a21197b49151a350ee6714622ed988cc7">llvm::object::Equal</a></div><div class="ttdeci">@ Equal</div><div class="ttdef"><b>Definition:</b> <a href="COFFModuleDefinition_8cpp_source.html#l00036">COFFModuleDefinition.cpp:36</a></div></div>
<div class="ttc" id="anamespacellvm_html"><div class="ttname"><a href="namespacellvm.html">llvm</a></div><div class="ttdoc">This is an optimization pass for GlobalISel generic memory operations.</div><div class="ttdef"><b>Definition:</b> <a href="AddressRanges_8h_source.html#l00018">AddressRanges.h:18</a></div></div>
<div class="ttc" id="aREADME__P9_8txt_html_af9ce2a43307dff54d7c53b165d8ed194"><div class="ttname"><a href="README__P9_8txt.html#af9ce2a43307dff54d7c53b165d8ed194">intrinsic</a></div><div class="ttdeci">QP Compare Ordered outs ins xscmpudp No intrinsic</div><div class="ttdef"><b>Definition:</b> <a href="README__P9_8txt_source.html#l00303">README_P9.txt:303</a></div></div>
<div class="ttc" id="aREADME__ALTIVEC_8txt_html_afb354c8aea0150628f8aa06c7f4a4168"><div class="ttname"><a href="README__ALTIVEC_8txt.html#afb354c8aea0150628f8aa06c7f4a4168">f</a></div><div class="ttdeci">vector float f(vector float a, vector float b)</div><div class="ttdef"><b>Definition:</b> <a href="README__ALTIVEC_8txt_source.html#l00200">README_ALTIVEC.txt:200</a></div></div>
<div class="ttc" id="aREADME__P9_8txt_html_ae7f23b6ddd12bd7a19c999dabba7f6c2"><div class="ttname"><a href="README__P9_8txt.html#ae7f23b6ddd12bd7a19c999dabba7f6c2">PPCfsqrtrto</a></div><div class="ttdeci">Decimal Convert From to National Zoned Signed int_ppc_altivec_bcdcfno int_ppc_altivec_bcdcfzo int_ppc_altivec_bcdctno int_ppc_altivec_bcdctzo int_ppc_altivec_bcdcfsqo int_ppc_altivec_bcdctsqo int_ppc_altivec_bcdcpsgno int_ppc_altivec_bcdsetsgno int_ppc_altivec_bcdso int_ppc_altivec_bcduso int_ppc_altivec_bcdsro i e VA byte[7] Decimal(Unsigned) Truncate Define DAG Node in PPCInstrInfo def def def def PPCfsqrtrto</div><div class="ttdef"><b>Definition:</b> <a href="README__P9_8txt_source.html#l00208">README_P9.txt:208</a></div></div>
<div class="ttc" id="aREADME-SSE_8txt_html_abb4ce3bc3096a12d4b93460bf78bcf95"><div class="ttname"><a href="README-SSE_8txt.html#abb4ce3bc3096a12d4b93460bf78bcf95">it</a></div><div class="ttdeci">into xmm2 addss xmm2 xmm1 xmm3 addss xmm3 movaps xmm0 unpcklps xmm0 ret seems silly when it could just be one addps Expand libm rounding functions main should enable SSE DAZ mode and other fast SSE modes Think about doing i64 math in SSE regs on x86 This testcase should have no SSE instructions in it</div><div class="ttdef"><b>Definition:</b> <a href="README-SSE_8txt_source.html#l00081">README-SSE.txt:81</a></div></div>
<div class="ttc" id="aREADME__P9_8txt_html_aa793083a95c48c23abfa352d4335685a"><div class="ttname"><a href="README__P9_8txt.html#aa793083a95c48c23abfa352d4335685a">Insert</a></div><div class="ttdeci">Vector Rotate Left Mask Mask Insert</div><div class="ttdef"><b>Definition:</b> <a href="README__P9_8txt_source.html#l00112">README_P9.txt:112</a></div></div>
<div class="ttc" id="aREADME__P9_8txt_html_aeca206b5c0e2d7e97da20ad00b5ec4c0"><div class="ttname"><a href="README__P9_8txt.html#aeca206b5c0e2d7e97da20ad00b5ec4c0">PowerISA_V3</a></div><div class="ttdeci">It looks like we only need to define PPCfmarto for these because according to PowerISA_V3</div><div class="ttdef"><b>Definition:</b> <a href="README__P9_8txt_source.html#l00253">README_P9.txt:253</a></div></div>
<div class="ttc" id="alib_2Target_2WebAssembly_2README_8txt_html_acd5f99f9e89410e51fc09950e8dbc7dd"><div class="ttname"><a href="lib_2Target_2WebAssembly_2README_8txt.html#acd5f99f9e89410e51fc09950e8dbc7dd">see</a></div><div class="ttdeci">The object format emitted by the WebAssembly backed is documented see the home and packaging for producing WebAssembly applications that can run in browsers and other environments wasi sdk provides a more minimal C C SDK based on llvm and a libc based on for producing WebAssemmbly applictions that use the WASI ABI Rust provides WebAssembly support integrated into Cargo There are two main which provides a relatively minimal environment that has an emphasis on being native wasm32 unknown which uses Emscripten internally and provides standard C C filesystem GL and SDL bindings For more see</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2WebAssembly_2README_8txt_source.html#l00041">README.txt:41</a></div></div>
<div class="ttc" id="aREADME__ALTIVEC_8txt_html_afe1b3eeae22187a80af63b3c283ee556"><div class="ttname"><a href="README__ALTIVEC_8txt.html#afe1b3eeae22187a80af63b3c283ee556">b</a></div><div class="ttdeci">cond_next The vcmpeqfp vcmpeqfp instructions currently cannot be merged when the vcmpeqfp result is used by a branch This can be improved The code generated for this is truly float b</div><div class="ttdef"><b>Definition:</b> <a href="README__ALTIVEC_8txt_source.html#l00108">README_ALTIVEC.txt:108</a></div></div>
<div class="ttc" id="aSIOptimizeExecMasking_8cpp_html_a41f299460d380acb533b0d91dca4d45a"><div class="ttname"><a href="SIOptimizeExecMasking_8cpp.html#a41f299460d380acb533b0d91dca4d45a">operations</a></div><div class="ttdeci">SI optimize exec mask operations</div><div class="ttdef"><b>Definition:</b> <a href="SIOptimizeExecMasking_8cpp_source.html#l00086">SIOptimizeExecMasking.cpp:86</a></div></div>
<div class="ttc" id="alib_2Target_2X86_2README_8txt_html_a57d0df36879c90c8fa1b9e0d5ad54a26"><div class="ttname"><a href="lib_2Target_2X86_2README_8txt.html#a57d0df36879c90c8fa1b9e0d5ad54a26">Note</a></div><div class="ttdeci">We currently emits eax Perhaps this is what we really should generate is Is imull three or four cycles Note</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2X86_2README_8txt_source.html#l00239">README.txt:239</a></div></div>
<div class="ttc" id="aREADME__ALTIVEC_8txt_html_ac4d11ab1f1d3fda73d0ab49deaebeae1"><div class="ttname"><a href="README__ALTIVEC_8txt.html#ac4d11ab1f1d3fda73d0ab49deaebeae1">addis</a></div><div class="ttdeci">Function&lt; 16 x i8 &gt; Produces the following code with LCPI0_0 toc ha addis</div><div class="ttdef"><b>Definition:</b> <a href="README__ALTIVEC_8txt_source.html#l00232">README_ALTIVEC.txt:232</a></div></div>
<div class="ttc" id="aREADME__P9_8txt_html_a82715e190e20bedfb6fdcbc9cba3853e"><div class="ttname"><a href="README__P9_8txt.html#a82715e190e20bedfb6fdcbc9cba3853e">int_ppc_altivec_vmul10euq</a></div><div class="ttdeci">Vector Multiply by Extended Write Unsigned int_ppc_altivec_vmul10euq</div><div class="ttdef"><b>Definition:</b> <a href="README__P9_8txt_source.html#l00140">README_P9.txt:140</a></div></div>
<div class="ttc" id="alib_2CodeGen_2README_8txt_html_a98f559f710a7595ef874405005c1c2e7"><div class="ttname"><a href="lib_2CodeGen_2README_8txt.html#a98f559f710a7595ef874405005c1c2e7">store</a></div><div class="ttdeci">Common register allocation spilling lr str ldr sxth r3 ldr mla r4 can lr mov lr str ldr sxth r3 mla r4 and then merge mul and lr str ldr sxth r3 mla r4 It also increase the likelihood the store may become dead bb27 Successors according to LLVM ID Predecessors according to mbb&lt; bb27, 0x8b0a7c0 &gt; Note ADDri is not a two address instruction its result reg1037 is an operand of the PHI node in bb76 and its operand reg1039 is the result of the PHI node We should treat it as a two address code and make sure the ADDri is scheduled after any node that reads reg1039 Use info(i.e. register scavenger) to assign it a free register to allow reuse the collector could move the objects and invalidate the derived pointer This is bad enough in the first but safe points can crop up unpredictably **array_addr i32 n y store obj obj **nth_el If the i64 division is lowered to a then a safe point array and nth_el no longer point into the correct object The fix for this is to copy address calculations so that dependent pointers are never live across safe point boundaries But the loads cannot be copied like this if there was an intervening store</div><div class="ttdef"><b>Definition:</b> <a href="lib_2CodeGen_2README_8txt_source.html#l00133">README.txt:133</a></div></div>
<div class="ttc" id="aclassllvm_1_1Target_html"><div class="ttname"><a href="classllvm_1_1Target.html">llvm::Target</a></div><div class="ttdoc">Target - Wrapper for Target specific information.</div><div class="ttdef"><b>Definition:</b> <a href="TargetRegistry_8h_source.html#l00149">TargetRegistry.h:149</a></div></div>
<div class="ttc" id="aREADME__P9_8txt_html_acbbe46c3f847873e843dd6d467095187"><div class="ttname"><a href="README__P9_8txt.html#acbbe46c3f847873e843dd6d467095187">NoEncode&lt;&quot;$vTi&quot;&gt;</a></div><div class="ttdeci">fma NoEncode&lt;&quot;$vTi&quot;&gt;</div><div class="ttdef"><b>Definition:</b> <a href="README__P9_8txt_source.html#l00227">README_P9.txt:227</a></div></div>
<div class="ttc" id="aREADME__P9_8txt_html_ae0c693afc7628462bf28808b35f51a46"><div class="ttname"><a href="README__P9_8txt.html#ae0c693afc7628462bf28808b35f51a46">v2i64</a></div><div class="ttdeci">QP Compare Ordered outs ins xscmpudp No builtin are required Or llvm fcmp order unorder compare DP QP Compare builtin are required DP xscmp *dp write to VSX register Use int_ppc_vsx_xscmpeqdp int_ppc_vsx_xscmpgedp int_ppc_vsx_xscmpgtdp int_ppc_vsx_xscmpnedp v2i64</div><div class="ttdef"><b>Definition:</b> <a href="README__P9_8txt_source.html#l00323">README_P9.txt:323</a></div></div>
<div class="ttc" id="anamespacellvm_1_1tgtok_html_abbc5259d649363016626e2529fabe0c5a4a6621856674f376740a1ba6efd809e3"><div class="ttname"><a href="namespacellvm_1_1tgtok.html#abbc5259d649363016626e2529fabe0c5a4a6621856674f376740a1ba6efd809e3">llvm::tgtok::Code</a></div><div class="ttdeci">@ Code</div><div class="ttdef"><b>Definition:</b> <a href="TGLexer_8h_source.html#l00050">TGLexer.h:50</a></div></div>
<div class="ttc" id="anamespacellvm_1_1RISCVFenceField_html_a147be9e9780c1e33363ea572d4c7b25fa05c79fbfc58d9dd2851c467a1ef166bf"><div class="ttname"><a href="namespacellvm_1_1RISCVFenceField.html#a147be9e9780c1e33363ea572d4c7b25fa05c79fbfc58d9dd2851c467a1ef166bf">llvm::RISCVFenceField::W</a></div><div class="ttdeci">@ W</div><div class="ttdef"><b>Definition:</b> <a href="RISCVBaseInfo_8h_source.html#l00279">RISCVBaseInfo.h:279</a></div></div>
<div class="ttc" id="aREADME__ALTIVEC_8txt_html_ab291f2e71eb00e9c419f00fec6d1f3c1"><div class="ttname"><a href="README__ALTIVEC_8txt.html#ab291f2e71eb00e9c419f00fec6d1f3c1">codegen</a></div><div class="ttdeci">Since we know that Vector is byte aligned and we know the element offset of we should change the load into a lve *x instead of doing a load store lve *x sequence Implement passing vectors by value into calls and receiving them as arguments GCC apparently tries to codegen</div><div class="ttdef"><b>Definition:</b> <a href="README__ALTIVEC_8txt_source.html#l00046">README_ALTIVEC.txt:46</a></div></div>
<div class="ttc" id="anamespacellvm_1_1dwarf_html_a6c06a10ffac779879f6b62a1a904517b"><div class="ttname"><a href="namespacellvm_1_1dwarf.html#a6c06a10ffac779879f6b62a1a904517b">llvm::dwarf::Form</a></div><div class="ttdeci">Form</div><div class="ttdef"><b>Definition:</b> <a href="Dwarf_8h_source.html#l00130">Dwarf.h:130</a></div></div>
<div class="ttc" id="aREADME__P9_8txt_html_a6d3349645fde16171036d0183c42be1e"><div class="ttname"><a href="README__P9_8txt.html#a6d3349645fde16171036d0183c42be1e">v16i8</a></div><div class="ttdeci">TODO use VCMP VCMPo form(support intrinsic) - Vector Extract Unsigned v16i8</div><div class="ttdef"><b>Definition:</b> <a href="README__P9_8txt_source.html#l00108">README_P9.txt:108</a></div></div>
<div class="ttc" id="aREADME__ALTIVEC_8txt_html_a1db0193cd0ce687eb4694b8ec0da7116"><div class="ttname"><a href="README__ALTIVEC_8txt.html#a1db0193cd0ce687eb4694b8ec0da7116">pool</a></div><div class="ttdeci">Implement PPCInstrInfo::isLoadFromStackSlot isStoreToStackSlot for vector to generate better spill code The first should be a single lvx from the constant pool</div><div class="ttdef"><b>Definition:</b> <a href="README__ALTIVEC_8txt_source.html#l00008">README_ALTIVEC.txt:8</a></div></div>
<div class="ttc" id="anamespaceR600__InstFlag_html_a23106439cc906be24dc8953eedd3940da8949a42ff4563a29d1e70e18338fd522"><div class="ttname"><a href="namespaceR600__InstFlag.html#a23106439cc906be24dc8953eedd3940da8949a42ff4563a29d1e70e18338fd522">R600_InstFlag::FC</a></div><div class="ttdeci">@ FC</div><div class="ttdef"><b>Definition:</b> <a href="R600Defines_8h_source.html#l00032">R600Defines.h:32</a></div></div>
<div class="ttc" id="aHexagonStoreWidening_8cpp_html_a7d2c711a42f51c1f7b3ce3f8f560fa74"><div class="ttname"><a href="HexagonStoreWidening_8cpp.html#a7d2c711a42f51c1f7b3ce3f8f560fa74">stores</a></div><div class="ttdeci">hexagon widen stores</div><div class="ttdef"><b>Definition:</b> <a href="HexagonStoreWidening_8cpp_source.html#l00118">HexagonStoreWidening.cpp:118</a></div></div>
<div class="ttc" id="aREADME__P9_8txt_html_af514567e4b44d896f4eebc31c5e25362"><div class="ttname"><a href="README__P9_8txt.html#af514567e4b44d896f4eebc31c5e25362">outs</a></div><div class="ttdeci">So we should use XX3Form_Rcr to implement intrinsic Convert DP outs ins xscvdpsp No builtin are required Round &amp;Convert QP DP(dword[1] is set to zero) No builtin are required Round to Quad Precision because you need to assign rounding mode in instruction Provide builtin(set f128:$vT,(int_ppc_vsx_xsrqpi f128:$vB))(set f128 yields&lt; n x&lt; ty &gt; &gt;&lt; result &gt; yields&lt; ty &gt;&lt; result &gt; No builtin are required Load Store load store see def memrix16 in PPCInstrInfo td Load Store Vector load store outs ins lxsdx set load store with conversion from to outs ins lxsspx set load store outs ins lxsiwzx set PPClfiwzx outs</div><div class="ttdoc">This returns a reference to a raw_fd_ostream for standard output.</div><div class="ttdef"><b>Definition:</b> <a href="README__P9_8txt_source.html#l00537">README_P9.txt:537</a></div></div>
<div class="ttc" id="aREADME__ALTIVEC_8txt_html_ac91dc78fc6b797bff2c7aa3bc43a5aea"><div class="ttname"><a href="README__ALTIVEC_8txt.html#ac91dc78fc6b797bff2c7aa3bc43a5aea">instructions</a></div><div class="ttdeci">Since we know that Vector is byte aligned and we know the element offset of we should change the load into a lve *x instead of doing a load store lve *x sequence Implement passing vectors by value into calls and receiving them as arguments GCC apparently tries to then a load and vperm of Variable We need a way to teach tblgen that some operands of an intrinsic are required to be constants The verifier should enforce this constraint We currently codegen SCALAR_TO_VECTOR as a store of the scalar to a byte aligned stack followed by a load vperm We should probably just store it to a scalar stack then use lvsl vperm to load it If the value is already in memory this is a big win extract_vector_elt of an arbitrary constant vector can be done with the following instructions</div><div class="ttdef"><b>Definition:</b> <a href="README__ALTIVEC_8txt_source.html#l00066">README_ALTIVEC.txt:66</a></div></div>
<div class="ttc" id="aREADME__P9_8txt_html_a5fa0c961bef06745918d06d84e45a46e"><div class="ttname"><a href="README__P9_8txt.html#a5fa0c961bef06745918d06d84e45a46e">$XB</a></div><div class="ttdeci">QP Compare Ordered outs ins xscmpudp $XB</div><div class="ttdef"><b>Definition:</b> <a href="README__P9_8txt_source.html#l00301">README_P9.txt:301</a></div></div>
<div class="ttc" id="alib_2Target_2ARM_2README_8txt_html_a91f4469a9d29e354421494afd4ba466d"><div class="ttname"><a href="lib_2Target_2ARM_2README_8txt.html#a91f4469a9d29e354421494afd4ba466d">to</a></div><div class="ttdeci">Should compile to</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2ARM_2README_8txt_source.html#l00449">README.txt:449</a></div></div>
<div class="ttc" id="alib_2Target_2README_8txt_html_a8db36c82f32d6f6a4d35a00e55be03a8"><div class="ttname"><a href="lib_2Target_2README_8txt.html#a8db36c82f32d6f6a4d35a00e55be03a8">Shift</a></div><div class="ttdeci">bool Shift</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2README_8txt_source.html#l00468">README.txt:468</a></div></div>
<div class="ttc" id="aREADME__P9_8txt_html_a85c67c0512944df5b5a044eb1e317b60"><div class="ttname"><a href="README__P9_8txt.html#a85c67c0512944df5b5a044eb1e317b60">QP</a></div><div class="ttdeci">So we should use XX3Form_Rcr to implement intrinsic Convert DP QP</div><div class="ttdef"><b>Definition:</b> <a href="README__P9_8txt_source.html#l00329">README_P9.txt:329</a></div></div>
<div class="ttc" id="aMSA_8txt_html_ab49a28dbe60da0a607449e5308b1ec3f"><div class="ttname"><a href="MSA_8txt.html#ab49a28dbe60da0a607449e5308b1ec3f">Instructions</a></div><div class="ttdeci">Code Generation Notes for reduce the size of the ISel and reduce repetition in the implementation In a small number of this can cause even when no optimisation has taken place Instructions</div><div class="ttdef"><b>Definition:</b> <a href="MSA_8txt_source.html#l00011">MSA.txt:11</a></div></div>
<div class="ttc" id="anamespacellvm_1_1sys_1_1path_html_a214ec2f04ffd92636ed4bd2717607a1d"><div class="ttname"><a href="namespacellvm_1_1sys_1_1path.html#a214ec2f04ffd92636ed4bd2717607a1d">llvm::sys::path::end</a></div><div class="ttdeci">const_iterator end(StringRef path)</div><div class="ttdoc">Get end iterator over path.</div><div class="ttdef"><b>Definition:</b> <a href="Path_8cpp_source.html#l00235">Path.cpp:235</a></div></div>
<div class="ttc" id="alib_2Target_2README_8txt_html_add71801b35be0fc55386370f571068fb"><div class="ttname"><a href="lib_2Target_2README_8txt.html#add71801b35be0fc55386370f571068fb">i8</a></div><div class="ttdeci">Clang compiles this i8</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2README_8txt_source.html#l00504">README.txt:504</a></div></div>
<div class="ttc" id="aREADME__P9_8txt_html_a08427d89823ae59cd237475dde4e07e8"><div class="ttname"><a href="README__P9_8txt.html#a08427d89823ae59cd237475dde4e07e8">Integer</a></div><div class="ttdeci">So we should use XX3Form_Rcr to implement intrinsic Convert DP outs ins xscvdpsp No builtin are required Round &amp;Convert QP DP(dword[1] is set to zero) No builtin are required Round to Quad Precision Integer</div><div class="ttdef"><b>Definition:</b> <a href="README__P9_8txt_source.html#l00366">README_P9.txt:366</a></div></div>
<div class="ttc" id="aclassllvm_1_1Triple_html_a547abd13f7a3c063aa72c8192a868154ab22bd0f2fbea54c80774becf8d6aa704"><div class="ttname"><a href="classllvm_1_1Triple.html#a547abd13f7a3c063aa72c8192a868154ab22bd0f2fbea54c80774becf8d6aa704">llvm::Triple::ppc</a></div><div class="ttdeci">@ ppc</div><div class="ttdef"><b>Definition:</b> <a href="Triple_8h_source.html#l00069">Triple.h:69</a></div></div>
<div class="ttc" id="aREADME__ALTIVEC_8txt_html_aa100c3ab24b9c0b6bc434846f615ec59"><div class="ttname"><a href="README__ALTIVEC_8txt.html#aa100c3ab24b9c0b6bc434846f615ec59">slot</a></div><div class="ttdeci">Since we know that Vector is byte aligned and we know the element offset of we should change the load into a lve *x instead of doing a load store lve *x sequence Implement passing vectors by value into calls and receiving them as arguments GCC apparently tries to then a load and vperm of Variable We need a way to teach tblgen that some operands of an intrinsic are required to be constants The verifier should enforce this constraint We currently codegen SCALAR_TO_VECTOR as a store of the scalar to a byte aligned stack slot</div><div class="ttdef"><b>Definition:</b> <a href="README__ALTIVEC_8txt_source.html#l00057">README_ALTIVEC.txt:57</a></div></div>
<div class="ttc" id="aREADME__P9_8txt_html_afc19dab8eb1f8a8d5e7c660f55d99cc1"><div class="ttname"><a href="README__P9_8txt.html#afc19dab8eb1f8a8d5e7c660f55d99cc1">f32</a></div><div class="ttdeci">So we should use XX3Form_Rcr to implement intrinsic Convert DP outs ins xscvdpsp No builtin are required Round &amp;Convert QP DP(dword[1] is set to zero) No builtin are required Round to Quad Precision because you need to assign rounding mode in instruction Provide builtin(set f128:$vT,(int_ppc_vsx_xsrqpi f128:$vB))(set f128 yields&lt; n x&lt; ty &gt; &gt;&lt; result &gt; yields&lt; ty &gt;&lt; result &gt; No builtin are required Load Store load store see def memrix16 in PPCInstrInfo td Load Store Vector load store outs ins lxsdx set load store with conversion from to outs ins lxsspx set f32</div><div class="ttdef"><b>Definition:</b> <a href="README__P9_8txt_source.html#l00522">README_P9.txt:522</a></div></div>
<div class="ttc" id="aREADME__P9_8txt_html_ae6881514a39f1bcf75ad62e5188700a4"><div class="ttname"><a href="README__P9_8txt.html#ae6881514a39f1bcf75ad62e5188700a4">Vector</a></div><div class="ttdeci">So we should use XX3Form_Rcr to implement intrinsic Convert DP outs ins xscvdpsp No builtin are required Round &amp;Convert QP DP(dword[1] is set to zero) No builtin are required Round to Quad Precision because you need to assign rounding mode in instruction Provide builtin(set f128:$vT,(int_ppc_vsx_xsrqpi f128:$vB))(set f128 yields&lt; n x&lt; ty &gt; &gt;&lt; result &gt; yields&lt; ty &gt;&lt; result &gt; No builtin are required Load Store Vector</div><div class="ttdef"><b>Definition:</b> <a href="README__P9_8txt_source.html#l00497">README_P9.txt:497</a></div></div>
<div class="ttc" id="aMips16ISelLowering_8cpp_html_a0acb682b8260ab1c60b918599864e2e5"><div class="ttname"><a href="Mips16ISelLowering_8cpp.html#a0acb682b8260ab1c60b918599864e2e5">T</a></div><div class="ttdeci">#define T</div><div class="ttdef"><b>Definition:</b> <a href="Mips16ISelLowering_8cpp_source.html#l00341">Mips16ISelLowering.cpp:341</a></div></div>
<div class="ttc" id="aREADME__P9_8txt_html_a9679eda65da04e63b0fc49644be06685"><div class="ttname"><a href="README__P9_8txt.html#a9679eda65da04e63b0fc49644be06685">i1</a></div><div class="ttdeci">Decimal Convert From to National Zoned Signed int_ppc_altivec_bcdcfno i1</div><div class="ttdef"><b>Definition:</b> <a href="README__P9_8txt_source.html#l00147">README_P9.txt:147</a></div></div>
<div class="ttc" id="anamespacellvm_1_1HexagonII_html_aee75e70da0fb5b84ea847ab7daf9429ba558e41ab1c3ddb0611edc2a5ed235ec3"><div class="ttname"><a href="namespacellvm_1_1HexagonII.html#aee75e70da0fb5b84ea847ab7daf9429ba558e41ab1c3ddb0611edc2a5ed235ec3">llvm::HexagonII::Absolute</a></div><div class="ttdeci">@ Absolute</div><div class="ttdef"><b>Definition:</b> <a href="HexagonBaseInfo_8h_source.html#l00032">HexagonBaseInfo.h:32</a></div></div>
<div class="ttc" id="alib_2Target_2ARM_2README_8txt_html_a806885525dd4f77e8ef4f8b6bad2902d"><div class="ttname"><a href="lib_2Target_2ARM_2README_8txt.html#a806885525dd4f77e8ef4f8b6bad2902d">g</a></div><div class="ttdeci">should just be implemented with a CLZ instruction Since there are other e g</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2ARM_2README_8txt_source.html#l00709">README.txt:709</a></div></div>
<div class="ttc" id="aREADME__P9_8txt_html_a1bd9fd3527e234953881e7e37d7cc9ca"><div class="ttname"><a href="README__P9_8txt.html#a1bd9fd3527e234953881e7e37d7cc9ca">vssrc</a></div><div class="ttdeci">So we should use XX3Form_Rcr to implement intrinsic Convert DP outs ins xscvdpsp No builtin are required Round &amp;Convert QP DP(dword[1] is set to zero) No builtin are required Round to Quad Precision because you need to assign rounding mode in instruction Provide builtin(set f128:$vT,(int_ppc_vsx_xsrqpi f128:$vB))(set f128 yields&lt; n x&lt; ty &gt; &gt;&lt; result &gt; yields&lt; ty &gt;&lt; result &gt; No builtin are required Load Store load store see def memrix16 in PPCInstrInfo td Load Store Vector load store outs ins lxsdx set load store with conversion from to outs vssrc</div><div class="ttdef"><b>Definition:</b> <a href="README__P9_8txt_source.html#l00520">README_P9.txt:520</a></div></div>
<div class="ttc" id="aREADME__P9_8txt_html_a80866962d6fddc1a61c00f3c22568d29"><div class="ttname"><a href="README__P9_8txt.html#a80866962d6fddc1a61c00f3c22568d29">IIC_VecFP</a></div><div class="ttdeci">So we should use XX3Form_Rcr to implement intrinsic Convert DP outs ins xscvdpsp IIC_VecFP</div><div class="ttdef"><b>Definition:</b> <a href="README__P9_8txt_source.html#l00331">README_P9.txt:331</a></div></div>
<div class="ttc" id="alib_2Target_2WebAssembly_2README_8txt_html_a3828c493031579f0c68587b19619f7e2"><div class="ttname"><a href="lib_2Target_2WebAssembly_2README_8txt.html#a3828c493031579f0c68587b19619f7e2">that</a></div><div class="ttdeci">we should consider alternate ways to model stack dependencies Lots of things could be done in WebAssemblyTargetTransformInfo cpp there are numerous optimization related hooks that can be overridden in WebAssemblyTargetLowering Instead of the OptimizeReturned which should consider preserving the returned attribute through to MachineInstrs and extending the MemIntrinsicResults pass to do this optimization on calls too That would also let the WebAssemblyPeephole pass clean up dead defs for such as it does for stores Consider implementing and or getMachineCombinerPatterns Find a clean way to fix the problem which leads to the Shrink Wrapping pass being run after the WebAssembly PEI pass When setting multiple variables to the same we currently get code like const It could be done with a smaller encoding like local tee $pop5 local $pop6 WebAssembly registers are implicitly initialized to zero Explicit zeroing is therefore often redundant and could be optimized away Small indices may use smaller encodings than large indices WebAssemblyRegColoring and or WebAssemblyRegRenumbering should sort registers according to their usage frequency to maximize the usage of smaller encodings Many cases of irreducible control flow could be transformed more optimally than via the transform in WebAssemblyFixIrreducibleControlFlow cpp It may also be worthwhile to do transforms before register particularly when duplicating to allow register coloring to be aware of the duplication WebAssemblyRegStackify could use AliasAnalysis to reorder loads and stores more aggressively WebAssemblyRegStackify is currently a greedy algorithm This means that</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2WebAssembly_2README_8txt_source.html#l00130">README.txt:130</a></div></div>
<div class="ttc" id="aREADME__ALTIVEC_8txt_html_ac1eff75da018daa05213eb9cf9211682"><div class="ttname"><a href="README__ALTIVEC_8txt.html#ac1eff75da018daa05213eb9cf9211682">vpmsumb</a></div><div class="ttdeci">Function&lt; 16 x i8 &gt; Produces the following code with LCPI0_0 toc ha LCPI0_1 toc ha LCPI0_0 toc l LCPI0_1 toc l vpmsumb</div><div class="ttdef"><b>Definition:</b> <a href="README__ALTIVEC_8txt_source.html#l00243">README_ALTIVEC.txt:243</a></div></div>
<div class="ttc" id="alib_2Target_2X86_2README_8txt_html_a0aa3d83b100058ffd7399364d6b76b5d"><div class="ttname"><a href="lib_2Target_2X86_2README_8txt.html#a0aa3d83b100058ffd7399364d6b76b5d">and</a></div><div class="ttdeci">We currently generate a but we really shouldn eax ecx xorl edx divl ecx eax divl ecx movl eax ret A similar code sequence works for division We currently compile i32 v2 eax eax jo LBB1_2 and</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2X86_2README_8txt_source.html#l01271">README.txt:1271</a></div></div>
<div class="ttc" id="anamespacellvm_1_1SPII_html_a1c7202c6054fef862bbed45957747cdfa5069619ca8fdce305534f3fe85091a0f"><div class="ttname"><a href="namespacellvm_1_1SPII.html#a1c7202c6054fef862bbed45957747cdfa5069619ca8fdce305534f3fe85091a0f">llvm::SPII::Load</a></div><div class="ttdeci">@ Load</div><div class="ttdef"><b>Definition:</b> <a href="SparcInstrInfo_8h_source.html#l00032">SparcInstrInfo.h:32</a></div></div>
<div class="ttc" id="anamespacellvm_html_ae551fe3e2b167b36005b26473e993884a26aa2e7865f749b52f3b77991776c40d"><div class="ttname"><a href="namespacellvm.html#ae551fe3e2b167b36005b26473e993884a26aa2e7865f749b52f3b77991776c40d">llvm::Data</a></div><div class="ttdeci">@ Data</div><div class="ttdef"><b>Definition:</b> <a href="SIMachineScheduler_8h_source.html#l00055">SIMachineScheduler.h:55</a></div></div>
<div class="ttc" id="alib_2Target_2PowerPC_2README_8txt_html_a7dac26c0290a417e6a6e0ed8ea152a75"><div class="ttname"><a href="lib_2Target_2PowerPC_2README_8txt.html#a7dac26c0290a417e6a6e0ed8ea152a75">like</a></div><div class="ttdeci">Should compile to something like</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2PowerPC_2README_8txt_source.html#l00019">README.txt:19</a></div></div>
<div class="ttc" id="alib_2Target_2X86_2README_8txt_html_a7ef4d3003047043a3de118adbb0570fd"><div class="ttname"><a href="lib_2Target_2X86_2README_8txt.html#a7ef4d3003047043a3de118adbb0570fd">a</a></div><div class="ttdeci">=0.0 ? 0.0 :(a &gt; 0.0 ? 1.0 :-1.0) a</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2X86_2README_8txt_source.html#l00489">README.txt:489</a></div></div>
<div class="ttc" id="aREADME__P9_8txt_html_a15f40fb34a8b343fc64e0f9631965b1f"><div class="ttname"><a href="README__P9_8txt.html#a15f40fb34a8b343fc64e0f9631965b1f">Quadword</a></div><div class="ttdeci">Vector Multiply by Write Unsigned Quadword</div><div class="ttdef"><b>Definition:</b> <a href="README__P9_8txt_source.html#l00131">README_P9.txt:131</a></div></div>
<div class="ttc" id="aREADME__ALTIVEC_8txt_html_a7ee8beac950fd06522b4b5a9fc34c644"><div class="ttname"><a href="README__ALTIVEC_8txt.html#a7ee8beac950fd06522b4b5a9fc34c644">a</a></div><div class="ttdeci">Function align align store&lt; 16 x i8 &gt;&lt; i8 1, i8 2, i8 3, i8 4, i8 5, i8 6, i8 7, i8 8, i8 9, i8 10, i8 11, i8 12, i8 13, i8 14, i8 15, i8 16 &gt;&lt; 16 x i8 &gt; * a</div><div class="ttdef"><b>Definition:</b> <a href="README__ALTIVEC_8txt_source.html#l00217">README_ALTIVEC.txt:217</a></div></div>
<div class="ttc" id="aMSA_8txt_html_ab70729ff3a9bdbe2abf0403e90e4a02c"><div class="ttname"><a href="MSA_8txt.html#ab70729ff3a9bdbe2abf0403e90e4a02c">different</a></div><div class="ttdeci">Code Generation Notes for reduce the size of the ISel and reduce repetition in the implementation In a small number of this can cause different(semantically equivalent) instructions to be used in place of the requested instruction</div></div>
<div class="ttc" id="alib_2Target_2ARM_2README_8txt_html_a505ab8ccf28e119d535a848c546abc77"><div class="ttname"><a href="lib_2Target_2ARM_2README_8txt.html#a505ab8ccf28e119d535a848c546abc77">way</a></div><div class="ttdeci">should just be implemented with a CLZ instruction Since there are other e that share this it would be best to implement this in a target independent way</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2ARM_2README_8txt_source.html#l00720">README.txt:720</a></div></div>
<div class="ttc" id="aREADME__P9_8txt_html_ae070adaf1b4bf0e7c12fcae2b9c5ae67"><div class="ttname"><a href="README__P9_8txt.html#ae070adaf1b4bf0e7c12fcae2b9c5ae67">result</a></div><div class="ttdeci">It looks like we only need to define PPCfmarto for these because according to these instructions perform RTO on fma s result</div><div class="ttdef"><b>Definition:</b> <a href="README__P9_8txt_source.html#l00256">README_P9.txt:256</a></div></div>
<div class="ttc" id="aREADME__P9_8txt_html_a5dd05893bdfe88603971730599877428"><div class="ttname"><a href="README__P9_8txt.html#a5dd05893bdfe88603971730599877428">v8i16</a></div><div class="ttdeci">So we should use XX3Form_Rcr to implement intrinsic Convert DP outs ins xscvdpsp No builtin are required Round &amp;Convert QP DP(dword[1] is set to zero) No builtin are required Round to Quad Precision because you need to assign rounding mode in instruction Provide builtin(set f128:$vT,(int_ppc_vsx_xsrqpi f128:$vB))(set f128 yields&lt; n x&lt; ty &gt; &gt;&lt; result &gt; yields&lt; ty &gt;&lt; result &gt; No builtin are required Load Store load store see def memrix16 in PPCInstrInfo td Load Store Vector load store outs ins lxsdx set load store with conversion from to outs ins lxsspx set load store outs ins lxsiwzx set PPClfiwzx ins stxsiwx PPCstfiwx outs ins lxvd2x set v8i16</div><div class="ttdef"><b>Definition:</b> <a href="README__P9_8txt_source.html#l00548">README_P9.txt:548</a></div></div>
<div class="ttc" id="anamespacellvm_1_1PPCISD_html_ad1c32e5bb1cb213fb836bc3d221e4f19ad7ff3b99ede678baebc8e3cd79b1090a"><div class="ttname"><a href="namespacellvm_1_1PPCISD.html#ad1c32e5bb1cb213fb836bc3d221e4f19ad7ff3b99ede678baebc8e3cd79b1090a">llvm::PPCISD::STXVD2X</a></div><div class="ttdeci">@ STXVD2X</div><div class="ttdoc">CHAIN = STXVD2X CHAIN, VSRC, Ptr - Occurs only for little endian.</div><div class="ttdef"><b>Definition:</b> <a href="PPCISelLowering_8h_source.html#l00583">PPCISelLowering.h:583</a></div></div>
<div class="ttc" id="anamespacellvm_html_a0a02f22932de8ec49a01c4cab074fd12"><div class="ttname"><a href="namespacellvm.html#a0a02f22932de8ec49a01c4cab074fd12">llvm::getThePPC64LETarget</a></div><div class="ttdeci">Target &amp; getThePPC64LETarget()</div><div class="ttdef"><b>Definition:</b> <a href="PowerPCTargetInfo_8cpp_source.html#l00025">PowerPCTargetInfo.cpp:25</a></div></div>
<div class="ttc" id="aREADME__ALTIVEC_8txt_html_adc521a903a50a228d4f9e5ccb3c632cf"><div class="ttname"><a href="README__ALTIVEC_8txt.html#adc521a903a50a228d4f9e5ccb3c632cf">not</a></div><div class="ttdeci">Altivec not</div><div class="ttdef"><b>Definition:</b> <a href="README__ALTIVEC_8txt_source.html#l00028">README_ALTIVEC.txt:28</a></div></div>
<div class="ttc" id="alib_2Target_2README_8txt_html_a16107502a78fcaae694e2189573d5b37"><div class="ttname"><a href="lib_2Target_2README_8txt.html#a16107502a78fcaae694e2189573d5b37">i64</a></div><div class="ttdeci">Clang compiles this i64</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2README_8txt_source.html#l00504">README.txt:504</a></div></div>
<div class="ttc" id="aREADME__ALTIVEC_8txt_html_a81b26f425b4a2c734c5288f336d75f7e"><div class="ttname"><a href="README__ALTIVEC_8txt.html#a81b26f425b4a2c734c5288f336d75f7e">mtriple</a></div><div class="ttdeci">Function&lt; 16 x i8 &gt; Produces the following code with mtriple</div><div class="ttdef"><b>Definition:</b> <a href="README__ALTIVEC_8txt_source.html#l00230">README_ALTIVEC.txt:230</a></div></div>
<div class="ttc" id="aREADME-SSE_8txt_html_a9fb6cbbc77fb02ab3a51b0660bd09909"><div class="ttname"><a href="README-SSE_8txt.html#a9fb6cbbc77fb02ab3a51b0660bd09909">select</a></div><div class="ttdeci">into xmm2 addss xmm2 xmm1 xmm3 addss xmm3 movaps xmm0 unpcklps xmm0 ret seems silly when it could just be one addps Expand libm rounding functions main should enable SSE DAZ mode and other fast SSE modes Think about doing i64 math in SSE regs on x86 This testcase should have no SSE instructions in and only one load from a constant double ret double C the select is being which prevents the dag combiner from turning select(load CPI1)</div></div>
<div class="ttc" id="anamespacellvm_html_a9db8c44b250b90e3ab7e4d144e7c9c2ea60baadb22e80b147e4885ad16760e569"><div class="ttname"><a href="namespacellvm.html#a9db8c44b250b90e3ab7e4d144e7c9c2ea60baadb22e80b147e4885ad16760e569">llvm::ModRefInfo::Ref</a></div><div class="ttdeci">@ Ref</div><div class="ttdoc">The access may reference the value stored in memory.</div></div>
<div class="ttc" id="aREADME__ALTIVEC_8txt_html_a67624ce6018d0cbfd1f6e2cd6f6a3b6a"><div class="ttname"><a href="README__ALTIVEC_8txt.html#a67624ce6018d0cbfd1f6e2cd6f6a3b6a">align</a></div><div class="ttdeci">Function align align store&lt; 16 x i8 &gt;&lt; i8 1, i8 2, i8 3, i8 4, i8 5, i8 6, i8 7, i8 8, i8 9, i8 10, i8 11, i8 12, i8 13, i8 14, i8 15, i8 16 &gt;&lt; 16 x i8 &gt; align store&lt; 16 x i8 &gt;&lt; i8 113, i8 114, i8 115, i8 116, i8 117, i8 118, i8 119, i8 120, i8 121, i8 122, i8 123, i8 124, i8 125, i8 126, i8 127, i8 112 &gt;&lt; 16 x i8 &gt; align</div><div class="ttdef"><b>Definition:</b> <a href="README__ALTIVEC_8txt_source.html#l00219">README_ALTIVEC.txt:219</a></div></div>
<div class="ttc" id="anamespacellvm_1_1PatternMatch_html_a25d956d9e0beadd47ce4bc255dfa811d"><div class="ttname"><a href="namespacellvm_1_1PatternMatch.html#a25d956d9e0beadd47ce4bc255dfa811d">llvm::PatternMatch::match</a></div><div class="ttdeci">bool match(Val *V, const Pattern &amp;P)</div><div class="ttdef"><b>Definition:</b> <a href="PatternMatch_8h_source.html#l00049">PatternMatch.h:49</a></div></div>
<div class="ttc" id="anamespacellvm_1_1msgpack_html_afdae9da66bac09f4b2bfc0fd9f0559e6a46f3ea056caa3126b91f3f70beea068c"><div class="ttname"><a href="namespacellvm_1_1msgpack.html#afdae9da66bac09f4b2bfc0fd9f0559e6a46f3ea056caa3126b91f3f70beea068c">llvm::msgpack::Type::Map</a></div><div class="ttdeci">@ Map</div></div>
<div class="ttc" id="alib_2Target_2X86_2README_8txt_html_af91797dc0ab1ae005fdbf19482859eaf"><div class="ttname"><a href="lib_2Target_2X86_2README_8txt.html#af91797dc0ab1ae005fdbf19482859eaf">shl</a></div><div class="ttdeci">We currently generate a but we really shouldn eax ecx xorl edx divl ecx eax divl ecx movl eax ret A similar code sequence works for division We currently compile i32 v2 eax eax jo LBB1_2 shl</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2X86_2README_8txt_source.html#l01271">README.txt:1271</a></div></div>
<div class="ttc" id="anamespacellvm_1_1support_html_ae0a227ae1b2ada1da82b40479251862ca30d1099d0325778e7b60550d84c621f0"><div class="ttname"><a href="namespacellvm_1_1support.html#ae0a227ae1b2ada1da82b40479251862ca30d1099d0325778e7b60550d84c621f0">llvm::support::little</a></div><div class="ttdeci">@ little</div><div class="ttdef"><b>Definition:</b> <a href="Endian_8h_source.html#l00027">Endian.h:27</a></div></div>
<div class="ttc" id="aREADME__ALTIVEC_8txt_html_a9aacd9146afe44bf656cd664e2a88c8c"><div class="ttname"><a href="README__ALTIVEC_8txt.html#a9aacd9146afe44bf656cd664e2a88c8c">C</a></div><div class="ttdeci">(vector float) vec_cmpeq(*A, *B) C</div><div class="ttdef"><b>Definition:</b> <a href="README__ALTIVEC_8txt_source.html#l00086">README_ALTIVEC.txt:86</a></div></div>
<div class="ttc" id="aREADME__P9_8txt_html_ad39e7e356e5d97ff0e4e7084aa706e59"><div class="ttname"><a href="README__P9_8txt.html#ad39e7e356e5d97ff0e4e7084aa706e59">vsfrc</a></div><div class="ttdeci">QP Compare Ordered outs ins vsfrc</div><div class="ttdef"><b>Definition:</b> <a href="README__P9_8txt_source.html#l00300">README_P9.txt:300</a></div></div>
<div class="ttc" id="aOcamlGCPrinter_8cpp_html_afcf2f797ed287a723263583c9b1c1bce"><div class="ttname"><a href="OcamlGCPrinter_8cpp.html#afcf2f797ed287a723263583c9b1c1bce">Y</a></div><div class="ttdeci">static GCMetadataPrinterRegistry::Add&lt; OcamlGCMetadataPrinter &gt; Y(&quot;ocaml&quot;, &quot;ocaml 3.10-compatible collector&quot;)</div></div>
<div class="ttc" id="aREADME__ALTIVEC_8txt_html_a5a72ad9f497fb7761b095ecff15cd416"><div class="ttname"><a href="README__ALTIVEC_8txt.html#a5a72ad9f497fb7761b095ecff15cd416">aa</a></div><div class="ttdeci">return aa</div><div class="ttdef"><b>Definition:</b> <a href="README__ALTIVEC_8txt_source.html#l00197">README_ALTIVEC.txt:197</a></div></div>
<div class="ttc" id="aREADME-SSE_8txt_html_a50fd53d9a3e55ae78555e11827355565"><div class="ttname"><a href="README-SSE_8txt.html#a50fd53d9a3e55ae78555e11827355565">t</a></div><div class="ttdeci">bitcast float %x to i32 %s=and i32 %t, 2147483647 %d=bitcast i32 %s to float ret float %d } declare float @fabsf(float %n) define float @bar(float %x) nounwind { %d=call float @fabsf(float %x) ret float %d } This IR(from PR6194):target datalayout=&quot;e-p:64:64:64-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64-f32:32:32-f64:64:64-v64:64:64-v128:128:128-a0:0:64-s0:64:64-f80:128:128-n8:16:32:64-S128&quot; target triple=&quot;x86_64-apple-darwin10.0.0&quot; %0=type { double, double } %struct.float3=type { float, float, float } define void @test(%0, %struct.float3 *nocapture %res) nounwind noinline ssp { entry:%tmp18=extractvalue %0 %0, 0 t</div><div class="ttdef"><b>Definition:</b> <a href="README-SSE_8txt_source.html#l00788">README-SSE.txt:788</a></div></div>
<div class="ttc" id="alib_2Target_2README_8txt_html_ac3ac4028df71f10fda029660ef66594d"><div class="ttname"><a href="lib_2Target_2README_8txt.html#ac3ac4028df71f10fda029660ef66594d">l</a></div><div class="ttdeci">This requires reassociating to forms of expressions that are already something that reassoc doesn t think about yet These two functions should generate the same code on big endian int * l</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2README_8txt_source.html#l00100">README.txt:100</a></div></div>
<div class="ttc" id="anamespacellvm_1_1SPII_html_a1c7202c6054fef862bbed45957747cdfa36b3dd3b84fde3f8494a9b18af131856"><div class="ttname"><a href="namespacellvm_1_1SPII.html#a1c7202c6054fef862bbed45957747cdfa36b3dd3b84fde3f8494a9b18af131856">llvm::SPII::Store</a></div><div class="ttdeci">@ Store</div><div class="ttdef"><b>Definition:</b> <a href="SparcInstrInfo_8h_source.html#l00033">SparcInstrInfo.h:33</a></div></div>
<div class="ttc" id="aREADME__P9_8txt_html_a7f504a2be3dc38b3fcad37684198cc08"><div class="ttname"><a href="README__P9_8txt.html#a7f504a2be3dc38b3fcad37684198cc08">at</a></div><div class="ttdeci">So we should use XX3Form_Rcr to implement intrinsic Convert DP outs ins xscvdpsp No builtin are required Round &amp;Convert QP DP(dword[1] is set to zero) No builtin are required Round to Quad Precision because you need to assign rounding mode in instruction Provide builtin(set f128:$vT,(int_ppc_vsx_xsrqpi f128:$vB))(set f128 yields&lt; n x&lt; ty &gt; &gt;&lt; result &gt; yields&lt; ty &gt;&lt; result &gt; No builtin are required Load Store load store see def memrix16 in PPCInstrInfo td Load Store Vector load store outs ins lxsdx set load store with conversion from to outs ins lxsspx set load store outs ins lxsiwzx set PPClfiwzx ins stxsiwx PPCstfiwx outs ins lxvd2x set int_ppc_vsx_lxvh8x int_ppc_vsx_lxvb16x ins stxvd2x store int_ppc_vsx_lxvl int_ppc_vsx_lxvll int_ppc_vsx_lxvwsx st[dw] at</div><div class="ttdef"><b>Definition:</b> <a href="README__P9_8txt_source.html#l00578">README_P9.txt:578</a></div></div>
<div class="ttc" id="aBuiltinGCs_8cpp_html_a7abf5fb4071cb25dbce06dfb5ee3c937"><div class="ttname"><a href="BuiltinGCs_8cpp.html#a7abf5fb4071cb25dbce06dfb5ee3c937">B</a></div><div class="ttdeci">static GCRegistry::Add&lt; OcamlGC &gt; B(&quot;ocaml&quot;, &quot;ocaml 3.10-compatible GC&quot;)</div></div>
<div class="ttc" id="aREADME__P9_8txt_html_a34c550a65909ded0eaa5d85dd3aae22e"><div class="ttname"><a href="README__P9_8txt.html#a34c550a65909ded0eaa5d85dd3aae22e">SDAG</a></div><div class="ttdeci">QP Compare Ordered outs ins xscmpudp No SDAG</div><div class="ttdef"><b>Definition:</b> <a href="README__P9_8txt_source.html#l00301">README_P9.txt:301</a></div></div>
<div class="ttc" id="aclassllvm_1_1Triple_html_a547abd13f7a3c063aa72c8192a868154aab15cb6de66f724829436a3466411993"><div class="ttname"><a href="classllvm_1_1Triple.html#a547abd13f7a3c063aa72c8192a868154aab15cb6de66f724829436a3466411993">llvm::Triple::ppc64</a></div><div class="ttdeci">@ ppc64</div><div class="ttdef"><b>Definition:</b> <a href="Triple_8h_source.html#l00071">Triple.h:71</a></div></div>
<div class="ttc" id="aREADME__ALTIVEC_8txt_html_afb4cf55ae120f4b16dd02d0967b40793"><div class="ttname"><a href="README__ALTIVEC_8txt.html#afb4cf55ae120f4b16dd02d0967b40793">lxvw4x</a></div><div class="ttdeci">Function&lt; 16 x i8 &gt; Produces the following code with LCPI0_0 toc ha LCPI0_1 toc ha LCPI0_0 toc l LCPI0_1 toc l lxvw4x</div><div class="ttdef"><b>Definition:</b> <a href="README__ALTIVEC_8txt_source.html#l00235">README_ALTIVEC.txt:235</a></div></div>
<div class="ttc" id="alib_2Target_2WebAssembly_2README_8txt_html_ad0f7d198414c3f3cf72769a0f58e5914"><div class="ttname"><a href="lib_2Target_2WebAssembly_2README_8txt.html#ad0f7d198414c3f3cf72769a0f58e5914">in</a></div><div class="ttdeci">The object format emitted by the WebAssembly backed is documented in</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2WebAssembly_2README_8txt_source.html#l00011">README.txt:11</a></div></div>
<div class="ttc" id="anamespacellvm_1_1ARMISD_html_a4097c262adca175c068cc59fa984dc38a7c288956c8c8e43434e6ae8633daab64"><div class="ttname"><a href="namespacellvm_1_1ARMISD.html#a4097c262adca175c068cc59fa984dc38a7c288956c8c8e43434e6ae8633daab64">llvm::ARMISD::VCMP</a></div><div class="ttdeci">@ VCMP</div><div class="ttdef"><b>Definition:</b> <a href="ARMISelLowering_8h_source.html#l00148">ARMISelLowering.h:148</a></div></div>
<div class="ttc" id="alib_2CodeGen_2README_8txt_html_aa0629dbc89f0868f62da8cbcb681b2be"><div class="ttname"><a href="lib_2CodeGen_2README_8txt.html#aa0629dbc89f0868f62da8cbcb681b2be">be</a></div><div class="ttdeci">Common register allocation spilling lr str ldr sxth r3 ldr mla r4 can be</div><div class="ttdef"><b>Definition:</b> <a href="lib_2CodeGen_2README_8txt_source.html#l00014">README.txt:14</a></div></div>
<div class="ttc" id="aREADME__P9_8txt_html_a5b94f63e2f11cabc289e77c95279e878"><div class="ttname"><a href="README__P9_8txt.html#a5b94f63e2f11cabc289e77c95279e878">vslv</a></div><div class="ttdeci">Vector Shift Left don t map to llvm shl and because they have different e g vslv</div><div class="ttdef"><b>Definition:</b> <a href="README__P9_8txt_source.html#l00128">README_P9.txt:128</a></div></div>
<div class="ttc" id="aREADME__P9_8txt_html_a4b5a9afc40c5688c4f6b970dfb77ed4c"><div class="ttname"><a href="README__P9_8txt.html#a4b5a9afc40c5688c4f6b970dfb77ed4c">PPCfmulrto</a></div><div class="ttdeci">Decimal Convert From to National Zoned Signed int_ppc_altivec_bcdcfno int_ppc_altivec_bcdcfzo int_ppc_altivec_bcdctno int_ppc_altivec_bcdctzo int_ppc_altivec_bcdcfsqo int_ppc_altivec_bcdctsqo int_ppc_altivec_bcdcpsgno int_ppc_altivec_bcdsetsgno int_ppc_altivec_bcdso int_ppc_altivec_bcduso int_ppc_altivec_bcdsro i e VA byte[7] Decimal(Unsigned) Truncate Define DAG Node in PPCInstrInfo def def PPCfmulrto</div><div class="ttdef"><b>Definition:</b> <a href="README__P9_8txt_source.html#l00206">README_P9.txt:206</a></div></div>
<div class="ttc" id="aREADME__P9_8txt_html_a11c3d45e0cf7e24e8c486c86ed26cf29"><div class="ttname"><a href="README__P9_8txt.html#a11c3d45e0cf7e24e8c486c86ed26cf29">vmul10uq</a></div><div class="ttdeci">Vector Multiply by Write Unsigned vmul10uq</div><div class="ttdef"><b>Definition:</b> <a href="README__P9_8txt_source.html#l00134">README_P9.txt:134</a></div></div>
<div class="ttc" id="aREADME__P9_8txt_html_af4c9f7a28b1a568be89deb1803ab18e3"><div class="ttname"><a href="README__P9_8txt.html#af4c9f7a28b1a568be89deb1803ab18e3">QWord</a></div><div class="ttdeci">Decimal Convert From to National Zoned Signed QWord</div><div class="ttdef"><b>Definition:</b> <a href="README__P9_8txt_source.html#l00146">README_P9.txt:146</a></div></div>
<div class="ttc" id="anamespacesaved_html"><div class="ttname"><a href="namespacesaved.html">saved</a></div></div>
<div class="ttc" id="aLint_8cpp_html_a7fb3c9caadeb0f7fe4828d380158d0f9"><div class="ttname"><a href="Lint_8cpp.html#a7fb3c9caadeb0f7fe4828d380158d0f9">IR</a></div><div class="ttdeci">Statically lint checks LLVM IR</div><div class="ttdef"><b>Definition:</b> <a href="Lint_8cpp_source.html#l00746">Lint.cpp:746</a></div></div>
<div class="ttc" id="alib_2Target_2SystemZ_2README_8txt_html_a839cdc0e6ffaecf33b5d7bfc83e2b7ec"><div class="ttname"><a href="lib_2Target_2SystemZ_2README_8txt.html#a839cdc0e6ffaecf33b5d7bfc83e2b7ec">input</a></div><div class="ttdeci">The initial backend is deliberately restricted to z10 We should add support for later architectures at some point If an asm ties an i32 r result to an i64 input</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2SystemZ_2README_8txt_source.html#l00010">README.txt:10</a></div></div>
<div class="ttc" id="alib_2Target_2ARM_2README_8txt_html_ae3e84a62e4ae19e7766bde30ee72c040"><div class="ttname"><a href="lib_2Target_2ARM_2README_8txt.html#ae3e84a62e4ae19e7766bde30ee72c040">c</a></div><div class="ttdeci">the resulting code requires compare and branches when and if the revised code is with conditional branches instead of More there is a byte word extend before each where there should be only and the condition codes are not remembered when the same two values are compared twice More LSR enhancements i8 and i32 load store addressing modes are identical int int c</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2ARM_2README_8txt_source.html#l00418">README.txt:418</a></div></div>
<div class="ttc" id="aRegionPrinter_8cpp_html_a5782a8740ff1e91516b41b3726a3168c"><div class="ttname"><a href="RegionPrinter_8cpp.html#a5782a8740ff1e91516b41b3726a3168c">only</a></div><div class="ttdeci">dot regions only</div><div class="ttdef"><b>Definition:</b> <a href="RegionPrinter_8cpp_source.html#l00194">RegionPrinter.cpp:194</a></div></div>
<div class="ttc" id="aREADME__P9_8txt_html_a226e2654e5716023e67e47269ad08991"><div class="ttname"><a href="README__P9_8txt.html#a226e2654e5716023e67e47269ad08991">SDTFPTernaryOp</a></div><div class="ttdeci">SDTFPTernaryOp</div><div class="ttdef"><b>Definition:</b> <a href="README__P9_8txt_source.html#l00250">README_P9.txt:250</a></div></div>
<div class="ttc" id="aErlangGCPrinter_8cpp_html_a74b474c0616ab55c1d9487f11fd31d26"><div class="ttname"><a href="ErlangGCPrinter_8cpp.html#a74b474c0616ab55c1d9487f11fd31d26">X</a></div><div class="ttdeci">static GCMetadataPrinterRegistry::Add&lt; ErlangGCPrinter &gt; X(&quot;erlang&quot;, &quot;erlang-compatible garbage collector&quot;)</div></div>
<div class="ttc" id="aREADME__P9_8txt_html_af300e351545b6c996502b698c19aa36c"><div class="ttname"><a href="README__P9_8txt.html#af300e351545b6c996502b698c19aa36c">PPCfdivrto</a></div><div class="ttdeci">Decimal Convert From to National Zoned Signed int_ppc_altivec_bcdcfno int_ppc_altivec_bcdcfzo int_ppc_altivec_bcdctno int_ppc_altivec_bcdctzo int_ppc_altivec_bcdcfsqo int_ppc_altivec_bcdctsqo int_ppc_altivec_bcdcpsgno int_ppc_altivec_bcdsetsgno int_ppc_altivec_bcdso int_ppc_altivec_bcduso int_ppc_altivec_bcdsro i e VA byte[7] Decimal(Unsigned) Truncate Define DAG Node in PPCInstrInfo def PPCfdivrto</div><div class="ttdef"><b>Definition:</b> <a href="README__P9_8txt_source.html#l00205">README_P9.txt:205</a></div></div>
<div class="ttc" id="alib_2Target_2SystemZ_2README_8txt_html_a8e96f00729aa3d4404fa4eff73925f9d"><div class="ttname"><a href="lib_2Target_2SystemZ_2README_8txt.html#a8e96f00729aa3d4404fa4eff73925f9d">too</a></div><div class="ttdeci">The initial backend is deliberately restricted to z10 We should add support for later architectures at some point If an asm ties an i32 r result to an i64 the input will be treated as an leaving the upper bits uninitialised For i64 store i32 i32 *dst ret void from CodeGen SystemZ asm ll will use LHI rather than LGHI to load This seems to be a general target independent problem The tuning of the choice between LOAD XC and CLC for constant length block operations We could extend them to variable length operations too</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2SystemZ_2README_8txt_source.html#l00040">README.txt:40</a></div></div>
<div class="ttc" id="alib_2CodeGen_2README_8txt_html_a09571efa45610bd20734656e6c524047"><div class="ttname"><a href="lib_2CodeGen_2README_8txt.html#a09571efa45610bd20734656e6c524047">will</a></div><div class="ttdeci">Common register allocation spilling lr str ldr sxth r3 ldr mla r4 can lr mov lr str ldr sxth r3 mla r4 and then merge mul and lr str ldr sxth r3 mla r4 It also increase the likelihood the store may become dead bb27 Successors according to LLVM ID Predecessors according to mbb&lt; bb27, 0x8b0a7c0 &gt; Note ADDri is not a two address instruction its result reg1037 is an operand of the PHI node in bb76 and its operand reg1039 is the result of the PHI node We should treat it as a two address code and make sure the ADDri is scheduled after any node that reads reg1039 Use info(i.e. register scavenger) to assign it a free register to allow reuse the collector could move the objects and invalidate the derived pointer This is bad enough in the first but safe points can crop up unpredictably **array_addr i32 n y store obj obj **nth_el If the i64 division is lowered to a then a safe point will(must) appear for the call site. If a collection occurs</div></div>
<div class="ttc" id="aREADME__P9_8txt_html_adf70e33b7cc54e3b63bffa8d6f5633a9"><div class="ttname"><a href="README__P9_8txt.html#adf70e33b7cc54e3b63bffa8d6f5633a9">f128</a></div><div class="ttdeci">fma f128</div><div class="ttdef"><b>Definition:</b> <a href="README__P9_8txt_source.html#l00226">README_P9.txt:226</a></div></div>
<div class="ttc" id="alib_2Target_2README_8txt_html_a50c8e2b4c2b4b443dd0149c808a1f812"><div class="ttname"><a href="lib_2Target_2README_8txt.html#a50c8e2b4c2b4b443dd0149c808a1f812">into</a></div><div class="ttdeci">Clang compiles this into</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2README_8txt_source.html#l00504">README.txt:504</a></div></div>
<div class="ttc" id="alib_2CodeGen_2README_8txt_html_a39b85bbe83e984ed97956f03d6c42501"><div class="ttname"><a href="lib_2CodeGen_2README_8txt.html#a39b85bbe83e984ed97956f03d6c42501">i32</a></div><div class="ttdeci">Common register allocation spilling lr str ldr sxth r3 ldr mla r4 can lr mov lr str ldr sxth r3 mla r4 and then merge mul and lr str ldr sxth r3 mla r4 It also increase the likelihood the store may become dead bb27 Successors according to LLVM ID Predecessors according to mbb&lt; bb27, 0x8b0a7c0 &gt; Note ADDri is not a two address instruction its result reg1037 is an operand of the PHI node in bb76 and its operand reg1039 is the result of the PHI node We should treat it as a two address code and make sure the ADDri is scheduled after any node that reads reg1039 Use info(i.e. register scavenger) to assign it a free register to allow reuse the collector could move the objects and invalidate the derived pointer This is bad enough in the first but safe points can crop up unpredictably **array_addr i32</div><div class="ttdef"><b>Definition:</b> <a href="lib_2CodeGen_2README_8txt_source.html#l00122">README.txt:122</a></div></div>
<div class="ttc" id="aREADME__ALTIVEC_8txt_html_a8c2af7080cfd4d8335edd785cd9cfe3f"><div class="ttname"><a href="README__ALTIVEC_8txt.html#a8c2af7080cfd4d8335edd785cd9cfe3f">bar</a></div><div class="ttdeci">Implement PPCInstrInfo::isLoadFromStackSlot isStoreToStackSlot for vector to generate better spill code The first should be a single lvx from the constant the second should be a xor bar(x)</div></div>
<div class="ttc" id="aREADME__P9_8txt_html_a75fc5865e1d50181d53a1f3eafef8fd8"><div class="ttname"><a href="README__P9_8txt.html#a75fc5865e1d50181d53a1f3eafef8fd8">int_ppc_altivec_vslv</a></div><div class="ttdeci">Vector Shift Left don t map to llvm shl and because they have different e g int_ppc_altivec_vslv</div><div class="ttdef"><b>Definition:</b> <a href="README__P9_8txt_source.html#l00128">README_P9.txt:128</a></div></div>
<div class="ttc" id="aREADME__P9_8txt_html_a8e8a352175ce0a8b2965dfd6fc9e7d30"><div class="ttname"><a href="README__P9_8txt.html#a8e8a352175ce0a8b2965dfd6fc9e7d30">vsrc</a></div><div class="ttdeci">So we should use XX3Form_Rcr to implement intrinsic Convert DP outs ins xscvdpsp No builtin are required Round &amp;Convert QP DP(dword[1] is set to zero) No builtin are required Round to Quad Precision because you need to assign rounding mode in instruction Provide builtin(set f128:$vT,(int_ppc_vsx_xsrqpi f128:$vB))(set f128 yields&lt; n x&lt; ty &gt; &gt;&lt; result &gt; yields&lt; ty &gt;&lt; result &gt; No builtin are required Load Store load store see def memrix16 in PPCInstrInfo td Load Store Vector load store outs ins lxsdx set load store with conversion from to outs ins lxsspx set load store outs ins lxsiwzx set PPClfiwzx ins stxsiwx PPCstfiwx outs vsrc</div><div class="ttdef"><b>Definition:</b> <a href="README__P9_8txt_source.html#l00545">README_P9.txt:545</a></div></div>
<div class="ttc" id="aclassllvm_1_1Triple_html_a547abd13f7a3c063aa72c8192a868154a4c6fec6469969e44d4af328ef7782c46"><div class="ttname"><a href="classllvm_1_1Triple.html#a547abd13f7a3c063aa72c8192a868154a4c6fec6469969e44d4af328ef7782c46">llvm::Triple::ppc64le</a></div><div class="ttdeci">@ ppc64le</div><div class="ttdef"><b>Definition:</b> <a href="Triple_8h_source.html#l00072">Triple.h:72</a></div></div>
<div class="ttc" id="alib_2Target_2SystemZ_2README_8txt_html_accaf4e23f4ffc792355e64dcb9af2c96"><div class="ttname"><a href="lib_2Target_2SystemZ_2README_8txt.html#accaf4e23f4ffc792355e64dcb9af2c96">val</a></div><div class="ttdeci">The initial backend is deliberately restricted to z10 We should add support for later architectures at some point If an asm ties an i32 r result to an i64 the input will be treated as an leaving the upper bits uninitialised For i64 store i32 val</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2SystemZ_2README_8txt_source.html#l00015">README.txt:15</a></div></div>
<div class="ttc" id="aREADME__ALTIVEC_8txt_html_a52d387873c0d733fc2f0b9de3730223d"><div class="ttname"><a href="README__ALTIVEC_8txt.html#a52d387873c0d733fc2f0b9de3730223d">needed</a></div><div class="ttdeci">We should do a little better with eliminating dead stores The stores to the stack are dead since a and b are not needed</div><div class="ttdef"><b>Definition:</b> <a href="README__ALTIVEC_8txt_source.html#l00212">README_ALTIVEC.txt:212</a></div></div>
<div class="ttc" id="aREADME-X86-64_8txt_html_aac3add0badd5c39bebc02df0b5d9bdcf"><div class="ttname"><a href="README-X86-64_8txt.html#aac3add0badd5c39bebc02df0b5d9bdcf">type</a></div><div class="ttdeci">AMD64 Optimization Manual has some nice information about optimizing integer multiplication by a constant How much of it applies to Intel s X86 implementation There are definite trade offs to xmm0 cvttss2siq rdx jb L3 subss xmm0 rax cvttss2siq rdx xorq rdx rax ret instead of xmm1 cvttss2siq rcx movaps xmm2 subss xmm2 cvttss2siq rax rdx xorq rax ucomiss xmm0 cmovb rax ret Seems like the jb branch has high likelihood of being taken It would have saved a few instructions It s not possible to reference and DH registers in an instruction requiring REX prefix divb and mulb both produce results in AH If isel emits a CopyFromReg which gets turned into a movb and that can be allocated a r8b r15b To get around isel emits a CopyFromReg from AX and then right shift it down by and truncate it It s not pretty but it works We need some register allocation magic to make the hack go which would often require a callee saved register Callees usually need to keep this value live for most of their body so it doesn t add a significant burden on them We currently implement this in however this is suboptimal because it means that it would be quite awkward to implement the optimization for callers A better implementation would be to relax the LLVM IR rules for sret arguments to allow a function with an sret argument to have a non void return type</div><div class="ttdef"><b>Definition:</b> <a href="README-X86-64_8txt_source.html#l00070">README-X86-64.txt:70</a></div></div>
<div class="ttc" id="aREADME__ALTIVEC_8txt_html_a00190a2376ab5d488a36c032bd242487"><div class="ttname"><a href="README__ALTIVEC_8txt.html#a00190a2376ab5d488a36c032bd242487">be</a></div><div class="ttdeci">entry mr r6 r2 blr CodeGen PowerPC vec_constants ll has an and operation that should be codegen d to andc The issue is that the all ones build vector is SelectNodeTo d a VSPLTISB instruction node before the and xor is selected which prevents the vnot pattern from matching An alternative to the store store load approach for illegal insert element lowering would be</div><div class="ttdef"><b>Definition:</b> <a href="README__ALTIVEC_8txt_source.html#l00181">README_ALTIVEC.txt:181</a></div></div>
<div class="ttc" id="aREADME__ALTIVEC_8txt_html_a98586ea01a32ff5046b0868b036a1849"><div class="ttname"><a href="README__ALTIVEC_8txt.html#a98586ea01a32ff5046b0868b036a1849">index</a></div><div class="ttdeci">splat index</div><div class="ttdef"><b>Definition:</b> <a href="README__ALTIVEC_8txt_source.html#l00181">README_ALTIVEC.txt:181</a></div></div>
<div class="ttc" id="alib_2Target_2README_8txt_html_a9026bda84f719fb903ddea83fc478a76"><div class="ttname"><a href="lib_2Target_2README_8txt.html#a9026bda84f719fb903ddea83fc478a76">following</a></div><div class="ttdeci">This is equivalent to the following</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2README_8txt_source.html#l00671">README.txt:671</a></div></div>
<div class="ttc" id="aBuiltinGCs_8cpp_html_a9bf617fd3367180fb96cebccfaae8dfa"><div class="ttname"><a href="BuiltinGCs_8cpp.html#a9bf617fd3367180fb96cebccfaae8dfa">D</a></div><div class="ttdeci">static GCRegistry::Add&lt; StatepointGC &gt; D(&quot;statepoint-example&quot;, &quot;an example strategy for statepoint&quot;)</div></div>
<div class="ttc" id="aCompiler_8h_html_adeb6f14d9f377993d79fae2efb34ecac"><div class="ttname"><a href="Compiler_8h.html#adeb6f14d9f377993d79fae2efb34ecac">LLVM_EXTERNAL_VISIBILITY</a></div><div class="ttdeci">#define LLVM_EXTERNAL_VISIBILITY</div><div class="ttdef"><b>Definition:</b> <a href="Compiler_8h_source.html#l00127">Compiler.h:127</a></div></div>
<div class="ttc" id="anamespacellvm_1_1LegalityPredicates_html_ad7ac7032baa62cc00002886633b9f281"><div class="ttname"><a href="namespacellvm_1_1LegalityPredicates.html#ad7ac7032baa62cc00002886633b9f281">llvm::LegalityPredicates::all</a></div><div class="ttdeci">Predicate all(Predicate P0, Predicate P1)</div><div class="ttdoc">True iff P0 and P1 are true.</div><div class="ttdef"><b>Definition:</b> <a href="LegalizerInfo_8h_source.html#l00228">LegalizerInfo.h:228</a></div></div>
<div class="ttc" id="anamespacellvm_1_1logicalview_html_ace26b39c8ec4392e05223c28d8572c4d"><div class="ttname"><a href="namespacellvm_1_1logicalview.html#ace26b39c8ec4392e05223c28d8572c4d">llvm::logicalview::patterns</a></div><div class="ttdeci">LVPatterns &amp; patterns()</div><div class="ttdef"><b>Definition:</b> <a href="LVOptions_8h_source.html#l00640">LVOptions.h:640</a></div></div>
<div class="ttc" id="anamespacellvm_1_1numbers_html_a92f4283d4e0e2ea1776894b3ae93640f"><div class="ttname"><a href="namespacellvm_1_1numbers.html#a92f4283d4e0e2ea1776894b3ae93640f">llvm::numbers::e</a></div><div class="ttdeci">constexpr double e</div><div class="ttdef"><b>Definition:</b> <a href="MathExtras_8h_source.html#l00031">MathExtras.h:31</a></div></div>
<div class="ttc" id="aREADME__P9_8txt_html_a2845cf258733b46d2494e7c5eda74c13"><div class="ttname"><a href="README__P9_8txt.html#a2845cf258733b46d2494e7c5eda74c13">SDTFPBinOp</a></div><div class="ttdeci">Decimal Convert From to National Zoned Signed int_ppc_altivec_bcdcfno int_ppc_altivec_bcdcfzo int_ppc_altivec_bcdctno int_ppc_altivec_bcdctzo int_ppc_altivec_bcdcfsqo int_ppc_altivec_bcdctsqo int_ppc_altivec_bcdcpsgno int_ppc_altivec_bcdsetsgno int_ppc_altivec_bcdso int_ppc_altivec_bcduso int_ppc_altivec_bcdsro i e VA byte[7] Decimal(Unsigned) Truncate Define DAG Node in PPCInstrInfo SDTFPBinOp</div><div class="ttdef"><b>Definition:</b> <a href="README__P9_8txt_source.html#l00205">README_P9.txt:205</a></div></div>
<div class="ttc" id="aREADME__P9_8txt_html_a31e9c2fec98b86a6f4e630d2d4c4eb6c"><div class="ttname"><a href="README__P9_8txt.html#a31e9c2fec98b86a6f4e630d2d4c4eb6c">semantics</a></div><div class="ttdeci">Vector Shift Left don t map to llvm shl and because they have different semantics</div><div class="ttdef"><b>Definition:</b> <a href="README__P9_8txt_source.html#l00119">README_P9.txt:119</a></div></div>
<div class="ttc" id="aMD5_8cpp_html_ac0eafdc9ee161b71e7af98af736952fd"><div class="ttname"><a href="MD5_8cpp.html#ac0eafdc9ee161b71e7af98af736952fd">I</a></div><div class="ttdeci">#define I(x, y, z)</div><div class="ttdef"><b>Definition:</b> <a href="MD5_8cpp_source.html#l00058">MD5.cpp:58</a></div></div>
<div class="ttc" id="aPowerPCTargetInfo_8h_html"><div class="ttname"><a href="PowerPCTargetInfo_8h.html">PowerPCTargetInfo.h</a></div></div>
<div class="ttc" id="aREADME__P9_8txt_html_a1f91a2069b22183cfbe4708b1592d788"><div class="ttname"><a href="README__P9_8txt.html#a1f91a2069b22183cfbe4708b1592d788">AltVSXFMARel</a></div><div class="ttdeci">fma AltVSXFMARel</div><div class="ttdef"><b>Definition:</b> <a href="README__P9_8txt_source.html#l00228">README_P9.txt:228</a></div></div>
<div class="ttc" id="aREADME__P9_8txt_html_ab9d04903540f7f864c0ff7fb429ebbd1"><div class="ttname"><a href="README__P9_8txt.html#ab9d04903540f7f864c0ff7fb429ebbd1">PPCfsubrto</a></div><div class="ttdeci">Decimal Convert From to National Zoned Signed int_ppc_altivec_bcdcfno int_ppc_altivec_bcdcfzo int_ppc_altivec_bcdctno int_ppc_altivec_bcdctzo int_ppc_altivec_bcdcfsqo int_ppc_altivec_bcdctsqo int_ppc_altivec_bcdcpsgno int_ppc_altivec_bcdsetsgno int_ppc_altivec_bcdso int_ppc_altivec_bcduso int_ppc_altivec_bcdsro i e VA byte[7] Decimal(Unsigned) Truncate Define DAG Node in PPCInstrInfo def def def PPCfsubrto</div><div class="ttdef"><b>Definition:</b> <a href="README__P9_8txt_source.html#l00207">README_P9.txt:207</a></div></div>
<div class="ttc" id="aREADME__P9_8txt_html_ad42d1e32234cdae6caf08e2f674ad874"><div class="ttname"><a href="README__P9_8txt.html#ad42d1e32234cdae6caf08e2f674ad874">instruction</a></div><div class="ttdeci">Decimal Convert From to National Zoned Signed int_ppc_altivec_bcdcfno int_ppc_altivec_bcdcfzo int_ppc_altivec_bcdctno int_ppc_altivec_bcdctzo int_ppc_altivec_bcdcfsqo int_ppc_altivec_bcdctsqo int_ppc_altivec_bcdcpsgno int_ppc_altivec_bcdsetsgno int_ppc_altivec_bcdso int_ppc_altivec_bcduso int_ppc_altivec_bcdsro i e VA byte[7] Decimal(Unsigned) Truncate Define DAG Node in PPCInstrInfo def def def def DAG patterns of each instruction(PPCInstrVSX.td)</div><div class="ttdef"><b>Definition:</b> <a href="README__P9_8txt_source.html#l00211">README_P9.txt:211</a></div></div>
<div class="ttc" id="alib_2Target_2X86_2README_8txt_html_ad6a9e04ace03e64069c0e3a87c529dcc"><div class="ttname"><a href="lib_2Target_2X86_2README_8txt.html#ad6a9e04ace03e64069c0e3a87c529dcc">load</a></div><div class="ttdeci">LLVM currently emits rax rax movq rax rax ret It could narrow the loads and stores to emit rax rax movq rax rax ret The trouble is that there is a TokenFactor between the store and the load</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2X86_2README_8txt_source.html#l01531">README.txt:1531</a></div></div>
<div class="ttc" id="aREADME__P9_8txt_html_a7866d0d19c437c9419ffb46f02b90338"><div class="ttname"><a href="README__P9_8txt.html#a7866d0d19c437c9419ffb46f02b90338">memrr</a></div><div class="ttdeci">So we should use XX3Form_Rcr to implement intrinsic Convert DP outs ins xscvdpsp No builtin are required Round &amp;Convert QP DP(dword[1] is set to zero) No builtin are required Round to Quad Precision because you need to assign rounding mode in instruction Provide builtin(set f128:$vT,(int_ppc_vsx_xsrqpi f128:$vB))(set f128 yields&lt; n x&lt; ty &gt; &gt;&lt; result &gt; yields&lt; ty &gt;&lt; result &gt; No builtin are required Load Store load store see def memrix16 in PPCInstrInfo td Load Store Vector load store outs ins memrr</div><div class="ttdef"><b>Definition:</b> <a href="README__P9_8txt_source.html#l00511">README_P9.txt:511</a></div></div>
<div class="ttc" id="anamespacellvm_html_a05f5b9a11bdcc5feba62899f95dcf878af6d9f1c7b49b7601fae6a545002a6763"><div class="ttname"><a href="namespacellvm.html#a05f5b9a11bdcc5feba62899f95dcf878af6d9f1c7b49b7601fae6a545002a6763">llvm::Length</a></div><div class="ttdeci">@ Length</div><div class="ttdef"><b>Definition:</b> <a href="DWP_8cpp_source.html#l00406">DWP.cpp:406</a></div></div>
<div class="ttc" id="alib_2Support_2Unix_2README_8txt_html_a636047a61c4f9dead2a05cbb3a588ecb"><div class="ttname"><a href="lib_2Support_2Unix_2README_8txt.html#a636047a61c4f9dead2a05cbb3a588ecb">example</a></div><div class="ttdeci">llvm lib Support Unix the directory structure underneath this directory could look like only those directories actually needing to be created should be created further subdirectories could be created to reflect versions of the various standards For example</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Support_2Unix_2README_8txt_source.html#l00015">README.txt:15</a></div></div>
<div class="ttc" id="alib_2Target_2ARM_2README_8txt_html_ab5ea3360d1fe424425a3cfafb89a0d92"><div class="ttname"><a href="lib_2Target_2ARM_2README_8txt.html#ab5ea3360d1fe424425a3cfafb89a0d92">register</a></div><div class="ttdeci">should just be implemented with a CLZ instruction Since there are other e that share this it would be best to implement this in a target independent as zero is the default value for the binary encoder e add r0 add r5 Register operands should be distinct That when the encoding does not require two syntactical operands to refer to the same register</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2ARM_2README_8txt_source.html#l00726">README.txt:726</a></div></div>
<div class="ttc" id="aREADME__P9_8txt_html_a1d04d700e108d69a07033ea9c7db8aee"><div class="ttname"><a href="README__P9_8txt.html#a1d04d700e108d69a07033ea9c7db8aee">SDTFPUnaryOp</a></div><div class="ttdeci">Decimal Convert From to National Zoned Signed int_ppc_altivec_bcdcfno int_ppc_altivec_bcdcfzo int_ppc_altivec_bcdctno int_ppc_altivec_bcdctzo int_ppc_altivec_bcdcfsqo int_ppc_altivec_bcdctsqo int_ppc_altivec_bcdcpsgno int_ppc_altivec_bcdsetsgno int_ppc_altivec_bcdso int_ppc_altivec_bcduso int_ppc_altivec_bcdsro i e VA byte[7] Decimal(Unsigned) Truncate Define DAG Node in PPCInstrInfo def def def def SDTFPUnaryOp</div><div class="ttdef"><b>Definition:</b> <a href="README__P9_8txt_source.html#l00209">README_P9.txt:209</a></div></div>
<div class="ttc" id="anamespacellvm_1_1EngineKind_html_aa969cf0aff34c1589ea13af3540b0414"><div class="ttname"><a href="namespacellvm_1_1EngineKind.html#aa969cf0aff34c1589ea13af3540b0414">llvm::EngineKind::Either</a></div><div class="ttdeci">const static Kind Either</div><div class="ttdef"><b>Definition:</b> <a href="ExecutionEngine_2ExecutionEngine_8h_source.html#l00527">ExecutionEngine.h:527</a></div></div>
<div class="ttc" id="aREADME__P9_8txt_html_a9ecb9af97ff8ecc76733f61d3946a8ba"><div class="ttname"><a href="README__P9_8txt.html#a9ecb9af97ff8ecc76733f61d3946a8ba">v4i32</a></div><div class="ttdeci">Vector Rotate Left Mask Mask v4i32</div><div class="ttdef"><b>Definition:</b> <a href="README__P9_8txt_source.html#l00112">README_P9.txt:112</a></div></div>
<div class="ttc" id="anamespacellvm_1_1irsymtab_1_1storage_html_ab6fecef32f1aaa3296558242fb0223df"><div class="ttname"><a href="namespacellvm_1_1irsymtab_1_1storage.html#ab6fecef32f1aaa3296558242fb0223df">llvm::irsymtab::storage::Word</a></div><div class="ttdeci">support::ulittle32_t Word</div><div class="ttdef"><b>Definition:</b> <a href="IRSymtab_8h_source.html#l00052">IRSymtab.h:52</a></div></div>
<div class="ttc" id="aREADME__P9_8txt_html_a42a82adf8d40243d6a0a28972c9f7df1"><div class="ttname"><a href="README__P9_8txt.html#a42a82adf8d40243d6a0a28972c9f7df1">Compare</a></div><div class="ttdeci">QP Compare Ordered outs ins xscmpudp No builtin are required Or llvm fcmp order unorder compare DP QP Compare builtin are required DP Compare</div><div class="ttdef"><b>Definition:</b> <a href="README__P9_8txt_source.html#l00309">README_P9.txt:309</a></div></div>
<div class="ttc" id="aREADME__P9_8txt_html_a4113b06725d3d6ebc94b9620858935a6"><div class="ttname"><a href="README__P9_8txt.html#a4113b06725d3d6ebc94b9620858935a6">DP</a></div><div class="ttdeci">So we should use XX3Form_Rcr to implement intrinsic Convert DP outs ins xscvdpsp No builtin are required Round &amp;Convert QP DP(dword[1] is set to zero) No builtin are required Round to Quad Precision because you need to assign rounding mode in instruction Provide builtin(set f128:$vT,(int_ppc_vsx_xsrqpi f128:$vB))(set f128 yields&lt; n x&lt; ty &gt; &gt;&lt; result &gt; yields&lt; ty &gt;&lt; result &gt; No builtin are required Load Store load store see def memrix16 in PPCInstrInfo td Load Store Vector load store outs ins lxsdx set load store with conversion from to DP</div><div class="ttdef"><b>Definition:</b> <a href="README__P9_8txt_source.html#l00520">README_P9.txt:520</a></div></div>
<div class="ttc" id="aclassllvm_1_1Triple_html_a547abd13f7a3c063aa72c8192a868154a440d963f2b5dc6b1268643771492a905"><div class="ttname"><a href="classllvm_1_1Triple.html#a547abd13f7a3c063aa72c8192a868154a440d963f2b5dc6b1268643771492a905">llvm::Triple::ppcle</a></div><div class="ttdeci">@ ppcle</div><div class="ttdef"><b>Definition:</b> <a href="Triple_8h_source.html#l00070">Triple.h:70</a></div></div>
<div class="ttc" id="anamespacellvm_1_1binaryformat_html_ab355a2b14b4cc35373b4526fbfab894da80eaeeee65cce2c1b9fa9a5741956f9a"><div class="ttname"><a href="namespacellvm_1_1binaryformat.html#ab355a2b14b4cc35373b4526fbfab894da80eaeeee65cce2c1b9fa9a5741956f9a">llvm::binaryformat::unknown</a></div><div class="ttdeci">@ unknown</div><div class="ttdef"><b>Definition:</b> <a href="Swift_8h_source.html#l00018">Swift.h:18</a></div></div>
<div class="ttc" id="aREADME__ALTIVEC_8txt_html_a3b54c55bd8a7121b30fc06cc567afcf0"><div class="ttname"><a href="README__ALTIVEC_8txt.html#a3b54c55bd8a7121b30fc06cc567afcf0">instruction</a></div><div class="ttdeci">Since we know that Vector is byte aligned and we know the element offset of we should change the load into a lve *x instruction</div><div class="ttdef"><b>Definition:</b> <a href="README__ALTIVEC_8txt_source.html#l00037">README_ALTIVEC.txt:37</a></div></div>
<div class="ttc" id="aNVPTXISelLowering_8cpp_html_ae1a90b5d85643644483b2ca70da4d13fac837bff23a12c3735d463020f37979de"><div class="ttname"><a href="NVPTXISelLowering_8cpp.html#ae1a90b5d85643644483b2ca70da4d13fac837bff23a12c3735d463020f37979de">Unsigned</a></div><div class="ttdeci">@ Unsigned</div><div class="ttdef"><b>Definition:</b> <a href="NVPTXISelLowering_8cpp_source.html#l04885">NVPTXISelLowering.cpp:4885</a></div></div>
<div class="ttc" id="aclassNode_html"><div class="ttname"><a href="classNode.html">Node</a></div><div class="ttdef"><b>Definition:</b> <a href="ItaniumDemangle_8h_source.html#l00156">ItaniumDemangle.h:156</a></div></div>
<div class="ttc" id="alib_2Target_2X86_2README_8txt_html_a35b4e9931514f0279aa86d42fbf42ccb"><div class="ttname"><a href="lib_2Target_2X86_2README_8txt.html#a35b4e9931514f0279aa86d42fbf42ccb">xor</a></div><div class="ttdeci">We currently generate a but we really shouldn eax ecx xorl edx divl ecx eax divl ecx movl eax ret A similar code sequence works for division We currently compile i32 v2 eax eax jo LBB1_2 xor</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2X86_2README_8txt_source.html#l01271">README.txt:1271</a></div></div>
<div class="ttc" id="alib_2Target_2README_8txt_html_a7df6ed7588301267782c2bd4b7f6899d"><div class="ttname"><a href="lib_2Target_2README_8txt.html#a7df6ed7588301267782c2bd4b7f6899d">for</a></div><div class="ttdeci">this could be done in SelectionDAGISel along with other special for</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2README_8txt_source.html#l00104">README.txt:104</a></div></div>
<div class="ttc" id="aREADME__P9_8txt_html_a50f687cffa9395388d87d3f54d6f4e8d"><div class="ttname"><a href="README__P9_8txt.html#a50f687cffa9395388d87d3f54d6f4e8d">v1i128</a></div><div class="ttdeci">Vector Multiply by Write Unsigned v1i128</div><div class="ttdef"><b>Definition:</b> <a href="README__P9_8txt_source.html#l00134">README_P9.txt:134</a></div></div>
<div class="ttc" id="alib_2Target_2ARM_2README_8txt_html_a46e498e9b70d8cac397bcbb09510c615"><div class="ttname"><a href="lib_2Target_2ARM_2README_8txt.html#a46e498e9b70d8cac397bcbb09510c615">not</a></div><div class="ttdeci">Should compile r2 movcc movcs str strb mov lr r1 movcs movcc mov lr not</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2ARM_2README_8txt_source.html#l00465">README.txt:465</a></div></div>
<div class="ttc" id="aREADME__P9_8txt_html_aab49517344b0aff93ffa9061a9956fe0"><div class="ttname"><a href="README__P9_8txt.html#aab49517344b0aff93ffa9061a9956fe0">instructions</a></div><div class="ttdeci">It looks like we only need to define PPCfmarto for these instructions</div><div class="ttdef"><b>Definition:</b> <a href="README__P9_8txt_source.html#l00250">README_P9.txt:250</a></div></div>
<div class="ttc" id="anamespacellvm_1_1PPCISD_html_ad1c32e5bb1cb213fb836bc3d221e4f19a9f74f2eb04440389d18aabcff035a19f"><div class="ttname"><a href="namespacellvm_1_1PPCISD.html#ad1c32e5bb1cb213fb836bc3d221e4f19a9f74f2eb04440389d18aabcff035a19f">llvm::PPCISD::LXVD2X</a></div><div class="ttdeci">@ LXVD2X</div><div class="ttdoc">VSRC, CHAIN = LXVD2X_LE CHAIN, Ptr - Occurs only for little endian.</div><div class="ttdef"><b>Definition:</b> <a href="PPCISelLowering_8h_source.html#l00551">PPCISelLowering.h:551</a></div></div>
<div class="ttc" id="aREADME__P9_8txt_html_a48a66d2f34e46f271843b6cfe41bef0a"><div class="ttname"><a href="README__P9_8txt.html#a48a66d2f34e46f271843b6cfe41bef0a">$src</a></div><div class="ttdeci">So we should use XX3Form_Rcr to implement intrinsic Convert DP outs ins xscvdpsp No builtin are required Round &amp;Convert QP DP(dword[1] is set to zero) No builtin are required Round to Quad Precision because you need to assign rounding mode in instruction Provide builtin(set f128:$vT,(int_ppc_vsx_xsrqpi f128:$vB))(set f128 yields&lt; n x&lt; ty &gt; &gt;&lt; result &gt; yields&lt; ty &gt;&lt; result &gt; No builtin are required Load Store load store see def memrix16 in PPCInstrInfo td Load Store Vector load store outs ins lxsdx $src</div><div class="ttdef"><b>Definition:</b> <a href="README__P9_8txt_source.html#l00512">README_P9.txt:512</a></div></div>
<div class="ttc" id="aREADME__P9_8txt_html_ae44837fbcf9aa54aaa8c86ac48466f5c"><div class="ttname"><a href="README__P9_8txt.html#ae44837fbcf9aa54aaa8c86ac48466f5c">vmul10euq</a></div><div class="ttdeci">Vector Multiply by Extended Write Unsigned vmul10euq</div><div class="ttdef"><b>Definition:</b> <a href="README__P9_8txt_source.html#l00140">README_P9.txt:140</a></div></div>
<div class="ttc" id="anamespacellvm_html_a9e1d3cdb4ff5a68e526fe202ddeee9cb"><div class="ttname"><a href="namespacellvm.html#a9e1d3cdb4ff5a68e526fe202ddeee9cb">llvm::getThePPC64Target</a></div><div class="ttdeci">Target &amp; getThePPC64Target()</div><div class="ttdef"><b>Definition:</b> <a href="PowerPCTargetInfo_8cpp_source.html#l00021">PowerPCTargetInfo.cpp:21</a></div></div>
<div class="ttc" id="alib_2Target_2README_8txt_html_a3a76669632041022e6976766a22bd2b0"><div class="ttname"><a href="lib_2Target_2README_8txt.html#a3a76669632041022e6976766a22bd2b0">j</a></div><div class="ttdeci">return j(j&lt;&lt; 16)</div></div>
<div class="ttc" id="aREADME__ALTIVEC_8txt_html_a5e70c5a0f6b50b949dd82e048d2993a7"><div class="ttname"><a href="README__ALTIVEC_8txt.html#a5e70c5a0f6b50b949dd82e048d2993a7">foo</a></div><div class="ttdeci">void foo(void)</div><div class="ttdef"><b>Definition:</b> <a href="README__ALTIVEC_8txt_source.html#l00017">README_ALTIVEC.txt:17</a></div></div>
<div class="ttc" id="anamespacestd_html"><div class="ttname"><a href="namespacestd.html">std</a></div><div class="ttdef"><b>Definition:</b> <a href="BitVector_8h_source.html#l00851">BitVector.h:851</a></div></div>
<div class="ttc" id="aMD5_8cpp_html_ae42219072d798876e6b08e6b78614ff6"><div class="ttname"><a href="MD5_8cpp.html#ae42219072d798876e6b08e6b78614ff6">H</a></div><div class="ttdeci">#define H(x, y, z)</div><div class="ttdef"><b>Definition:</b> <a href="MD5_8cpp_source.html#l00057">MD5.cpp:57</a></div></div>
<div class="ttc" id="alib_2Target_2ARM_2README_8txt_html_a3a82232c420700208dd1b19e316558d8"><div class="ttname"><a href="lib_2Target_2ARM_2README_8txt.html#a3a82232c420700208dd1b19e316558d8">bit</a></div><div class="ttdeci">compiles ldr LCPI1_0 ldr ldr mov lsr tst moveq r1 ldr LCPI1_1 and r0 bx lr It would be better to do something like to fold the shift into the conditional ldr LCPI1_0 ldr ldr tst movne lsr ldr LCPI1_1 and r0 bx lr it saves an instruction and a register It might be profitable to cse MOVi16 if there are lots of bit immediates with the same bottom half Robert Muth started working on an alternate jump table implementation that does not put the tables in line in the text This is more like the llvm default jump table implementation This might be useful sometime Several revisions of patches are on the mailing beginning while CMP sets them like a subtract Therefore to be able to use CMN for comparisons other than the Z bit</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2ARM_2README_8txt_source.html#l00584">README.txt:584</a></div></div>
<div class="ttc" id="aREADME-Thumb_8txt_html_a5d98a8b5139e56ebf0d2ff4cbaa0dc5e"><div class="ttname"><a href="README-Thumb_8txt.html#a5d98a8b5139e56ebf0d2ff4cbaa0dc5e">code</a></div><div class="ttdeci">*Add support for compiling functions in both ARM and Thumb then taking the smallest *Add support for compiling individual basic blocks in thumb when in a larger ARM function This can be used for presumed cold code</div><div class="ttdef"><b>Definition:</b> <a href="README-Thumb_8txt_source.html#l00009">README-Thumb.txt:9</a></div></div>
<div class="ttc" id="alib_2Target_2README_8txt_html_a468c151b353d817979d3225dc1d7658b"><div class="ttname"><a href="lib_2Target_2README_8txt.html#a468c151b353d817979d3225dc1d7658b">rotate</a></div><div class="ttdeci">The same transformation can work with an even modulo with the addition of a rotate</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2README_8txt_source.html#l00680">README.txt:680</a></div></div>
<div class="ttc" id="alib_2Target_2README_8txt_html_af9f7a898c4a757821053e38056d9383f"><div class="ttname"><a href="lib_2Target_2README_8txt.html#af9f7a898c4a757821053e38056d9383f">or</a></div><div class="ttdeci">compiles or</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2README_8txt_source.html#l00606">README.txt:606</a></div></div>
<div class="ttc" id="aREADME__ALTIVEC_8txt_html_a9356d20a911928e53c37f717cbd9e08e"><div class="ttname"><a href="README__ALTIVEC_8txt.html#a9356d20a911928e53c37f717cbd9e08e">x</a></div><div class="ttdeci">vcmpeq to generate a select mask lvsl slot x</div><div class="ttdef"><b>Definition:</b> <a href="README__ALTIVEC_8txt_source.html#l00182">README_ALTIVEC.txt:182</a></div></div>
<div class="ttc" id="aREADME__ALTIVEC_8txt_html_af3b7cce4bb5f8d59a674047d1f9689b2"><div class="ttname"><a href="README__ALTIVEC_8txt.html#af3b7cce4bb5f8d59a674047d1f9689b2">addi</a></div><div class="ttdeci">Function&lt; 16 x i8 &gt; Produces the following code with LCPI0_0 toc ha LCPI0_1 toc ha addi</div><div class="ttdef"><b>Definition:</b> <a href="README__ALTIVEC_8txt_source.html#l00233">README_ALTIVEC.txt:233</a></div></div>
<div class="ttc" id="aREADME__ALTIVEC_8txt_html_a95dde4245e3a0d25dc3f5849bef6bf30"><div class="ttname"><a href="README__ALTIVEC_8txt.html#a95dde4245e3a0d25dc3f5849bef6bf30">examples</a></div><div class="ttdeci">vperm to rotate result into correct slot vsel result together Should codegen branches on vec_any vec_all to avoid mfcr Two examples</div><div class="ttdef"><b>Definition:</b> <a href="README__ALTIVEC_8txt_source.html#l00190">README_ALTIVEC.txt:190</a></div></div>
<div class="ttc" id="anamespacellvm_1_1support_html_a2560071a977efb94947d664e396f7206aa2d63b0536e1684292bd8bbbe49a6099"><div class="ttname"><a href="namespacellvm_1_1support.html#a2560071a977efb94947d664e396f7206aa2d63b0536e1684292bd8bbbe49a6099">llvm::support::aligned</a></div><div class="ttdeci">@ aligned</div><div class="ttdef"><b>Definition:</b> <a href="Endian_8h_source.html#l00030">Endian.h:30</a></div></div>
<div class="ttc" id="aREADME__P9_8txt_html_a9d6773eae9257f7e16bc4ec4d4240cdd"><div class="ttname"><a href="README__P9_8txt.html#a9d6773eae9257f7e16bc4ec4d4240cdd">xoaddr</a></div><div class="ttdeci">So we should use XX3Form_Rcr to implement intrinsic Convert DP outs ins xscvdpsp No builtin are required Round &amp;Convert QP DP(dword[1] is set to zero) No builtin are required Round to Quad Precision because you need to assign rounding mode in instruction Provide builtin(set f128:$vT,(int_ppc_vsx_xsrqpi f128:$vB))(set f128 yields&lt; n x&lt; ty &gt; &gt;&lt; result &gt; yields&lt; ty &gt;&lt; result &gt; No builtin are required Load Store load store see def memrix16 in PPCInstrInfo td Load Store Vector load xoaddr</div><div class="ttdef"><b>Definition:</b> <a href="README__P9_8txt_source.html#l00506">README_P9.txt:506</a></div></div>
<div class="ttc" id="aREADME-SSE_8txt_html_aa909e47be20d3c871de457c29a9d8e66"><div class="ttname"><a href="README-SSE_8txt.html#aa909e47be20d3c871de457c29a9d8e66">better</a></div><div class="ttdeci">In x86 we generate this spiffy xmm0 xmm0 ret in x86 we generate this which could be better</div><div class="ttdef"><b>Definition:</b> <a href="README-SSE_8txt_source.html#l00537">README-SSE.txt:537</a></div></div>
<div class="ttc" id="astructllvm_1_1RegisterTarget_html"><div class="ttname"><a href="structllvm_1_1RegisterTarget.html">llvm::RegisterTarget</a></div><div class="ttdoc">RegisterTarget - Helper template for registering a target, for use in the target's initialization fun...</div><div class="ttdef"><b>Definition:</b> <a href="TargetRegistry_8h_source.html#l01136">TargetRegistry.h:1136</a></div></div>
<div class="ttc" id="aREADME__P9_8txt_html_a68a2756bb5b4a8b6e6dc4720628b46c6"><div class="ttname"><a href="README__P9_8txt.html#a68a2756bb5b4a8b6e6dc4720628b46c6">$XA</a></div><div class="ttdeci">QP Compare Ordered outs ins xscmpudp $XA</div><div class="ttdef"><b>Definition:</b> <a href="README__P9_8txt_source.html#l00301">README_P9.txt:301</a></div></div>
<div class="ttc" id="anamespacellvm_1_1ARCCC_html_a9a81d9a1b379cf08150b22e81d7dd006aceb189306b941666e679bf556207c1e4"><div class="ttname"><a href="namespacellvm_1_1ARCCC.html#a9a81d9a1b379cf08150b22e81d7dd006aceb189306b941666e679bf556207c1e4">llvm::ARCCC::Z</a></div><div class="ttdeci">@ Z</div><div class="ttdef"><b>Definition:</b> <a href="ARCInfo_8h_source.html#l00041">ARCInfo.h:41</a></div></div>
<div class="ttc" id="aPowerPCTargetInfo_8cpp_html_a5a55d83958fff6797dcc5c5325734fdb"><div class="ttname"><a href="PowerPCTargetInfo_8cpp.html#a5a55d83958fff6797dcc5c5325734fdb">LLVMInitializePowerPCTargetInfo</a></div><div class="ttdeci">LLVM_EXTERNAL_VISIBILITY void LLVMInitializePowerPCTargetInfo()</div><div class="ttdef"><b>Definition:</b> <a href="PowerPCTargetInfo_8cpp_source.html#l00030">PowerPCTargetInfo.cpp:30</a></div></div>
<div class="ttc" id="alib_2Target_2PowerPC_2README_8txt_html_aab7aca753744e96d2cd66778e7d86741"><div class="ttname"><a href="lib_2Target_2PowerPC_2README_8txt.html#aab7aca753744e96d2cd66778e7d86741">blr</a></div><div class="ttdeci">cond_true lis lo16() lo16() lo16() f1 fsel f3 blr</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2PowerPC_2README_8txt_source.html#l00108">README.txt:108</a></div></div>
<div class="ttc" id="aTargetLibraryInfo_8cpp_html_aca185e6d0e9f423dbb24440206454872a0e0d4848f799861d016ae63c8fdc41e3"><div class="ttname"><a href="TargetLibraryInfo_8cpp.html#aca185e6d0e9f423dbb24440206454872a0e0d4848f799861d016ae63c8fdc41e3">Same</a></div><div class="ttdeci">@ Same</div><div class="ttdef"><b>Definition:</b> <a href="TargetLibraryInfo_8cpp_source.html#l00065">TargetLibraryInfo.cpp:65</a></div></div>
<div class="ttc" id="anamespacellvm_1_1MCID_html_ab357441fcd1ea1f9b0d27c12700f6023a2b016c207343046b2bac45e69e76dcec"><div class="ttname"><a href="namespacellvm_1_1MCID.html#ab357441fcd1ea1f9b0d27c12700f6023a2b016c207343046b2bac45e69e76dcec">llvm::MCID::Add</a></div><div class="ttdeci">@ Add</div><div class="ttdef"><b>Definition:</b> <a href="MCInstrDesc_8h_source.html#l00186">MCInstrDesc.h:186</a></div></div>
<div class="ttc" id="anamespacellvm_1_1tgtok_html_abbc5259d649363016626e2529fabe0c5ada3eb06ada644390db065d37b3fd87ac"><div class="ttname"><a href="namespacellvm_1_1tgtok.html#abbc5259d649363016626e2529fabe0c5ada3eb06ada644390db065d37b3fd87ac">llvm::tgtok::Class</a></div><div class="ttdeci">@ Class</div><div class="ttdef"><b>Definition:</b> <a href="TGLexer_8h_source.html#l00050">TGLexer.h:50</a></div></div>
<div class="ttc" id="anamespacellvm_html_abf184ce24b39916585fc680cc607020e"><div class="ttname"><a href="namespacellvm.html#abf184ce24b39916585fc680cc607020e">llvm::getThePPC32LETarget</a></div><div class="ttdeci">Target &amp; getThePPC32LETarget()</div><div class="ttdef"><b>Definition:</b> <a href="PowerPCTargetInfo_8cpp_source.html#l00017">PowerPCTargetInfo.cpp:17</a></div></div>
<div class="ttc" id="alib_2Target_2ARM_2README_8txt_html_a0923c429b0c515f4ace7a106c97935d4"><div class="ttname"><a href="lib_2Target_2ARM_2README_8txt.html#a0923c429b0c515f4ace7a106c97935d4">This</a></div><div class="ttdeci">the resulting code requires compare and branches when and if the revised code is with conditional branches instead of More there is a byte word extend before each where there should be only and the condition codes are not remembered when the same two values are compared twice More LSR enhancements i8 and i32 load store addressing modes are identical This</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2ARM_2README_8txt_source.html#l00418">README.txt:418</a></div></div>
<div class="ttc" id="aREADME__P9_8txt_html_ae3391a46ddeb2f64675c86a74b4f4cdc"><div class="ttname"><a href="README__P9_8txt.html#ae3391a46ddeb2f64675c86a74b4f4cdc">iaddrX4</a></div><div class="ttdeci">So we should use XX3Form_Rcr to implement intrinsic Convert DP outs ins xscvdpsp No builtin are required Round &amp;Convert QP DP(dword[1] is set to zero) No builtin are required Round to Quad Precision because you need to assign rounding mode in instruction Provide builtin(set f128:$vT,(int_ppc_vsx_xsrqpi f128:$vB))(set f128 yields&lt; n x&lt; ty &gt; &gt;&lt; result &gt; yields&lt; ty &gt;&lt; result &gt; No builtin are required Load Store load store see def memrix16 in PPCInstrInfo td Load Store Vector load store outs ins lxsdx set load iaddrX4</div><div class="ttdef"><b>Definition:</b> <a href="README__P9_8txt_source.html#l00516">README_P9.txt:516</a></div></div>
<div class="ttc" id="aREADME-SSE_8txt_html_aae2d2977835e891eef9c1569d44462d7"><div class="ttname"><a href="README-SSE_8txt.html#aae2d2977835e891eef9c1569d44462d7">used</a></div><div class="ttdeci">This might compile to this xmm1 xorps xmm0 movss xmm0 ret Now consider if the code caused xmm1 to get spilled This might produce this xmm1 movaps xmm0 movaps xmm1 movss xmm0 ret since the reload is only used by these we could fold it into the producing something like xmm1 movaps xmm0 ret saving two instructions The basic idea is that a reload from a spill if only one byte chunk is used</div><div class="ttdef"><b>Definition:</b> <a href="README-SSE_8txt_source.html#l00270">README-SSE.txt:270</a></div></div>
<div class="ttc" id="aREADME__P9_8txt_html_abf26d251b827a20effd3a6686f384c36"><div class="ttname"><a href="README__P9_8txt.html#abf26d251b827a20effd3a6686f384c36">IIC_LdStSTFD</a></div><div class="ttdeci">So we should use XX3Form_Rcr to implement intrinsic Convert DP outs ins xscvdpsp No builtin are required Round &amp;Convert QP DP(dword[1] is set to zero) No builtin are required Round to Quad Precision because you need to assign rounding mode in instruction Provide builtin(set f128:$vT,(int_ppc_vsx_xsrqpi f128:$vB))(set f128 yields&lt; n x&lt; ty &gt; &gt;&lt; result &gt; yields&lt; ty &gt;&lt; result &gt; No builtin are required Load Store load store see def memrix16 in PPCInstrInfo td Load Store Vector load store outs ins lxsdx set load store with conversion from to outs ins lxsspx set load store outs ins lxsiwzx set PPClfiwzx ins stxsiwx IIC_LdStSTFD</div><div class="ttdef"><b>Definition:</b> <a href="README__P9_8txt_source.html#l00538">README_P9.txt:538</a></div></div>
<div class="ttc" id="aregcomp_8c_html_a0240ac851181b84ac374872dc5434ee4"><div class="ttname"><a href="regcomp_8c.html#a0240ac851181b84ac374872dc5434ee4">N</a></div><div class="ttdeci">#define N</div></div>
<div class="ttc" id="alib_2Target_2ARM_2README_8txt_html_ad34c196412ad9a6a78795035f587fa26"><div class="ttname"><a href="lib_2Target_2ARM_2README_8txt.html#ad34c196412ad9a6a78795035f587fa26">support</a></div><div class="ttdeci">Reimplement select in terms of SEL *We would really like to support but we need to prove that the add doesn t need to overflow between the two bit chunks *Implement pre post increment support(e.g. PR935) *Implement smarter const ant generation for binops with large immediates. A few ARMv6T2 ops should be pattern matched</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2ARM_2README_8txt_source.html#l00010">README.txt:10</a></div></div>
<div class="ttc" id="alib_2Target_2ARM_2README_8txt_html_a99d4c77c6a5298070bb9e4e4904d9dfe"><div class="ttname"><a href="lib_2Target_2ARM_2README_8txt.html#a99d4c77c6a5298070bb9e4e4904d9dfe">generate</a></div><div class="ttdeci">We currently generate</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2ARM_2README_8txt_source.html#l00597">README.txt:597</a></div></div>
<div class="ttc" id="aRelocation_8txt_html_ad0265f082d0dc86496888b7cec1b717d"><div class="ttname"><a href="Relocation_8txt.html#ad0265f082d0dc86496888b7cec1b717d">LLVM</a></div><div class="ttdeci">MIPS Relocation Principles In LLVM</div><div class="ttdef"><b>Definition:</b> <a href="Relocation_8txt_source.html#l00003">Relocation.txt:3</a></div></div>
<div class="ttc" id="alib_2Target_2ARM_2README_8txt_html_ac3302d36e5507ecfe3ed8ba03d5e320c"><div class="ttname"><a href="lib_2Target_2ARM_2README_8txt.html#ac3302d36e5507ecfe3ed8ba03d5e320c">stack</a></div><div class="ttdeci">S is passed via registers r2 But gcc stores them to the stack</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2ARM_2README_8txt_source.html#l00189">README.txt:189</a></div></div>
<div class="ttc" id="aREADME__P9_8txt_html_a6d771591dfd20b3ee4a1230ea6d128af"><div class="ttname"><a href="README__P9_8txt.html#a6d771591dfd20b3ee4a1230ea6d128af">IIC_LdStLFD</a></div><div class="ttdeci">So we should use XX3Form_Rcr to implement intrinsic Convert DP outs ins xscvdpsp No builtin are required Round &amp;Convert QP DP(dword[1] is set to zero) No builtin are required Round to Quad Precision because you need to assign rounding mode in instruction Provide builtin(set f128:$vT,(int_ppc_vsx_xsrqpi f128:$vB))(set f128 yields&lt; n x&lt; ty &gt; &gt;&lt; result &gt; yields&lt; ty &gt;&lt; result &gt; No builtin are required Load Store load store see def memrix16 in PPCInstrInfo td Load Store Vector load store outs ins lxsdx IIC_LdStLFD</div><div class="ttdef"><b>Definition:</b> <a href="README__P9_8txt_source.html#l00512">README_P9.txt:512</a></div></div>
<div class="ttc" id="aREADME__P9_8txt_html_a2dc4a9ab85bc06625fe4cbbd55cd3d4d"><div class="ttname"><a href="README__P9_8txt.html#a2dc4a9ab85bc06625fe4cbbd55cd3d4d">ix16addr</a></div><div class="ttdeci">So we should use XX3Form_Rcr to implement intrinsic Convert DP outs ins xscvdpsp No builtin are required Round &amp;Convert QP DP(dword[1] is set to zero) No builtin are required Round to Quad Precision because you need to assign rounding mode in instruction Provide builtin(set f128:$vT,(int_ppc_vsx_xsrqpi f128:$vB))(set f128 yields&lt; n x&lt; ty &gt; &gt;&lt; result &gt; yields&lt; ty &gt;&lt; result &gt; No builtin are required Load Store load ix16addr</div><div class="ttdef"><b>Definition:</b> <a href="README__P9_8txt_source.html#l00498">README_P9.txt:498</a></div></div>
<div class="ttc" id="aAMDGPUPrintfRuntimeBinding_8cpp_html_a69bb70228d1f1da94577e5ddcaa20a29"><div class="ttname"><a href="AMDGPUPrintfRuntimeBinding_8cpp.html#a69bb70228d1f1da94577e5ddcaa20a29">lowering</a></div><div class="ttdeci">amdgpu printf runtime AMDGPU Printf lowering</div><div class="ttdef"><b>Definition:</b> <a href="AMDGPUPrintfRuntimeBinding_8cpp_source.html#l00090">AMDGPUPrintfRuntimeBinding.cpp:90</a></div></div>
<div class="ttc" id="anamespacellvm_1_1msgpack_html_afdae9da66bac09f4b2bfc0fd9f0559e6"><div class="ttname"><a href="namespacellvm_1_1msgpack.html#afdae9da66bac09f4b2bfc0fd9f0559e6">llvm::msgpack::Type</a></div><div class="ttdeci">Type</div><div class="ttdoc">MessagePack types as defined in the standard, with the exception of Integer being divided into a sign...</div><div class="ttdef"><b>Definition:</b> <a href="MsgPackReader_8h_source.html#l00048">MsgPackReader.h:48</a></div></div>
<div class="ttc" id="anamespacellvm_1_1HexStyle_html_a2ff7bb0072f1202f7b06bb426d6ecda0aee14e37b71e28e68ace5e2f6b67042a9"><div class="ttname"><a href="namespacellvm_1_1HexStyle.html#a2ff7bb0072f1202f7b06bb426d6ecda0aee14e37b71e28e68ace5e2f6b67042a9">llvm::HexStyle::Asm</a></div><div class="ttdeci">@ Asm</div><div class="ttdoc">0ffh</div><div class="ttdef"><b>Definition:</b> <a href="MCInstPrinter_8h_source.html#l00035">MCInstPrinter.h:35</a></div></div>
<div class="ttc" id="aREADME__P9_8txt_html_ad5e11843dcaf1f81c644a197d728156c"><div class="ttname"><a href="README__P9_8txt.html#ad5e11843dcaf1f81c644a197d728156c">RegConstraint&lt;&quot;$vTi = $vT&quot;&gt;</a></div><div class="ttdeci">fma RegConstraint&lt;&quot;$vTi = $vT&quot;&gt;</div><div class="ttdef"><b>Definition:</b> <a href="README__P9_8txt_source.html#l00227">README_P9.txt:227</a></div></div>
<div class="ttc" id="aREADME__ALTIVEC_8txt_html_aea01f986952eecf8b93f9125a25a7a05"><div class="ttname"><a href="README__ALTIVEC_8txt.html#aea01f986952eecf8b93f9125a25a7a05">stxvw4x</a></div><div class="ttdeci">Function&lt; 16 x i8 &gt; Produces the following code with LCPI0_0 toc ha LCPI0_1 toc ha LCPI0_0 toc l LCPI0_1 toc l stxvw4x</div><div class="ttdef"><b>Definition:</b> <a href="README__ALTIVEC_8txt_source.html#l00238">README_ALTIVEC.txt:238</a></div></div>
<div class="ttc" id="aREADME__P9_8txt_html_a247d3ad1997a244277c2c5cc702e16cc"><div class="ttname"><a href="README__P9_8txt.html#a247d3ad1997a244277c2c5cc702e16cc">v2f64</a></div><div class="ttdeci">QP Compare Ordered outs ins xscmpudp No builtin are required Or llvm fcmp order unorder compare DP QP Compare builtin are required DP xscmp *dp write to VSX register Use int_ppc_vsx_xscmpeqdp int_ppc_vsx_xscmpgedp int_ppc_vsx_xscmpgtdp int_ppc_vsx_xscmpnedp v2f64</div><div class="ttdef"><b>Definition:</b> <a href="README__P9_8txt_source.html#l00323">README_P9.txt:323</a></div></div>
<div class="ttc" id="aREADME__P9_8txt_html_a1b56d5b4596bd6686daf0127df8471dc"><div class="ttname"><a href="README__P9_8txt.html#a1b56d5b4596bd6686daf0127df8471dc">$XT</a></div><div class="ttdeci">QP Compare Ordered outs ins xscmpudp No builtin are required Or llvm fcmp order unorder compare DP QP Compare builtin are required DP xscmp *dp write to VSX register Use int_ppc_vsx_xscmpeqdp int_ppc_vsx_xscmpgedp int_ppc_vsx_xscmpgtdp int_ppc_vsx_xscmpnedp $XT</div><div class="ttdef"><b>Definition:</b> <a href="README__P9_8txt_source.html#l00322">README_P9.txt:322</a></div></div>
<div class="ttc" id="alib_2Target_2X86_2README_8txt_html_a96ccf5cfb52d627161ce94e8098cb91a"><div class="ttname"><a href="lib_2Target_2X86_2README_8txt.html#a96ccf5cfb52d627161ce94e8098cb91a">nounwind</a></div><div class="ttdeci">this lets us change the cmpl into a which is and eliminate the shift We compile this i32 i32 i8 zeroext d nounwind</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2X86_2README_8txt_source.html#l00973">README.txt:973</a></div></div>
<div class="ttc" id="aBlockVerifier_8cpp_html_ae45c7d73c0ff5d177b59153ffae77f84"><div class="ttname"><a href="BlockVerifier_8cpp.html#ae45c7d73c0ff5d177b59153ffae77f84">From</a></div><div class="ttdeci">BlockVerifier::State From</div><div class="ttdef"><b>Definition:</b> <a href="BlockVerifier_8cpp_source.html#l00055">BlockVerifier.cpp:55</a></div></div>
<div class="ttc" id="aREADME__P9_8txt_html_a1339768ca51595b3ebf5c0e69b80c9e8"><div class="ttname"><a href="README__P9_8txt.html#a1339768ca51595b3ebf5c0e69b80c9e8">lshr</a></div><div class="ttdeci">Vector Shift Left don t map to llvm shl and lshr</div><div class="ttdef"><b>Definition:</b> <a href="README__P9_8txt_source.html#l00118">README_P9.txt:118</a></div></div>
<div class="ttc" id="aREADME-SSE_8txt_html_a7246178f42b1eaef4e9bba10a9f39323"><div class="ttname"><a href="README-SSE_8txt.html#a7246178f42b1eaef4e9bba10a9f39323">spill</a></div><div class="ttdeci">the custom lowered code happens to be but we shouldn t have to custom lower anything This is probably related to&lt; 2 x i64 &gt; ops being so bad LLVM currently generates stack realignment when it is not necessary needed The problem is that we need to know about stack alignment too before RA runs At that point we don t whether there will be vector spill</div><div class="ttdef"><b>Definition:</b> <a href="README-SSE_8txt_source.html#l00489">README-SSE.txt:489</a></div></div>
<div class="ttc" id="aREADME__ALTIVEC_8txt_html_aeaae92a77e80128e1fa09600c8258a74"><div class="ttname"><a href="README__ALTIVEC_8txt.html#aeaae92a77e80128e1fa09600c8258a74">ori</a></div><div class="ttdeci">Function&lt; 16 x i8 &gt; Produces the following code with LCPI0_0 toc ha LCPI0_1 toc ha LCPI0_0 toc l LCPI0_1 toc l ori</div><div class="ttdef"><b>Definition:</b> <a href="README__ALTIVEC_8txt_source.html#l00239">README_ALTIVEC.txt:239</a></div></div>
<div class="ttc" id="anamespaceshuffles_html_a6abf8a645bd24dfb42085db9672ac39a"><div class="ttname"><a href="namespaceshuffles.html#a6abf8a645bd24dfb42085db9672ac39a">shuffles::mask</a></div><div class="ttdeci">auto mask(ShuffFunc S, unsigned Length, OptArgs... args) -&gt; MaskT</div><div class="ttdef"><b>Definition:</b> <a href="HexagonISelDAGToDAGHVX_8cpp_source.html#l00903">HexagonISelDAGToDAGHVX.cpp:903</a></div></div>
<div class="ttc" id="aREADME__P9_8txt_html_afdb2c86c54a7de682961e9b0a42a080d"><div class="ttname"><a href="README__P9_8txt.html#afdb2c86c54a7de682961e9b0a42a080d">f64</a></div><div class="ttdeci">QP Compare Ordered outs ins xscmpudp No builtin are required Or llvm fcmp order unorder compare DP QP Compare builtin are required DP xscmp *dp write to VSX register Use int_ppc_vsx_xscmpeqdp f64</div><div class="ttdef"><b>Definition:</b> <a href="README__P9_8txt_source.html#l00314">README_P9.txt:314</a></div></div>
<div class="ttc" id="alib_2Target_2ARM_2README_8txt_html_a901ce7389ca67dd79b8ab5b53c4a7da8"><div class="ttname"><a href="lib_2Target_2ARM_2README_8txt.html#a901ce7389ca67dd79b8ab5b53c4a7da8">d</a></div><div class="ttdeci">the resulting code requires compare and branches when and if the revised code is with conditional branches instead of More there is a byte word extend before each where there should be only and the condition codes are not remembered when the same two values are compared twice More LSR enhancements i8 and i32 load store addressing modes are identical int int int d</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2ARM_2README_8txt_source.html#l00418">README.txt:418</a></div></div>
<div class="ttc" id="aREADME__ALTIVEC_8txt_html_ac2bca51fd633d11e41373896183538f6"><div class="ttname"><a href="README__ALTIVEC_8txt.html#ac2bca51fd633d11e41373896183538f6">registers</a></div><div class="ttdeci">Implement PPCInstrInfo::isLoadFromStackSlot isStoreToStackSlot for vector registers</div><div class="ttdef"><b>Definition:</b> <a href="README__ALTIVEC_8txt_source.html#l00004">README_ALTIVEC.txt:4</a></div></div>
<div class="ttc" id="aModuloSchedule_8cpp_html_a106e32122c569cdb42ddf61ecbb0aad1"><div class="ttname"><a href="ModuloSchedule_8cpp.html#a106e32122c569cdb42ddf61ecbb0aad1">test</a></div><div class="ttdeci">modulo schedule test</div><div class="ttdef"><b>Definition:</b> <a href="ModuloSchedule_8cpp_source.html#l02143">ModuloSchedule.cpp:2143</a></div></div>
<div class="ttc" id="aARCBranchFinalize_8cpp_html_a14311558a7445776def2d5bc13161ba3"><div class="ttname"><a href="ARCBranchFinalize_8cpp.html#a14311558a7445776def2d5bc13161ba3">branches</a></div><div class="ttdeci">arc branch ARC finalize branches</div><div class="ttdef"><b>Definition:</b> <a href="ARCBranchFinalize_8cpp_source.html#l00066">ARCBranchFinalize.cpp:66</a></div></div>
<div class="ttc" id="aTargetRegistry_8h_html"><div class="ttname"><a href="TargetRegistry_8h.html">TargetRegistry.h</a></div></div>
<div class="ttc" id="anamespacellvm_1_1RegState_html_aef4cc0c855dc833e2a9d58a50703320da72c17e2ff2d5af62a30e56ac152aa8d5"><div class="ttname"><a href="namespacellvm_1_1RegState.html#aef4cc0c855dc833e2a9d58a50703320da72c17e2ff2d5af62a30e56ac152aa8d5">llvm::RegState::Define</a></div><div class="ttdeci">@ Define</div><div class="ttdoc">Register definition.</div><div class="ttdef"><b>Definition:</b> <a href="MachineInstrBuilder_8h_source.html#l00044">MachineInstrBuilder.h:44</a></div></div>
<div class="ttc" id="aREADME__P9_8txt_html_a0b2a8fd73722063e86d9f2771b964fe6"><div class="ttname"><a href="README__P9_8txt.html#a0b2a8fd73722063e86d9f2771b964fe6">Indexed</a></div><div class="ttdeci">So we should use XX3Form_Rcr to implement intrinsic Convert DP outs ins xscvdpsp No builtin are required Round &amp;Convert QP DP(dword[1] is set to zero) No builtin are required Round to Quad Precision because you need to assign rounding mode in instruction Provide builtin(set f128:$vT,(int_ppc_vsx_xsrqpi f128:$vB))(set f128 yields&lt; n x&lt; ty &gt; &gt;&lt; result &gt; yields&lt; ty &gt;&lt; result &gt; No builtin are required Load Store load store see def memrix16 in PPCInstrInfo td Load Store Vector Indexed</div><div class="ttdef"><b>Definition:</b> <a href="README__P9_8txt_source.html#l00505">README_P9.txt:505</a></div></div>
<div class="ttc" id="aREADME__P9_8txt_html_af7618b37d3bd1fe61c87480f31a79b03"><div class="ttname"><a href="README__P9_8txt.html#af7618b37d3bd1fe61c87480f31a79b03">$dst</a></div><div class="ttdeci">So we should use XX3Form_Rcr to implement intrinsic Convert DP outs ins xscvdpsp No builtin are required Round &amp;Convert QP DP(dword[1] is set to zero) No builtin are required Round to Quad Precision because you need to assign rounding mode in instruction Provide builtin(set f128:$vT,(int_ppc_vsx_xsrqpi f128:$vB))(set f128 yields&lt; n x&lt; ty &gt; &gt;&lt; result &gt; yields&lt; ty &gt;&lt; result &gt; No builtin are required Load Store load store see def memrix16 in PPCInstrInfo td Load Store Vector load store outs ins lxsdx set load store with conversion from to outs ins lxsspx set load store outs ins lxsiwzx set PPClfiwzx ins stxsiwx $dst</div><div class="ttdef"><b>Definition:</b> <a href="README__P9_8txt_source.html#l00538">README_P9.txt:538</a></div></div>
<div class="ttc" id="aMustExecute_8cpp_html_ac00fd2bd5d2febf1f9988294a6c56b33"><div class="ttname"><a href="MustExecute_8cpp.html#ac00fd2bd5d2febf1f9988294a6c56b33">entry</a></div><div class="ttdeci">print Instructions which execute on loop entry</div><div class="ttdef"><b>Definition:</b> <a href="MustExecute_8cpp_source.html#l00346">MustExecute.cpp:346</a></div></div>
<div class="ttc" id="aREADME__ALTIVEC_8txt_html_a59455f0652696cfe74b45034c1432df9"><div class="ttname"><a href="README__ALTIVEC_8txt.html#a59455f0652696cfe74b45034c1432df9">stvx</a></div><div class="ttdeci">Implement PPCInstrInfo::isLoadFromStackSlot isStoreToStackSlot for vector to generate better spill code The first should be a single lvx from the constant the second should be a xor stvx</div><div class="ttdef"><b>Definition:</b> <a href="README__ALTIVEC_8txt_source.html#l00012">README_ALTIVEC.txt:12</a></div></div>
<div class="ttc" id="anamespacellvm_1_1codeview_html_adfebd8c4ae29ccd84c600c1e65d6b807a86408593c34af77fdd90df932f8b5261"><div class="ttname"><a href="namespacellvm_1_1codeview.html#adfebd8c4ae29ccd84c600c1e65d6b807a86408593c34af77fdd90df932f8b5261">llvm::codeview::PublicSymFlags::Function</a></div><div class="ttdeci">@ Function</div></div>
<div class="ttc" id="alib_2Target_2README_8txt_html_ace6b37d5eaf50e6fd3465513bc022e93"><div class="ttname"><a href="lib_2Target_2README_8txt.html#ace6b37d5eaf50e6fd3465513bc022e93">of</a></div><div class="ttdeci">Add support for conditional and other related patterns Instead of</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Target_2README_8txt_source.html#l00134">README.txt:134</a></div></div>
<div class="ttc" id="anamespacellvm_1_1irsymtab_html_a8af0e7caf92ff2e049dc40eceafc15be"><div class="ttname"><a href="namespacellvm_1_1irsymtab.html#a8af0e7caf92ff2e049dc40eceafc15be">llvm::irsymtab::build</a></div><div class="ttdeci">Error build(ArrayRef&lt; Module * &gt; Mods, SmallVector&lt; char, 0 &gt; &amp;Symtab, StringTableBuilder &amp;StrtabBuilder, BumpPtrAllocator &amp;Alloc)</div><div class="ttdoc">Fills in Symtab and StrtabBuilder with a valid symbol and string table for Mods.</div><div class="ttdef"><b>Definition:</b> <a href="IRSymtab_8cpp_source.html#l00365">IRSymtab.cpp:365</a></div></div>
<div class="ttc" id="anamespacellvm_html_a40d02b699f329a22af7ee94757772da6"><div class="ttname"><a href="namespacellvm.html#a40d02b699f329a22af7ee94757772da6">llvm::getThePPC32Target</a></div><div class="ttdeci">Target &amp; getThePPC32Target()</div><div class="ttdef"><b>Definition:</b> <a href="PowerPCTargetInfo_8cpp_source.html#l00013">PowerPCTargetInfo.cpp:13</a></div></div>
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Aug 7 2023 10:16:41 for LLVM by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
