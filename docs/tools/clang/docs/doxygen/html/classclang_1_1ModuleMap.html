<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>clang: clang::ModuleMap Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">clang
   &#160;<span id="projectnumber">17.0.0git</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceclang.html">clang</a></li><li class="navelem"><a class="el" href="classclang_1_1ModuleMap.html">ModuleMap</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classclang_1_1ModuleMap-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">clang::ModuleMap Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &quot;<a class="el" href="ModuleMap_8h_source.html">clang/Lex/ModuleMap.h</a>&quot;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1ModuleMap_1_1KnownHeader.html">KnownHeader</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A header that is known to reside within a given module, whether it was included or excluded.  <a href="classclang_1_1ModuleMap_1_1KnownHeader.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:ac7a2413d4d0a8f29d2dad359bcfd8dec"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1ModuleMap.html#ac7a2413d4d0a8f29d2dad359bcfd8dec">ModuleHeaderRole</a> { <a class="el" href="classclang_1_1ModuleMap.html#ac7a2413d4d0a8f29d2dad359bcfd8deca50b6dee47a2d5b1f50f46dc46e4c96aa">NormalHeader</a> = 0x0, 
<a class="el" href="classclang_1_1ModuleMap.html#ac7a2413d4d0a8f29d2dad359bcfd8deca0500e1f1c1ee8f9e6c76c993aa48b0d4">PrivateHeader</a> = 0x1, 
<a class="el" href="classclang_1_1ModuleMap.html#ac7a2413d4d0a8f29d2dad359bcfd8decad7e8857e09c5d0fbe70ad90e0e584200">TextualHeader</a> = 0x2, 
<a class="el" href="classclang_1_1ModuleMap.html#ac7a2413d4d0a8f29d2dad359bcfd8deca29ca8d089c3fd646d54e611219d0d877">ExcludedHeader</a> = 0x4
 }</td></tr>
<tr class="memdesc:ac7a2413d4d0a8f29d2dad359bcfd8dec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flags describing the role of a module header.  <a href="classclang_1_1ModuleMap.html#ac7a2413d4d0a8f29d2dad359bcfd8dec">More...</a><br /></td></tr>
<tr class="separator:ac7a2413d4d0a8f29d2dad359bcfd8dec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac22c56a8f11f61caa8ab58809a21cca3"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1ModuleMap.html#ac22c56a8f11f61caa8ab58809a21cca3">AdditionalModMapsSet</a> = <a class="el" href="classllvm_1_1SmallPtrSet.html">llvm::SmallPtrSet</a>&lt; const <a class="el" href="classclang_1_1FileEntry.html">FileEntry</a> *, 1 &gt;</td></tr>
<tr class="separator:ac22c56a8f11f61caa8ab58809a21cca3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b352087754574155a198a4cb0d6e197"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1ModuleMap.html#a1b352087754574155a198a4cb0d6e197">module_iterator</a> = llvm::StringMap&lt; <a class="el" href="classclang_1_1Module.html">Module</a> * &gt;::const_iterator</td></tr>
<tr class="separator:a1b352087754574155a198a4cb0d6e197"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ac588ee8d4c631303982ed1c68002f49d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1ModuleMap.html#ac588ee8d4c631303982ed1c68002f49d">resolveLinkAsDependencies</a> (<a class="el" href="classclang_1_1Module.html">Module</a> *Mod)</td></tr>
<tr class="memdesc:ac588ee8d4c631303982ed1c68002f49d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use PendingLinkAsModule information to mark top level link names that are going to be replaced by export_as aliases.  <a href="classclang_1_1ModuleMap.html#ac588ee8d4c631303982ed1c68002f49d">More...</a><br /></td></tr>
<tr class="separator:ac588ee8d4c631303982ed1c68002f49d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06068cd4735154ef4218ab96f9462412"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1ModuleMap.html#a06068cd4735154ef4218ab96f9462412">addLinkAsDependency</a> (<a class="el" href="classclang_1_1Module.html">Module</a> *Mod)</td></tr>
<tr class="memdesc:a06068cd4735154ef4218ab96f9462412"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make module to use export_as as the link dependency name if enough information is available or add it to a pending list otherwise.  <a href="classclang_1_1ModuleMap.html#a06068cd4735154ef4218ab96f9462412">More...</a><br /></td></tr>
<tr class="separator:a06068cd4735154ef4218ab96f9462412"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a767bb9d1787801348282cf9b588df471"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1ModuleMap.html#a767bb9d1787801348282cf9b588df471">ModuleMap</a> (<a class="el" href="classclang_1_1SourceManager.html">SourceManager</a> &amp;SourceMgr, <a class="el" href="classclang_1_1DiagnosticsEngine.html">DiagnosticsEngine</a> &amp;Diags, const <a class="el" href="classclang_1_1LangOptions.html">LangOptions</a> &amp;LangOpts, const <a class="el" href="classclang_1_1TargetInfo.html">TargetInfo</a> *Target, <a class="el" href="classclang_1_1HeaderSearch.html">HeaderSearch</a> &amp;HeaderInfo)</td></tr>
<tr class="memdesc:a767bb9d1787801348282cf9b588df471"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a new module map.  <a href="classclang_1_1ModuleMap.html#a767bb9d1787801348282cf9b588df471">More...</a><br /></td></tr>
<tr class="separator:a767bb9d1787801348282cf9b588df471"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8769cd7eba3cb7f8f1cd2dde890603d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1ModuleMap.html#ab8769cd7eba3cb7f8f1cd2dde890603d">~ModuleMap</a> ()</td></tr>
<tr class="memdesc:ab8769cd7eba3cb7f8f1cd2dde890603d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy the module map.  <a href="classclang_1_1ModuleMap.html#ab8769cd7eba3cb7f8f1cd2dde890603d">More...</a><br /></td></tr>
<tr class="separator:ab8769cd7eba3cb7f8f1cd2dde890603d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc441df169e00dbd5ab3a5db003d454f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1ModuleMap.html#abc441df169e00dbd5ab3a5db003d454f">setTarget</a> (const <a class="el" href="classclang_1_1TargetInfo.html">TargetInfo</a> &amp;Target)</td></tr>
<tr class="memdesc:abc441df169e00dbd5ab3a5db003d454f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the target information.  <a href="classclang_1_1ModuleMap.html#abc441df169e00dbd5ab3a5db003d454f">More...</a><br /></td></tr>
<tr class="separator:abc441df169e00dbd5ab3a5db003d454f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c624a7392febb43c7bb1a19e835ab34"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1ModuleMap.html#a6c624a7392febb43c7bb1a19e835ab34">setBuiltinIncludeDir</a> (const <a class="el" href="classclang_1_1DirectoryEntry.html">DirectoryEntry</a> *Dir)</td></tr>
<tr class="memdesc:a6c624a7392febb43c7bb1a19e835ab34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the directory that contains Clang-supplied include files, such as our <a class="el" href="stdarg_8h.html">stdarg.h</a> or <a class="el" href="tgmath_8h.html">tgmath.h</a>.  <a href="classclang_1_1ModuleMap.html#a6c624a7392febb43c7bb1a19e835ab34">More...</a><br /></td></tr>
<tr class="separator:a6c624a7392febb43c7bb1a19e835ab34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c4a9836fc4829507cded4d63e24f6fc"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classclang_1_1DirectoryEntry.html">DirectoryEntry</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1ModuleMap.html#a1c4a9836fc4829507cded4d63e24f6fc">getBuiltinDir</a> () const</td></tr>
<tr class="memdesc:a1c4a9836fc4829507cded4d63e24f6fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the directory that contains Clang-supplied include files.  <a href="classclang_1_1ModuleMap.html#a1c4a9836fc4829507cded4d63e24f6fc">More...</a><br /></td></tr>
<tr class="separator:a1c4a9836fc4829507cded4d63e24f6fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e8ca3bc91f0e93e6c706b80f263e521"><td class="memItemLeft" align="right" valign="top"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1ModuleMap.html#a1e8ca3bc91f0e93e6c706b80f263e521">isBuiltinHeader</a> (const <a class="el" href="classclang_1_1FileEntry.html">FileEntry</a> *File)</td></tr>
<tr class="separator:a1e8ca3bc91f0e93e6c706b80f263e521"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a516ba163200648ee309a8b16ccc0d62a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1ModuleMap.html#a516ba163200648ee309a8b16ccc0d62a">addModuleMapCallbacks</a> (std::unique_ptr&lt; <a class="el" href="classclang_1_1ModuleMapCallbacks.html">ModuleMapCallbacks</a> &gt; Callback)</td></tr>
<tr class="memdesc:a516ba163200648ee309a8b16ccc0d62a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a module map callback.  <a href="classclang_1_1ModuleMap.html#a516ba163200648ee309a8b16ccc0d62a">More...</a><br /></td></tr>
<tr class="separator:a516ba163200648ee309a8b16ccc0d62a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0f3adfd4ab31073e14c5f2d79398ad5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classclang_1_1ModuleMap_1_1KnownHeader.html">KnownHeader</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1ModuleMap.html#ac0f3adfd4ab31073e14c5f2d79398ad5">findModuleForHeader</a> (const <a class="el" href="classclang_1_1FileEntry.html">FileEntry</a> *File, <a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a> AllowTextual=<a class="el" href="stdbool_8h.html#a65e9886d74aaee76545e83dd09011727">false</a>, <a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a> AllowExcluded=<a class="el" href="stdbool_8h.html#a65e9886d74aaee76545e83dd09011727">false</a>)</td></tr>
<tr class="memdesc:ac0f3adfd4ab31073e14c5f2d79398ad5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the module that owns the given header file, if any.  <a href="classclang_1_1ModuleMap.html#ac0f3adfd4ab31073e14c5f2d79398ad5">More...</a><br /></td></tr>
<tr class="separator:ac0f3adfd4ab31073e14c5f2d79398ad5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94cf9768b587f077bf7916c10754713a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classclang_1_1ModuleMap_1_1KnownHeader.html">KnownHeader</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1ModuleMap.html#a94cf9768b587f077bf7916c10754713a">findAllModulesForHeader</a> (const <a class="el" href="classclang_1_1FileEntry.html">FileEntry</a> *File)</td></tr>
<tr class="memdesc:a94cf9768b587f077bf7916c10754713a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve all the modules that contain the given header file.  <a href="classclang_1_1ModuleMap.html#a94cf9768b587f077bf7916c10754713a">More...</a><br /></td></tr>
<tr class="separator:a94cf9768b587f077bf7916c10754713a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7569af5b4b731de5a135caf8636681b3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classclang_1_1ModuleMap_1_1KnownHeader.html">KnownHeader</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1ModuleMap.html#a7569af5b4b731de5a135caf8636681b3">findResolvedModulesForHeader</a> (const <a class="el" href="classclang_1_1FileEntry.html">FileEntry</a> *File) const</td></tr>
<tr class="memdesc:a7569af5b4b731de5a135caf8636681b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Like <a class="el" href="classclang_1_1ModuleMap.html#a94cf9768b587f077bf7916c10754713a">findAllModulesForHeader</a>, but do not attempt to infer module ownership from umbrella headers if we've not already done so.  <a href="classclang_1_1ModuleMap.html#a7569af5b4b731de5a135caf8636681b3">More...</a><br /></td></tr>
<tr class="separator:a7569af5b4b731de5a135caf8636681b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64ce2c7a23bcff10e7ae4bfcda637182"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1ModuleMap.html#a64ce2c7a23bcff10e7ae4bfcda637182">resolveHeaderDirectives</a> (const <a class="el" href="classclang_1_1FileEntry.html">FileEntry</a> *File) const</td></tr>
<tr class="memdesc:a64ce2c7a23bcff10e7ae4bfcda637182"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resolve all lazy header directives for the specified file.  <a href="classclang_1_1ModuleMap.html#a64ce2c7a23bcff10e7ae4bfcda637182">More...</a><br /></td></tr>
<tr class="separator:a64ce2c7a23bcff10e7ae4bfcda637182"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41dcd87105f5059bc55a3f3db230e9bb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1ModuleMap.html#a41dcd87105f5059bc55a3f3db230e9bb">resolveHeaderDirectives</a> (<a class="el" href="classclang_1_1Module.html">Module</a> *Mod, std::optional&lt; const <a class="el" href="classclang_1_1FileEntry.html">FileEntry</a> * &gt; File) const</td></tr>
<tr class="memdesc:a41dcd87105f5059bc55a3f3db230e9bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resolve lazy header directives for the specified module.  <a href="classclang_1_1ModuleMap.html#a41dcd87105f5059bc55a3f3db230e9bb">More...</a><br /></td></tr>
<tr class="separator:a41dcd87105f5059bc55a3f3db230e9bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22cfc8d05dbf3c2cceb132f4c789b8d1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1ModuleMap.html#a22cfc8d05dbf3c2cceb132f4c789b8d1">diagnoseHeaderInclusion</a> (<a class="el" href="classclang_1_1Module.html">Module</a> *RequestingModule, <a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a> RequestingModuleIsModuleInterface, <a class="el" href="classclang_1_1SourceLocation.html">SourceLocation</a> FilenameLoc, StringRef <a class="el" href="ClangSrcLocDump_8cpp.html#a637a6651de5d8f7041e8e604929b1e94">Filename</a>, <a class="el" href="classclang_1_1FileEntryRef.html">FileEntryRef</a> File)</td></tr>
<tr class="memdesc:a22cfc8d05dbf3c2cceb132f4c789b8d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reports errors if a module must not include a specific file.  <a href="classclang_1_1ModuleMap.html#a22cfc8d05dbf3c2cceb132f4c789b8d1">More...</a><br /></td></tr>
<tr class="separator:a22cfc8d05dbf3c2cceb132f4c789b8d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc11dbc10f0658870b83753074c3c1d9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1ModuleMap.html#afc11dbc10f0658870b83753074c3c1d9">isHeaderInUnavailableModule</a> (const <a class="el" href="classclang_1_1FileEntry.html">FileEntry</a> *Header) const</td></tr>
<tr class="memdesc:afc11dbc10f0658870b83753074c3c1d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine whether the given header is part of a module marked 'unavailable'.  <a href="classclang_1_1ModuleMap.html#afc11dbc10f0658870b83753074c3c1d9">More...</a><br /></td></tr>
<tr class="separator:afc11dbc10f0658870b83753074c3c1d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a890ef9bee13458036c9e4d5d7df58c8f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1ModuleMap.html#a890ef9bee13458036c9e4d5d7df58c8f">isHeaderUnavailableInModule</a> (const <a class="el" href="classclang_1_1FileEntry.html">FileEntry</a> *Header, const <a class="el" href="classclang_1_1Module.html">Module</a> *RequestingModule) const</td></tr>
<tr class="memdesc:a890ef9bee13458036c9e4d5d7df58c8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine whether the given header is unavailable as part of the specified module.  <a href="classclang_1_1ModuleMap.html#a890ef9bee13458036c9e4d5d7df58c8f">More...</a><br /></td></tr>
<tr class="separator:a890ef9bee13458036c9e4d5d7df58c8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35bee9d02a3e7ced6bc9f7dd42ede743"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classclang_1_1Module.html">Module</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1ModuleMap.html#a35bee9d02a3e7ced6bc9f7dd42ede743">findModule</a> (StringRef Name) const</td></tr>
<tr class="memdesc:a35bee9d02a3e7ced6bc9f7dd42ede743"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve a module with the given name.  <a href="classclang_1_1ModuleMap.html#a35bee9d02a3e7ced6bc9f7dd42ede743">More...</a><br /></td></tr>
<tr class="separator:a35bee9d02a3e7ced6bc9f7dd42ede743"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9682383d1483005eb8de8ab46275f5e5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classclang_1_1Module.html">Module</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1ModuleMap.html#a9682383d1483005eb8de8ab46275f5e5">lookupModuleUnqualified</a> (StringRef Name, <a class="el" href="classclang_1_1Module.html">Module</a> *Context) const</td></tr>
<tr class="memdesc:a9682383d1483005eb8de8ab46275f5e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve a module with the given name using lexical name lookup, starting at the given context.  <a href="classclang_1_1ModuleMap.html#a9682383d1483005eb8de8ab46275f5e5">More...</a><br /></td></tr>
<tr class="separator:a9682383d1483005eb8de8ab46275f5e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4bd056e3b16607ace724463606dd3d5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classclang_1_1Module.html">Module</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1ModuleMap.html#ac4bd056e3b16607ace724463606dd3d5">lookupModuleQualified</a> (StringRef Name, <a class="el" href="classclang_1_1Module.html">Module</a> *Context) const</td></tr>
<tr class="memdesc:ac4bd056e3b16607ace724463606dd3d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve a module with the given name within the given context, using direct (qualified) name lookup.  <a href="classclang_1_1ModuleMap.html#ac4bd056e3b16607ace724463606dd3d5">More...</a><br /></td></tr>
<tr class="separator:ac4bd056e3b16607ace724463606dd3d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a115a5b7b114346aaa534995084fc3ac0"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classclang_1_1Module.html">Module</a> *, <a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1ModuleMap.html#a115a5b7b114346aaa534995084fc3ac0">findOrCreateModule</a> (StringRef Name, <a class="el" href="classclang_1_1Module.html">Module</a> *<a class="el" href="ASTDiff_8cpp.html#a787d77e399ffabdb66b1361d08789691">Parent</a>, <a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a> IsFramework, <a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a> IsExplicit)</td></tr>
<tr class="memdesc:a115a5b7b114346aaa534995084fc3ac0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find a new module or submodule, or create it if it does not already exist.  <a href="classclang_1_1ModuleMap.html#a115a5b7b114346aaa534995084fc3ac0">More...</a><br /></td></tr>
<tr class="separator:a115a5b7b114346aaa534995084fc3ac0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab984430b63c290eb25d0b696d486303c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classclang_1_1Module.html">Module</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1ModuleMap.html#ab984430b63c290eb25d0b696d486303c">createGlobalModuleFragmentForModuleUnit</a> (<a class="el" href="classclang_1_1SourceLocation.html">SourceLocation</a> Loc, <a class="el" href="classclang_1_1Module.html">Module</a> *<a class="el" href="ASTDiff_8cpp.html#a787d77e399ffabdb66b1361d08789691">Parent</a>=nullptr)</td></tr>
<tr class="memdesc:ab984430b63c290eb25d0b696d486303c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a global module fragment for a C++ module unit.  <a href="classclang_1_1ModuleMap.html#ab984430b63c290eb25d0b696d486303c">More...</a><br /></td></tr>
<tr class="separator:ab984430b63c290eb25d0b696d486303c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acea4a5b3bc65f0ff822859970c2ecac0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classclang_1_1Module.html">Module</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1ModuleMap.html#acea4a5b3bc65f0ff822859970c2ecac0">createPrivateModuleFragmentForInterfaceUnit</a> (<a class="el" href="classclang_1_1Module.html">Module</a> *<a class="el" href="ASTDiff_8cpp.html#a787d77e399ffabdb66b1361d08789691">Parent</a>, <a class="el" href="classclang_1_1SourceLocation.html">SourceLocation</a> Loc)</td></tr>
<tr class="memdesc:acea4a5b3bc65f0ff822859970c2ecac0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a global module fragment for a C++ module interface unit.  <a href="classclang_1_1ModuleMap.html#acea4a5b3bc65f0ff822859970c2ecac0">More...</a><br /></td></tr>
<tr class="separator:acea4a5b3bc65f0ff822859970c2ecac0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca8dfb44af54446f37a943a9dd4b9c4f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classclang_1_1Module.html">Module</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1ModuleMap.html#aca8dfb44af54446f37a943a9dd4b9c4f">createModuleForInterfaceUnit</a> (<a class="el" href="classclang_1_1SourceLocation.html">SourceLocation</a> Loc, StringRef Name)</td></tr>
<tr class="memdesc:aca8dfb44af54446f37a943a9dd4b9c4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new module for a C++ module interface unit.  <a href="classclang_1_1ModuleMap.html#aca8dfb44af54446f37a943a9dd4b9c4f">More...</a><br /></td></tr>
<tr class="separator:aca8dfb44af54446f37a943a9dd4b9c4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a488004c9aee8ccd0836e58ab114813ed"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classclang_1_1Module.html">Module</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1ModuleMap.html#a488004c9aee8ccd0836e58ab114813ed">createHeaderUnit</a> (<a class="el" href="classclang_1_1SourceLocation.html">SourceLocation</a> Loc, StringRef Name, <a class="el" href="structclang_1_1Module_1_1Header.html">Module::Header</a> H)</td></tr>
<tr class="memdesc:a488004c9aee8ccd0836e58ab114813ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a C++20 header unit.  <a href="classclang_1_1ModuleMap.html#a488004c9aee8ccd0836e58ab114813ed">More...</a><br /></td></tr>
<tr class="separator:a488004c9aee8ccd0836e58ab114813ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad78651ebbabbed8598a8b3d71c0712f6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classclang_1_1Module.html">Module</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1ModuleMap.html#ad78651ebbabbed8598a8b3d71c0712f6">inferFrameworkModule</a> (const <a class="el" href="classclang_1_1DirectoryEntry.html">DirectoryEntry</a> *FrameworkDir, <a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a> IsSystem, <a class="el" href="classclang_1_1Module.html">Module</a> *<a class="el" href="ASTDiff_8cpp.html#a787d77e399ffabdb66b1361d08789691">Parent</a>)</td></tr>
<tr class="memdesc:ad78651ebbabbed8598a8b3d71c0712f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Infer the contents of a framework module map from the given framework directory.  <a href="classclang_1_1ModuleMap.html#ad78651ebbabbed8598a8b3d71c0712f6">More...</a><br /></td></tr>
<tr class="separator:ad78651ebbabbed8598a8b3d71c0712f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a031a847ae6f15d895ef5808fd4af56aa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classclang_1_1Module.html">Module</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1ModuleMap.html#a031a847ae6f15d895ef5808fd4af56aa">createShadowedModule</a> (StringRef Name, <a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a> IsFramework, <a class="el" href="classclang_1_1Module.html">Module</a> *ShadowingModule)</td></tr>
<tr class="memdesc:a031a847ae6f15d895ef5808fd4af56aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new top-level module that is shadowed by <code>ShadowingModule</code>.  <a href="classclang_1_1ModuleMap.html#a031a847ae6f15d895ef5808fd4af56aa">More...</a><br /></td></tr>
<tr class="separator:a031a847ae6f15d895ef5808fd4af56aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a390f6e47e08d60984fca9c6c492d42f7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1ModuleMap.html#a390f6e47e08d60984fca9c6c492d42f7">finishModuleDeclarationScope</a> ()</td></tr>
<tr class="memdesc:a390f6e47e08d60984fca9c6c492d42f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new declaration scope for module names, allowing previously defined modules to shadow definitions from the new scope.  <a href="classclang_1_1ModuleMap.html#a390f6e47e08d60984fca9c6c492d42f7">More...</a><br /></td></tr>
<tr class="separator:a390f6e47e08d60984fca9c6c492d42f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3df11cf9b74e240aa373f25c1a63b49f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1ModuleMap.html#a3df11cf9b74e240aa373f25c1a63b49f">mayShadowNewModule</a> (<a class="el" href="classclang_1_1Module.html">Module</a> *ExistingModule)</td></tr>
<tr class="separator:a3df11cf9b74e240aa373f25c1a63b49f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b14289476fe5638600e7e1d78f41a0e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1ModuleMap.html#a3b14289476fe5638600e7e1d78f41a0e">canInferFrameworkModule</a> (const <a class="el" href="classclang_1_1DirectoryEntry.html">DirectoryEntry</a> *Dir) const</td></tr>
<tr class="memdesc:a3b14289476fe5638600e7e1d78f41a0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether a framework module can be inferred in the given directory.  <a href="classclang_1_1ModuleMap.html#a3b14289476fe5638600e7e1d78f41a0e">More...</a><br /></td></tr>
<tr class="separator:a3b14289476fe5638600e7e1d78f41a0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a303d98d21ca4002f64a8efe0d0861897"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceclang.html#a7e226bbdf107c8ffd9cca41873bbdd2d">OptionalFileEntryRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1ModuleMap.html#a303d98d21ca4002f64a8efe0d0861897">getContainingModuleMapFile</a> (const <a class="el" href="classclang_1_1Module.html">Module</a> *<a class="el" href="classclang_1_1Module.html">Module</a>) const</td></tr>
<tr class="memdesc:a303d98d21ca4002f64a8efe0d0861897"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the module map file containing the definition of the given module.  <a href="classclang_1_1ModuleMap.html#a303d98d21ca4002f64a8efe0d0861897">More...</a><br /></td></tr>
<tr class="separator:a303d98d21ca4002f64a8efe0d0861897"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7079336099f427b383128cfa445dd4ea"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceclang.html#a7e226bbdf107c8ffd9cca41873bbdd2d">OptionalFileEntryRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1ModuleMap.html#a7079336099f427b383128cfa445dd4ea">getModuleMapFileForUniquing</a> (const <a class="el" href="classclang_1_1Module.html">Module</a> *M) const</td></tr>
<tr class="memdesc:a7079336099f427b383128cfa445dd4ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the module map file that (along with the module name) uniquely identifies this module.  <a href="classclang_1_1ModuleMap.html#a7079336099f427b383128cfa445dd4ea">More...</a><br /></td></tr>
<tr class="separator:a7079336099f427b383128cfa445dd4ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64cf116b47bb6201a8154feab288cc65"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1ModuleMap.html#a64cf116b47bb6201a8154feab288cc65">setInferredModuleAllowedBy</a> (<a class="el" href="classclang_1_1Module.html">Module</a> *M, const <a class="el" href="classclang_1_1FileEntry.html">FileEntry</a> *ModMap)</td></tr>
<tr class="separator:a64cf116b47bb6201a8154feab288cc65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a1261e559ef2565d078189e60f96b85"><td class="memItemLeft" align="right" valign="top">std::error_code&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1ModuleMap.html#a7a1261e559ef2565d078189e60f96b85">canonicalizeModuleMapPath</a> (<a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; char &gt; &amp;Path)</td></tr>
<tr class="memdesc:a7a1261e559ef2565d078189e60f96b85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Canonicalize <code>Path</code> in a manner suitable for a module map file.  <a href="classclang_1_1ModuleMap.html#a7a1261e559ef2565d078189e60f96b85">More...</a><br /></td></tr>
<tr class="separator:a7a1261e559ef2565d078189e60f96b85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c2eda49b11b2b5dd41e456d986623e8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classclang_1_1ModuleMap.html#ac22c56a8f11f61caa8ab58809a21cca3">AdditionalModMapsSet</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1ModuleMap.html#a9c2eda49b11b2b5dd41e456d986623e8">getAdditionalModuleMapFiles</a> (const <a class="el" href="classclang_1_1Module.html">Module</a> *M)</td></tr>
<tr class="memdesc:a9c2eda49b11b2b5dd41e456d986623e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get any module map files other than getModuleMapFileForUniquing(M) that define submodules of a top-level module <code>M</code>.  <a href="classclang_1_1ModuleMap.html#a9c2eda49b11b2b5dd41e456d986623e8">More...</a><br /></td></tr>
<tr class="separator:a9c2eda49b11b2b5dd41e456d986623e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a748c66535339dbf5b860b72eff5cbadb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1ModuleMap.html#a748c66535339dbf5b860b72eff5cbadb">addAdditionalModuleMapFile</a> (const <a class="el" href="classclang_1_1Module.html">Module</a> *M, const <a class="el" href="classclang_1_1FileEntry.html">FileEntry</a> *<a class="el" href="classclang_1_1ModuleMap.html">ModuleMap</a>)</td></tr>
<tr class="separator:a748c66535339dbf5b860b72eff5cbadb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03d91ee91e3d302d32885c4d790b3915"><td class="memItemLeft" align="right" valign="top"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1ModuleMap.html#a03d91ee91e3d302d32885c4d790b3915">resolveExports</a> (<a class="el" href="classclang_1_1Module.html">Module</a> *Mod, <a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a> Complain)</td></tr>
<tr class="memdesc:a03d91ee91e3d302d32885c4d790b3915"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resolve all of the unresolved exports in the given module.  <a href="classclang_1_1ModuleMap.html#a03d91ee91e3d302d32885c4d790b3915">More...</a><br /></td></tr>
<tr class="separator:a03d91ee91e3d302d32885c4d790b3915"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff262a15ac7933edd463953d969e4f6b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1ModuleMap.html#aff262a15ac7933edd463953d969e4f6b">resolveUses</a> (<a class="el" href="classclang_1_1Module.html">Module</a> *Mod, <a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a> Complain)</td></tr>
<tr class="memdesc:aff262a15ac7933edd463953d969e4f6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resolve all of the unresolved uses in the given module.  <a href="classclang_1_1ModuleMap.html#aff262a15ac7933edd463953d969e4f6b">More...</a><br /></td></tr>
<tr class="separator:aff262a15ac7933edd463953d969e4f6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a635593eb7f27a7297eb22afacd08d104"><td class="memItemLeft" align="right" valign="top"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1ModuleMap.html#a635593eb7f27a7297eb22afacd08d104">resolveConflicts</a> (<a class="el" href="classclang_1_1Module.html">Module</a> *Mod, <a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a> Complain)</td></tr>
<tr class="memdesc:a635593eb7f27a7297eb22afacd08d104"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resolve all of the unresolved conflicts in the given module.  <a href="classclang_1_1ModuleMap.html#a635593eb7f27a7297eb22afacd08d104">More...</a><br /></td></tr>
<tr class="separator:a635593eb7f27a7297eb22afacd08d104"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0557c399446ad6ecf42bc7eaa4eb86d0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1ModuleMap.html#a0557c399446ad6ecf42bc7eaa4eb86d0">setUmbrellaHeader</a> (<a class="el" href="classclang_1_1Module.html">Module</a> *Mod, <a class="el" href="classclang_1_1FileEntryRef.html">FileEntryRef</a> UmbrellaHeader, const Twine &amp;NameAsWritten, const Twine &amp;PathRelativeToRootModuleDirectory)</td></tr>
<tr class="memdesc:a0557c399446ad6ecf42bc7eaa4eb86d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the umbrella header of the given module to the given header.  <a href="classclang_1_1ModuleMap.html#a0557c399446ad6ecf42bc7eaa4eb86d0">More...</a><br /></td></tr>
<tr class="separator:a0557c399446ad6ecf42bc7eaa4eb86d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c5148fa4f93b67492291bee915c9e27"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1ModuleMap.html#a4c5148fa4f93b67492291bee915c9e27">setUmbrellaDir</a> (<a class="el" href="classclang_1_1Module.html">Module</a> *Mod, const <a class="el" href="classclang_1_1DirectoryEntry.html">DirectoryEntry</a> *UmbrellaDir, const Twine &amp;NameAsWritten, const Twine &amp;PathRelativeToRootModuleDirectory)</td></tr>
<tr class="memdesc:a4c5148fa4f93b67492291bee915c9e27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the umbrella directory of the given module to the given directory.  <a href="classclang_1_1ModuleMap.html#a4c5148fa4f93b67492291bee915c9e27">More...</a><br /></td></tr>
<tr class="separator:a4c5148fa4f93b67492291bee915c9e27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb605a0f3e5ac2213bab92d201fc1ec1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1ModuleMap.html#acb605a0f3e5ac2213bab92d201fc1ec1">addHeader</a> (<a class="el" href="classclang_1_1Module.html">Module</a> *Mod, <a class="el" href="structclang_1_1Module_1_1Header.html">Module::Header</a> Header, <a class="el" href="classclang_1_1ModuleMap.html#ac7a2413d4d0a8f29d2dad359bcfd8dec">ModuleHeaderRole</a> Role, <a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a> Imported=<a class="el" href="stdbool_8h.html#a65e9886d74aaee76545e83dd09011727">false</a>)</td></tr>
<tr class="memdesc:acb605a0f3e5ac2213bab92d201fc1ec1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds this header to the given module.  <a href="classclang_1_1ModuleMap.html#acb605a0f3e5ac2213bab92d201fc1ec1">More...</a><br /></td></tr>
<tr class="separator:acb605a0f3e5ac2213bab92d201fc1ec1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a516cfeb32bb3a464262cf6f369417eab"><td class="memItemLeft" align="right" valign="top"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1ModuleMap.html#a516cfeb32bb3a464262cf6f369417eab">parseModuleMapFile</a> (const <a class="el" href="classclang_1_1FileEntry.html">FileEntry</a> *File, <a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a> IsSystem, const <a class="el" href="classclang_1_1DirectoryEntry.html">DirectoryEntry</a> *HomeDir, <a class="el" href="classclang_1_1FileID.html">FileID</a> ID=<a class="el" href="classclang_1_1FileID.html">FileID</a>(), <a class="el" href="classunsigned.html">unsigned</a> *<a class="el" href="Format_8cpp.html#a9fcf84dffafb0ea03c0f9b686ddbf2b3">Offset</a>=nullptr, <a class="el" href="classclang_1_1SourceLocation.html">SourceLocation</a> ExternModuleLoc=<a class="el" href="classclang_1_1SourceLocation.html">SourceLocation</a>())</td></tr>
<tr class="memdesc:a516cfeb32bb3a464262cf6f369417eab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse the given module map file, and record any modules we encounter.  <a href="classclang_1_1ModuleMap.html#a516cfeb32bb3a464262cf6f369417eab">More...</a><br /></td></tr>
<tr class="separator:a516cfeb32bb3a464262cf6f369417eab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ed1579ac35c5dcb1ab68449949a6912"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1ModuleMap.html#a0ed1579ac35c5dcb1ab68449949a6912">dump</a> ()</td></tr>
<tr class="memdesc:a0ed1579ac35c5dcb1ab68449949a6912"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dump the contents of the module map, for debugging purposes.  <a href="classclang_1_1ModuleMap.html#a0ed1579ac35c5dcb1ab68449949a6912">More...</a><br /></td></tr>
<tr class="separator:a0ed1579ac35c5dcb1ab68449949a6912"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ab65f1f0882fcff9a15da9cfbf0fd02"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classclang_1_1ModuleMap.html#a1b352087754574155a198a4cb0d6e197">module_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1ModuleMap.html#a6ab65f1f0882fcff9a15da9cfbf0fd02">module_begin</a> () const</td></tr>
<tr class="separator:a6ab65f1f0882fcff9a15da9cfbf0fd02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d9e3147d81ec86cf00eea874d9ea95b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classclang_1_1ModuleMap.html#a1b352087754574155a198a4cb0d6e197">module_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1ModuleMap.html#a9d9e3147d81ec86cf00eea874d9ea95b">module_end</a> () const</td></tr>
<tr class="separator:a9d9e3147d81ec86cf00eea874d9ea95b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9124c52cfa4df22a479eddbcc8e350d3"><td class="memItemLeft" align="right" valign="top">llvm::iterator_range&lt; <a class="el" href="classclang_1_1ModuleMap.html#a1b352087754574155a198a4cb0d6e197">module_iterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1ModuleMap.html#a9124c52cfa4df22a479eddbcc8e350d3">modules</a> () const</td></tr>
<tr class="separator:a9124c52cfa4df22a479eddbcc8e350d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac61bce84c6ecb21f1f05539c84b855ad"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1ModuleMap.html#ac61bce84c6ecb21f1f05539c84b855ad">cacheModuleLoad</a> (const <a class="el" href="classclang_1_1IdentifierInfo.html">IdentifierInfo</a> &amp;II, <a class="el" href="classclang_1_1Module.html">Module</a> *M)</td></tr>
<tr class="memdesc:ac61bce84c6ecb21f1f05539c84b855ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cache a module load. M might be nullptr.  <a href="classclang_1_1ModuleMap.html#ac61bce84c6ecb21f1f05539c84b855ad">More...</a><br /></td></tr>
<tr class="separator:ac61bce84c6ecb21f1f05539c84b855ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8673ca4aacbe3e404597553a4c298005"><td class="memItemLeft" align="right" valign="top">std::optional&lt; <a class="el" href="classclang_1_1Module.html">Module</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1ModuleMap.html#a8673ca4aacbe3e404597553a4c298005">getCachedModuleLoad</a> (const <a class="el" href="classclang_1_1IdentifierInfo.html">IdentifierInfo</a> &amp;II)</td></tr>
<tr class="memdesc:a8673ca4aacbe3e404597553a4c298005"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a cached module load.  <a href="classclang_1_1ModuleMap.html#a8673ca4aacbe3e404597553a4c298005">More...</a><br /></td></tr>
<tr class="separator:a8673ca4aacbe3e404597553a4c298005"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:af95957116dd995616c90e64c864811cd"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classclang_1_1ModuleMap.html#ac7a2413d4d0a8f29d2dad359bcfd8dec">ModuleHeaderRole</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1ModuleMap.html#af95957116dd995616c90e64c864811cd">headerKindToRole</a> (<a class="el" href="classclang_1_1Module.html#a359f634f3c9358d7c969744e25beb826">Module::HeaderKind</a> Kind)</td></tr>
<tr class="memdesc:af95957116dd995616c90e64c864811cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a header kind to a role. Requires Kind to not be HK_Excluded.  <a href="classclang_1_1ModuleMap.html#af95957116dd995616c90e64c864811cd">More...</a><br /></td></tr>
<tr class="separator:af95957116dd995616c90e64c864811cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32c51efd0ee64aaadd73218544eeeb01"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classclang_1_1Module.html#a359f634f3c9358d7c969744e25beb826">Module::HeaderKind</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1ModuleMap.html#a32c51efd0ee64aaadd73218544eeeb01">headerRoleToKind</a> (<a class="el" href="classclang_1_1ModuleMap.html#ac7a2413d4d0a8f29d2dad359bcfd8dec">ModuleHeaderRole</a> Role)</td></tr>
<tr class="memdesc:a32c51efd0ee64aaadd73218544eeeb01"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a header role to a kind.  <a href="classclang_1_1ModuleMap.html#a32c51efd0ee64aaadd73218544eeeb01">More...</a><br /></td></tr>
<tr class="separator:a32c51efd0ee64aaadd73218544eeeb01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ddbcfb5014e3bd0bcf33a30b41cc511"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1ModuleMap.html#a5ddbcfb5014e3bd0bcf33a30b41cc511">isModular</a> (<a class="el" href="classclang_1_1ModuleMap.html#ac7a2413d4d0a8f29d2dad359bcfd8dec">ModuleHeaderRole</a> Role)</td></tr>
<tr class="memdesc:a5ddbcfb5014e3bd0bcf33a30b41cc511"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the header with the given role is a modular one.  <a href="classclang_1_1ModuleMap.html#a5ddbcfb5014e3bd0bcf33a30b41cc511">More...</a><br /></td></tr>
<tr class="separator:a5ddbcfb5014e3bd0bcf33a30b41cc511"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40c825f7506d1abd0d9bc54eba6330e6"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1ModuleMap.html#a40c825f7506d1abd0d9bc54eba6330e6">isBuiltinHeader</a> (StringRef FileName)</td></tr>
<tr class="memdesc:a40c825f7506d1abd0d9bc54eba6330e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is this a compiler builtin header?  <a href="classclang_1_1ModuleMap.html#a40c825f7506d1abd0d9bc54eba6330e6">More...</a><br /></td></tr>
<tr class="separator:a40c825f7506d1abd0d9bc54eba6330e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a69fccb440615f32e24516ed4e718457d"><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1ModuleMap.html#a69fccb440615f32e24516ed4e718457d">ModuleMapParser</a></td></tr>
<tr class="separator:a69fccb440615f32e24516ed4e718457d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock">
<p class="definition">Definition at line <a class="el" href="ModuleMap_8h_source.html#l00076">76</a> of file <a class="el" href="ModuleMap_8h_source.html">ModuleMap.h</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="ac22c56a8f11f61caa8ab58809a21cca3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac22c56a8f11f61caa8ab58809a21cca3">&#9670;&nbsp;</a></span>AdditionalModMapsSet</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classclang_1_1ModuleMap.html#ac22c56a8f11f61caa8ab58809a21cca3">clang::ModuleMap::AdditionalModMapsSet</a> =  <a class="el" href="classllvm_1_1SmallPtrSet.html">llvm::SmallPtrSet</a>&lt;const <a class="el" href="classclang_1_1FileEntry.html">FileEntry</a> *, 1&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ModuleMap_8h_source.html#l00199">199</a> of file <a class="el" href="ModuleMap_8h_source.html">ModuleMap.h</a>.</p>

</div>
</div>
<a id="a1b352087754574155a198a4cb0d6e197"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b352087754574155a198a4cb0d6e197">&#9670;&nbsp;</a></span>module_iterator</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classclang_1_1ModuleMap.html#a1b352087754574155a198a4cb0d6e197">clang::ModuleMap::module_iterator</a> =  llvm::StringMap&lt;<a class="el" href="classclang_1_1Module.html">Module</a> *&gt;::const_iterator</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ModuleMap_8h_source.html#l00722">722</a> of file <a class="el" href="ModuleMap_8h_source.html">ModuleMap.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Enumeration Documentation</h2>
<a id="ac7a2413d4d0a8f29d2dad359bcfd8dec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7a2413d4d0a8f29d2dad359bcfd8dec">&#9670;&nbsp;</a></span>ModuleHeaderRole</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classclang_1_1ModuleMap.html#ac7a2413d4d0a8f29d2dad359bcfd8dec">clang::ModuleMap::ModuleHeaderRole</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Flags describing the role of a module header. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ac7a2413d4d0a8f29d2dad359bcfd8deca50b6dee47a2d5b1f50f46dc46e4c96aa"></a>NormalHeader&#160;</td><td class="fielddoc"><p>This header is normally included in the module. </p>
</td></tr>
<tr><td class="fieldname"><a id="ac7a2413d4d0a8f29d2dad359bcfd8deca0500e1f1c1ee8f9e6c76c993aa48b0d4"></a>PrivateHeader&#160;</td><td class="fielddoc"><p>This header is included but private. </p>
</td></tr>
<tr><td class="fieldname"><a id="ac7a2413d4d0a8f29d2dad359bcfd8decad7e8857e09c5d0fbe70ad90e0e584200"></a>TextualHeader&#160;</td><td class="fielddoc"><p>This header is part of the module (for layering purposes) but should be textually included. </p>
</td></tr>
<tr><td class="fieldname"><a id="ac7a2413d4d0a8f29d2dad359bcfd8deca29ca8d089c3fd646d54e611219d0d877"></a>ExcludedHeader&#160;</td><td class="fielddoc"><p>This header is explicitly excluded from the module. </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="ModuleMap_8h_source.html#l00129">129</a> of file <a class="el" href="ModuleMap_8h_source.html">ModuleMap.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a767bb9d1787801348282cf9b588df471"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a767bb9d1787801348282cf9b588df471">&#9670;&nbsp;</a></span>ModuleMap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ModuleMap::ModuleMap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1SourceManager.html">SourceManager</a> &amp;&#160;</td>
          <td class="paramname"><em>SourceMgr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classclang_1_1DiagnosticsEngine.html">DiagnosticsEngine</a> &amp;&#160;</td>
          <td class="paramname"><em>Diags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classclang_1_1LangOptions.html">LangOptions</a> &amp;&#160;</td>
          <td class="paramname"><em>LangOpts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classclang_1_1TargetInfo.html">TargetInfo</a> *&#160;</td>
          <td class="paramname"><em>Target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classclang_1_1HeaderSearch.html">HeaderSearch</a> &amp;&#160;</td>
          <td class="paramname"><em>HeaderInfo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct a new module map. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">SourceMgr</td><td>The source manager used to find module files and headers. This source manager should be shared with the header-search mechanism, since they will refer to the same headers.</td></tr>
    <tr><td class="paramname">Diags</td><td>A diagnostic engine used for diagnostics.</td></tr>
    <tr><td class="paramname">LangOpts</td><td>Language options for this translation unit.</td></tr>
    <tr><td class="paramname">Target</td><td>The target for this translation unit. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="ModuleMap_8cpp_source.html#l00317">317</a> of file <a class="el" href="ModuleMap_8cpp_source.html">ModuleMap.cpp</a>.</p>

</div>
</div>
<a id="ab8769cd7eba3cb7f8f1cd2dde890603d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8769cd7eba3cb7f8f1cd2dde890603d">&#9670;&nbsp;</a></span>~ModuleMap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ModuleMap::~ModuleMap </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroy the module map. </p>

<p class="definition">Definition at line <a class="el" href="ModuleMap_8cpp_source.html#l00325">325</a> of file <a class="el" href="ModuleMap_8cpp_source.html">ModuleMap.cpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a748c66535339dbf5b860b72eff5cbadb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a748c66535339dbf5b860b72eff5cbadb">&#9670;&nbsp;</a></span>addAdditionalModuleMapFile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ModuleMap::addAdditionalModuleMapFile </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classclang_1_1Module.html">Module</a> *&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classclang_1_1FileEntry.html">FileEntry</a> *&#160;</td>
          <td class="paramname"><em>ModuleMap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ModuleMap_8cpp_source.html#l01330">1330</a> of file <a class="el" href="ModuleMap_8cpp_source.html">ModuleMap.cpp</a>.</p>

</div>
</div>
<a id="acb605a0f3e5ac2213bab92d201fc1ec1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb605a0f3e5ac2213bab92d201fc1ec1">&#9670;&nbsp;</a></span>addHeader()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ModuleMap::addHeader </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1Module.html">Module</a> *&#160;</td>
          <td class="paramname"><em>Mod</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structclang_1_1Module_1_1Header.html">Module::Header</a>&#160;</td>
          <td class="paramname"><em>Header</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classclang_1_1ModuleMap.html#ac7a2413d4d0a8f29d2dad359bcfd8dec">ModuleHeaderRole</a>&#160;</td>
          <td class="paramname"><em>Role</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>Imported</em> = <code><a class="el" href="stdbool_8h.html#a65e9886d74aaee76545e83dd09011727">false</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds this header to the given module. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Role</td><td>The role of the header wrt the module. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="ModuleMap_8cpp_source.html#l01235">1235</a> of file <a class="el" href="ModuleMap_8cpp_source.html">ModuleMap.cpp</a>.</p>

<p class="reference">References <a class="el" href="Module_8h_source.html#l00218">clang::Module::Header::Entry</a>, <a class="el" href="Module_8h_source.html#l00597">clang::Module::getTopLevelModule()</a>, <a class="el" href="ModuleMap_8cpp_source.html#l00076">headerRoleToKind()</a>, <a class="el" href="Module_8h_source.html#l00234">clang::Module::Headers</a>, <a class="el" href="LangOptions_8h_source.html#l00514">clang::LangOptions::isCompilingModule()</a>, and <a class="el" href="HeaderSearch_8cpp_source.html#l01384">clang::HeaderSearch::MarkFileModuleHeader()</a>.</p>

<p class="reference">Referenced by <a class="el" href="ASTReader_8cpp_source.html#l01918">clang::serialization::reader::HeaderFileInfoTrait::ReadData()</a>.</p>

</div>
</div>
<a id="a06068cd4735154ef4218ab96f9462412"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06068cd4735154ef4218ab96f9462412">&#9670;&nbsp;</a></span>addLinkAsDependency()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ModuleMap::addLinkAsDependency </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1Module.html">Module</a> *&#160;</td>
          <td class="paramname"><em>Mod</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Make module to use export_as as the link dependency name if enough information is available or add it to a pending list otherwise. </p>

<p class="definition">Definition at line <a class="el" href="ModuleMap_8cpp_source.html#l00069">69</a> of file <a class="el" href="ModuleMap_8cpp_source.html">ModuleMap.cpp</a>.</p>

<p class="reference">References <a class="el" href="Module_8h_source.html#l00161">clang::Module::ExportAsModule</a>, <a class="el" href="ModuleMap_8cpp_source.html#l00809">findModule()</a>, <a class="el" href="Module_8h_source.html#l00101">clang::Module::Name</a>, and <a class="el" href="Module_8h_source.html#l00416">clang::Module::UseExportAsModuleLinkName</a>.</p>

</div>
</div>
<a id="a516ba163200648ee309a8b16ccc0d62a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a516ba163200648ee309a8b16ccc0d62a">&#9670;&nbsp;</a></span>addModuleMapCallbacks()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void clang::ModuleMap::addModuleMapCallbacks </td>
          <td>(</td>
          <td class="paramtype">std::unique_ptr&lt; <a class="el" href="classclang_1_1ModuleMapCallbacks.html">ModuleMapCallbacks</a> &gt;&#160;</td>
          <td class="paramname"><em>Callback</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add a module map callback. </p>

<p class="definition">Definition at line <a class="el" href="ModuleMap_8h_source.html#l00424">424</a> of file <a class="el" href="ModuleMap_8h_source.html">ModuleMap.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="DependencyFile_8cpp_source.html#l00181">clang::DependencyCollector::attachToPreprocessor()</a>, and <a class="el" href="ModuleDependencyCollector_8cpp_source.html#l00112">clang::ModuleDependencyCollector::attachToPreprocessor()</a>.</p>

</div>
</div>
<a id="ac61bce84c6ecb21f1f05539c84b855ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac61bce84c6ecb21f1f05539c84b855ad">&#9670;&nbsp;</a></span>cacheModuleLoad()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void clang::ModuleMap::cacheModuleLoad </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classclang_1_1IdentifierInfo.html">IdentifierInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>II</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classclang_1_1Module.html">Module</a> *&#160;</td>
          <td class="paramname"><em>M</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Cache a module load. M might be nullptr. </p>

<p class="definition">Definition at line <a class="el" href="ModuleMap_8h_source.html#l00731">731</a> of file <a class="el" href="ModuleMap_8h_source.html">ModuleMap.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="CompilerInstance_8cpp_source.html#l01959">clang::CompilerInstance::loadModule()</a>.</p>

</div>
</div>
<a id="a3b14289476fe5638600e7e1d78f41a0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b14289476fe5638600e7e1d78f41a0e">&#9670;&nbsp;</a></span>canInferFrameworkModule()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a> clang::ModuleMap::canInferFrameworkModule </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classclang_1_1DirectoryEntry.html">DirectoryEntry</a> *&#160;</td>
          <td class="paramname"><em>Dir</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check whether a framework module can be inferred in the given directory. </p>

<p class="definition">Definition at line <a class="el" href="ModuleMap_8h_source.html#l00598">598</a> of file <a class="el" href="ModuleMap_8h_source.html">ModuleMap.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="FrontendAction_8cpp_source.html#l00442">loadModuleMapForModuleBuild()</a>.</p>

</div>
</div>
<a id="a7a1261e559ef2565d078189e60f96b85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a1261e559ef2565d078189e60f96b85">&#9670;&nbsp;</a></span>canonicalizeModuleMapPath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::error_code ModuleMap::canonicalizeModuleMapPath </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; char &gt; &amp;&#160;</td>
          <td class="paramname"><em>Path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Canonicalize <code>Path</code> in a manner suitable for a module map file. </p>
<p>In particular, this canonicalizes the parent directory separately from the filename so that it does not affect header resolution relative to the modulemap.</p>
<dl class="section return"><dt>Returns</dt><dd>an error code if any filesystem operations failed. In this case <code>Path</code> is not modified. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ModuleMap_8cpp_source.html#l01288">1288</a> of file <a class="el" href="ModuleMap_8cpp_source.html">ModuleMap.cpp</a>.</p>

<p class="reference">References <a class="el" href="FileManager_8cpp_source.html#l00634">clang::FileManager::getCanonicalName()</a>, <a class="el" href="FileManager_8cpp_source.html#l00190">clang::FileManager::getDirectory()</a>, <a class="el" href="SourceManager_8h_source.html#l00818">clang::SourceManager::getFileManager()</a>, and <a class="el" href="ASTDiff_8cpp_source.html#l00191">Parent</a>.</p>

</div>
</div>
<a id="ab984430b63c290eb25d0b696d486303c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab984430b63c290eb25d0b696d486303c">&#9670;&nbsp;</a></span>createGlobalModuleFragmentForModuleUnit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classclang_1_1Module.html">Module</a> * ModuleMap::createGlobalModuleFragmentForModuleUnit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1SourceLocation.html">SourceLocation</a>&#160;</td>
          <td class="paramname"><em>Loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classclang_1_1Module.html">Module</a> *&#160;</td>
          <td class="paramname"><em>Parent</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a global module fragment for a C++ module unit. </p>
<p>We model the global module fragment as a submodule of the module interface unit. Unfortunately, we can't create the module interface unit's <a class="el" href="classclang_1_1Module.html" title="Describes a module or submodule.">Module</a> until later, because we don't know what it will be called usually. See C++20 [module.unit]/7.2 for the case we could know its parent. </p>

<p class="definition">Definition at line <a class="el" href="ModuleMap_8cpp_source.html#l00854">854</a> of file <a class="el" href="ModuleMap_8cpp_source.html">ModuleMap.cpp</a>.</p>

<p class="reference">References <a class="el" href="Module_8h_source.html#l00124">clang::Module::GlobalModuleFragment</a>, and <a class="el" href="ASTDiff_8cpp_source.html#l00191">Parent</a>.</p>

</div>
</div>
<a id="a488004c9aee8ccd0836e58ab114813ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a488004c9aee8ccd0836e58ab114813ed">&#9670;&nbsp;</a></span>createHeaderUnit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classclang_1_1Module.html">Module</a> * ModuleMap::createHeaderUnit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1SourceLocation.html">SourceLocation</a>&#160;</td>
          <td class="paramname"><em>Loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StringRef&#160;</td>
          <td class="paramname"><em>Name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structclang_1_1Module_1_1Header.html">Module::Header</a>&#160;</td>
          <td class="paramname"><em>H</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a C++20 header unit. </p>

<p class="definition">Definition at line <a class="el" href="ModuleMap_8cpp_source.html#l00903">903</a> of file <a class="el" href="ModuleMap_8cpp_source.html">ModuleMap.cpp</a>.</p>

</div>
</div>
<a id="aca8dfb44af54446f37a943a9dd4b9c4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca8dfb44af54446f37a943a9dd4b9c4f">&#9670;&nbsp;</a></span>createModuleForInterfaceUnit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classclang_1_1Module.html">Module</a> * ModuleMap::createModuleForInterfaceUnit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1SourceLocation.html">SourceLocation</a>&#160;</td>
          <td class="paramname"><em>Loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StringRef&#160;</td>
          <td class="paramname"><em>Name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new module for a C++ module interface unit. </p>
<p>The module must not already exist, and will be configured for the current compilation.</p>
<p>Note that this also sets the current module to the newly-created module.</p>
<dl class="section return"><dt>Returns</dt><dd>The newly-created module. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ModuleMap_8cpp_source.html#l00876">876</a> of file <a class="el" href="ModuleMap_8cpp_source.html">ModuleMap.cpp</a>.</p>

</div>
</div>
<a id="acea4a5b3bc65f0ff822859970c2ecac0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acea4a5b3bc65f0ff822859970c2ecac0">&#9670;&nbsp;</a></span>createPrivateModuleFragmentForInterfaceUnit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classclang_1_1Module.html">Module</a> * ModuleMap::createPrivateModuleFragmentForInterfaceUnit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1Module.html">Module</a> *&#160;</td>
          <td class="paramname"><em>Parent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classclang_1_1SourceLocation.html">SourceLocation</a>&#160;</td>
          <td class="paramname"><em>Loc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a global module fragment for a C++ module interface unit. </p>

<p class="definition">Definition at line <a class="el" href="ModuleMap_8cpp_source.html#l00867">867</a> of file <a class="el" href="ModuleMap_8cpp_source.html">ModuleMap.cpp</a>.</p>

<p class="reference">References <a class="el" href="ASTDiff_8cpp_source.html#l00191">Parent</a>, and <a class="el" href="Module_8h_source.html#l00127">clang::Module::PrivateModuleFragment</a>.</p>

</div>
</div>
<a id="a031a847ae6f15d895ef5808fd4af56aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a031a847ae6f15d895ef5808fd4af56aa">&#9670;&nbsp;</a></span>createShadowedModule()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classclang_1_1Module.html">Module</a> * ModuleMap::createShadowedModule </td>
          <td>(</td>
          <td class="paramtype">StringRef&#160;</td>
          <td class="paramname"><em>Name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>IsFramework</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classclang_1_1Module.html">Module</a> *&#160;</td>
          <td class="paramname"><em>ShadowingModule</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new top-level module that is shadowed by <code>ShadowingModule</code>. </p>

<p class="definition">Definition at line <a class="el" href="ModuleMap_8cpp_source.html#l01124">1124</a> of file <a class="el" href="ModuleMap_8cpp_source.html">ModuleMap.cpp</a>.</p>

</div>
</div>
<a id="a22cfc8d05dbf3c2cceb132f4c789b8d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22cfc8d05dbf3c2cceb132f4c789b8d1">&#9670;&nbsp;</a></span>diagnoseHeaderInclusion()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ModuleMap::diagnoseHeaderInclusion </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1Module.html">Module</a> *&#160;</td>
          <td class="paramname"><em>RequestingModule</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>RequestingModuleIsModuleInterface</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classclang_1_1SourceLocation.html">SourceLocation</a>&#160;</td>
          <td class="paramname"><em>FilenameLoc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StringRef&#160;</td>
          <td class="paramname"><em>Filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classclang_1_1FileEntryRef.html">FileEntryRef</a>&#160;</td>
          <td class="paramname"><em>File</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reports errors if a module must not include a specific file. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">RequestingModule</td><td>The module including a file.</td></tr>
    <tr><td class="paramname">RequestingModuleIsModuleInterface</td><td><code>true</code> if the inclusion is in the interface of RequestingModule, <code>false</code> if it's in the implementation of RequestingModule. Value is ignored and meaningless if RequestingModule is nullptr.</td></tr>
    <tr><td class="paramname">FilenameLoc</td><td>The location of the inclusion's filename.</td></tr>
    <tr><td class="paramname">Filename</td><td>The included filename as written.</td></tr>
    <tr><td class="paramname">File</td><td>The included file. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="ModuleMap_8cpp_source.html#l00474">474</a> of file <a class="el" href="ModuleMap_8cpp_source.html">ModuleMap.cpp</a>.</p>

<p class="reference">References <a class="el" href="Module_8cpp_source.html#l00290">clang::Module::directlyUses()</a>, <a class="el" href="ModuleMap_8h_source.html#l00141">ExcludedHeader</a>, <a class="el" href="namespaceclang.html#a7379bdfd074341d981e1a31d6de2cff3a0b27918290ff5323bea1e3b78a9cf04e">clang::File</a>, <a class="el" href="Format_8cpp_source.html#l02773">Filename</a>, <a class="el" href="Module_8cpp_source.html#l00239">clang::Module::getFullModuleName()</a>, <a class="el" href="ModuleMap_8h_source.html#l00176">clang::ModuleMap::KnownHeader::getModule()</a>, <a class="el" href="ModuleMap_8h_source.html#l00179">clang::ModuleMap::KnownHeader::getRole()</a>, <a class="el" href="Module_8h_source.html#l00597">clang::Module::getTopLevelModule()</a>, <a class="el" href="ModuleMap_8cpp_source.html#l00470">getTopLevelOrNull()</a>, <a class="el" href="LangOptions_8h_source.html#l00514">clang::LangOptions::isCompilingModule()</a>, <a class="el" href="Module_8h_source.html#l00287">clang::Module::IsFramework</a>, <a class="el" href="Module_8h_source.html#l00101">clang::Module::Name</a>, <a class="el" href="Basic_2Diagnostic_8h_source.html#l01542">clang::DiagnosticsEngine::Report()</a>, <a class="el" href="ModuleMap_8cpp_source.html#l01200">resolveHeaderDirectives()</a>, <a class="el" href="ModuleMap_8cpp_source.html#l01370">resolveUses()</a>, and <a class="el" href="ModuleMap_8cpp_source.html#l00449">violatesPrivateInclude()</a>.</p>

<p class="reference">Referenced by <a class="el" href="PPDirectives_8cpp_source.html#l00931">clang::Preprocessor::LookupFile()</a>.</p>

</div>
</div>
<a id="a0ed1579ac35c5dcb1ab68449949a6912"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ed1579ac35c5dcb1ab68449949a6912">&#9670;&nbsp;</a></span>dump()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LLVM_DUMP_METHOD void ModuleMap::dump </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dump the contents of the module map, for debugging purposes. </p>

<p class="definition">Definition at line <a class="el" href="ModuleMap_8cpp_source.html#l01335">1335</a> of file <a class="el" href="ModuleMap_8cpp_source.html">ModuleMap.cpp</a>.</p>

<p class="reference">References <a class="el" href="Module_8cpp_source.html#l00454">clang::Module::print()</a>.</p>

</div>
</div>
<a id="a94cf9768b587f077bf7916c10754713a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94cf9768b587f077bf7916c10754713a">&#9670;&nbsp;</a></span>findAllModulesForHeader()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classclang_1_1ModuleMap_1_1KnownHeader.html">ModuleMap::KnownHeader</a> &gt; ModuleMap::findAllModulesForHeader </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classclang_1_1FileEntry.html">FileEntry</a> *&#160;</td>
          <td class="paramname"><em>File</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve all the modules that contain the given header file. </p>
<p>Note that this does not implicitly load module maps, except for builtin headers, and does not consult the external source. (Those checks are the responsibility of <a class="el" href="classclang_1_1HeaderSearch.html">HeaderSearch</a>.)</p>
<p>Typically, <a class="el" href="classclang_1_1ModuleMap.html#ac0f3adfd4ab31073e14c5f2d79398ad5">findModuleForHeader</a> should be used instead, as it picks the preferred module for the header. </p>

<p class="definition">Definition at line <a class="el" href="ModuleMap_8cpp_source.html#l00686">686</a> of file <a class="el" href="ModuleMap_8cpp_source.html">ModuleMap.cpp</a>.</p>

<p class="reference">References <a class="el" href="namespaceclang.html#a7379bdfd074341d981e1a31d6de2cff3a0b27918290ff5323bea1e3b78a9cf04e">clang::File</a>.</p>

<p class="reference">Referenced by <a class="el" href="HeaderSearch_8cpp_source.html#l01569">clang::HeaderSearch::findAllModulesForHeader()</a>.</p>

</div>
</div>
<a id="a35bee9d02a3e7ced6bc9f7dd42ede743"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35bee9d02a3e7ced6bc9f7dd42ede743">&#9670;&nbsp;</a></span>findModule()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classclang_1_1Module.html">Module</a> * ModuleMap::findModule </td>
          <td>(</td>
          <td class="paramtype">StringRef&#160;</td>
          <td class="paramname"><em>Name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve a module with the given name. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Name</td><td>The name of the module to look up.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The named module, if known; otherwise, returns null. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ModuleMap_8cpp_source.html#l00809">809</a> of file <a class="el" href="ModuleMap_8cpp_source.html">ModuleMap.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="ModuleMap_8cpp_source.html#l00069">addLinkAsDependency()</a>, and <a class="el" href="HeaderSearch_8cpp_source.html#l00272">clang::HeaderSearch::lookupModule()</a>.</p>

</div>
</div>
<a id="ac0f3adfd4ab31073e14c5f2d79398ad5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0f3adfd4ab31073e14c5f2d79398ad5">&#9670;&nbsp;</a></span>findModuleForHeader()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classclang_1_1ModuleMap_1_1KnownHeader.html">ModuleMap::KnownHeader</a> ModuleMap::findModuleForHeader </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classclang_1_1FileEntry.html">FileEntry</a> *&#160;</td>
          <td class="paramname"><em>File</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>AllowTextual</em> = <code><a class="el" href="stdbool_8h.html#a65e9886d74aaee76545e83dd09011727">false</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>AllowExcluded</em> = <code><a class="el" href="stdbool_8h.html#a65e9886d74aaee76545e83dd09011727">false</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve the module that owns the given header file, if any. </p>
<p>Note that this does not implicitly load module maps, except for builtin headers, and does not consult the external source. (Those checks are the responsibility of <a class="el" href="classclang_1_1HeaderSearch.html">HeaderSearch</a>.)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">File</td><td>The header file that is likely to be included.</td></tr>
    <tr><td class="paramname">AllowTextual</td><td>If <code>true</code> and <code>File</code> is a textual header, return its owning module. Otherwise, no <a class="el" href="classclang_1_1ModuleMap_1_1KnownHeader.html" title="A header that is known to reside within a given module, whether it was included or excluded.">KnownHeader</a> will be returned if the file is only known as a textual header.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The module <a class="el" href="classclang_1_1ModuleMap_1_1KnownHeader.html" title="A header that is known to reside within a given module, whether it was included or excluded.">KnownHeader</a>, which provides the module that owns the given header file. The <a class="el" href="classclang_1_1ModuleMap_1_1KnownHeader.html" title="A header that is known to reside within a given module, whether it was included or excluded.">KnownHeader</a> is default constructed to indicate that no module owns this header file. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ModuleMap_8cpp_source.html#l00584">584</a> of file <a class="el" href="ModuleMap_8cpp_source.html">ModuleMap.cpp</a>.</p>

<p class="reference">References <a class="el" href="ModuleMap_8h_source.html#l00141">ExcludedHeader</a>, <a class="el" href="namespaceclang.html#a7379bdfd074341d981e1a31d6de2cff3a0b27918290ff5323bea1e3b78a9cf04e">clang::File</a>, <a class="el" href="ModuleMap_8h_source.html#l00176">clang::ModuleMap::KnownHeader::getModule()</a>, <a class="el" href="ModuleMap_8h_source.html#l00179">clang::ModuleMap::KnownHeader::getRole()</a>, <a class="el" href="Module_8h_source.html#l00597">clang::Module::getTopLevelModule()</a>, <a class="el" href="ModuleMap_8cpp_source.html#l00556">isBetterKnownHeader()</a>, and <a class="el" href="ModuleMap_8h_source.html#l00138">TextualHeader</a>.</p>

<p class="reference">Referenced by <a class="el" href="HeaderSearch_8cpp_source.html#l01558">clang::HeaderSearch::findModuleForHeader()</a>, and <a class="el" href="PPDirectives_8cpp_source.html#l00839">clang::Preprocessor::getModuleForLocation()</a>.</p>

</div>
</div>
<a id="a115a5b7b114346aaa534995084fc3ac0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a115a5b7b114346aaa534995084fc3ac0">&#9670;&nbsp;</a></span>findOrCreateModule()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; <a class="el" href="classclang_1_1Module.html">Module</a> *, <a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a> &gt; ModuleMap::findOrCreateModule </td>
          <td>(</td>
          <td class="paramtype">StringRef&#160;</td>
          <td class="paramname"><em>Name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classclang_1_1Module.html">Module</a> *&#160;</td>
          <td class="paramname"><em>Parent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>IsFramework</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>IsExplicit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find a new module or submodule, or create it if it does not already exist. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Name</td><td>The name of the module to find or create.</td></tr>
    <tr><td class="paramname">Parent</td><td>The module that will act as the parent of this submodule, or nullptr to indicate that this is a top-level module.</td></tr>
    <tr><td class="paramname">IsFramework</td><td>Whether this is a framework module.</td></tr>
    <tr><td class="paramname">IsExplicit</td><td>Whether this is an explicit submodule.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The found or newly-created module, along with a boolean value that will be true if the module is newly-created. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ModuleMap_8cpp_source.html#l00834">834</a> of file <a class="el" href="ModuleMap_8cpp_source.html">ModuleMap.cpp</a>.</p>

</div>
</div>
<a id="a7569af5b4b731de5a135caf8636681b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7569af5b4b731de5a135caf8636681b3">&#9670;&nbsp;</a></span>findResolvedModulesForHeader()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classclang_1_1ModuleMap_1_1KnownHeader.html">ModuleMap::KnownHeader</a> &gt; ModuleMap::findResolvedModulesForHeader </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classclang_1_1FileEntry.html">FileEntry</a> *&#160;</td>
          <td class="paramname"><em>File</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Like <a class="el" href="classclang_1_1ModuleMap.html#a94cf9768b587f077bf7916c10754713a">findAllModulesForHeader</a>, but do not attempt to infer module ownership from umbrella headers if we've not already done so. </p>

<p class="definition">Definition at line <a class="el" href="ModuleMap_8cpp_source.html#l00698">698</a> of file <a class="el" href="ModuleMap_8cpp_source.html">ModuleMap.cpp</a>.</p>

<p class="reference">References <a class="el" href="namespaceclang.html#a7379bdfd074341d981e1a31d6de2cff3a0b27918290ff5323bea1e3b78a9cf04e">clang::File</a>, and <a class="el" href="ModuleMap_8cpp_source.html#l01200">resolveHeaderDirectives()</a>.</p>

</div>
</div>
<a id="a390f6e47e08d60984fca9c6c492d42f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a390f6e47e08d60984fca9c6c492d42f7">&#9670;&nbsp;</a></span>finishModuleDeclarationScope()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void clang::ModuleMap::finishModuleDeclarationScope </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new declaration scope for module names, allowing previously defined modules to shadow definitions from the new scope. </p>
<dl class="section note"><dt>Note</dt><dd><a class="el" href="classclang_1_1Module.html" title="Describes a module or submodule.">Module</a> names from earlier scopes will shadow names from the new scope, which is the opposite of how shadowing works for variables. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ModuleMap_8h_source.html#l00589">589</a> of file <a class="el" href="ModuleMap_8h_source.html">ModuleMap.h</a>.</p>

</div>
</div>
<a id="a9c2eda49b11b2b5dd41e456d986623e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c2eda49b11b2b5dd41e456d986623e8">&#9670;&nbsp;</a></span>getAdditionalModuleMapFiles()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classclang_1_1ModuleMap.html#ac22c56a8f11f61caa8ab58809a21cca3">AdditionalModMapsSet</a>* clang::ModuleMap::getAdditionalModuleMapFiles </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classclang_1_1Module.html">Module</a> *&#160;</td>
          <td class="paramname"><em>M</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get any module map files other than getModuleMapFileForUniquing(M) that define submodules of a top-level module <code>M</code>. </p>
<p>This is cheaper than getting the module map file for each submodule individually, since the expected number of results is very small. </p>

<p class="definition">Definition at line <a class="el" href="ModuleMap_8h_source.html#l00638">638</a> of file <a class="el" href="ModuleMap_8h_source.html">ModuleMap.h</a>.</p>

</div>
</div>
<a id="a1c4a9836fc4829507cded4d63e24f6fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c4a9836fc4829507cded4d63e24f6fc">&#9670;&nbsp;</a></span>getBuiltinDir()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classclang_1_1DirectoryEntry.html">DirectoryEntry</a>* clang::ModuleMap::getBuiltinDir </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the directory that contains Clang-supplied include files. </p>

<p class="definition">Definition at line <a class="el" href="ModuleMap_8h_source.html#l00415">415</a> of file <a class="el" href="ModuleMap_8h_source.html">ModuleMap.h</a>.</p>

</div>
</div>
<a id="a8673ca4aacbe3e404597553a4c298005"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8673ca4aacbe3e404597553a4c298005">&#9670;&nbsp;</a></span>getCachedModuleLoad()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt;<a class="el" href="classclang_1_1Module.html">Module</a> *&gt; clang::ModuleMap::getCachedModuleLoad </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classclang_1_1IdentifierInfo.html">IdentifierInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>II</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a cached module load. </p>

<p class="definition">Definition at line <a class="el" href="ModuleMap_8h_source.html#l00736">736</a> of file <a class="el" href="ModuleMap_8h_source.html">ModuleMap.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="CompilerInstance_8cpp_source.html#l01959">clang::CompilerInstance::loadModule()</a>.</p>

</div>
</div>
<a id="a303d98d21ca4002f64a8efe0d0861897"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a303d98d21ca4002f64a8efe0d0861897">&#9670;&nbsp;</a></span>getContainingModuleMapFile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceclang.html#a7e226bbdf107c8ffd9cca41873bbdd2d">OptionalFileEntryRef</a> ModuleMap::getContainingModuleMapFile </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classclang_1_1Module.html">Module</a> *&#160;</td>
          <td class="paramname"><em>Module</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve the module map file containing the definition of the given module. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname"><a class="el" href="classclang_1_1Module.html" title="Describes a module or submodule.">Module</a></td><td>The module whose module map file will be returned, if known.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The file entry for the module map file containing the given module, or nullptr if the module definition was inferred. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ModuleMap_8cpp_source.html#l01264">1264</a> of file <a class="el" href="ModuleMap_8cpp_source.html">ModuleMap.cpp</a>.</p>

<p class="reference">References <a class="el" href="Module_8h_source.html#l00104">clang::Module::DefinitionLoc</a>, <a class="el" href="SourceManager_8h_source.html#l01053">clang::SourceManager::getFileEntryRefForID()</a>, <a class="el" href="SourceManager_8h_source.html#l01119">clang::SourceManager::getFileID()</a>, and <a class="el" href="SourceLocation_8h_source.html#l00111">clang::SourceLocation::isInvalid()</a>.</p>

<p class="reference">Referenced by <a class="el" href="CompilerInstance_8cpp_source.html#l01303">compileModule()</a>, and <a class="el" href="ModuleMap_8cpp_source.html#l01273">getModuleMapFileForUniquing()</a>.</p>

</div>
</div>
<a id="a7079336099f427b383128cfa445dd4ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7079336099f427b383128cfa445dd4ea">&#9670;&nbsp;</a></span>getModuleMapFileForUniquing()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceclang.html#a7e226bbdf107c8ffd9cca41873bbdd2d">OptionalFileEntryRef</a> ModuleMap::getModuleMapFileForUniquing </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classclang_1_1Module.html">Module</a> *&#160;</td>
          <td class="paramname"><em>M</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the module map file that (along with the module name) uniquely identifies this module. </p>
<p>The particular module that <code>Name</code> refers to may depend on how the module was found in header search. However, the combination of <code>Name</code> and this module map will be globally unique for top-level modules. In the case of inferred modules, returns the module map that allowed the inference (e.g. contained 'module *'). Otherwise, returns <a class="el" href="classclang_1_1ModuleMap.html#a303d98d21ca4002f64a8efe0d0861897" title="Retrieve the module map file containing the definition of the given module.">getContainingModuleMapFile()</a>. </p>

<p class="definition">Definition at line <a class="el" href="ModuleMap_8cpp_source.html#l01273">1273</a> of file <a class="el" href="ModuleMap_8cpp_source.html">ModuleMap.cpp</a>.</p>

<p class="reference">References <a class="el" href="ModuleMap_8cpp_source.html#l01264">getContainingModuleMapFile()</a>, and <a class="el" href="Module_8h_source.html#l00302">clang::Module::IsInferred</a>.</p>

<p class="reference">Referenced by <a class="el" href="ModuleDepCollector_8cpp_source.html#l00228">clang::tooling::dependencies::ModuleDepCollector::applyDiscoveredDependencies()</a>, <a class="el" href="CompilerInstance_8cpp_source.html#l01303">compileModule()</a>, <a class="el" href="HeaderSearch_8cpp_source.html#l00173">clang::HeaderSearch::getCachedModuleFileName()</a>, and <a class="el" href="HeaderSearch_8cpp_source.html#l00214">clang::HeaderSearch::getPrebuiltImplicitModuleFileName()</a>.</p>

</div>
</div>
<a id="af95957116dd995616c90e64c864811cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af95957116dd995616c90e64c864811cd">&#9670;&nbsp;</a></span>headerKindToRole()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classclang_1_1ModuleMap.html#ac7a2413d4d0a8f29d2dad359bcfd8dec">ModuleMap::ModuleHeaderRole</a> ModuleMap::headerKindToRole </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1Module.html#a359f634f3c9358d7c969744e25beb826">Module::HeaderKind</a>&#160;</td>
          <td class="paramname"><em>Kind</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert a header kind to a role. Requires Kind to not be HK_Excluded. </p>

<p class="definition">Definition at line <a class="el" href="ModuleMap_8cpp_source.html#l00093">93</a> of file <a class="el" href="ModuleMap_8cpp_source.html">ModuleMap.cpp</a>.</p>

<p class="reference">References <a class="el" href="ModuleMap_8h_source.html#l00141">ExcludedHeader</a>, <a class="el" href="Module_8h_source.html#l00209">clang::Module::HK_Excluded</a>, <a class="el" href="Module_8h_source.html#l00205">clang::Module::HK_Normal</a>, <a class="el" href="Module_8h_source.html#l00207">clang::Module::HK_Private</a>, <a class="el" href="Module_8h_source.html#l00208">clang::Module::HK_PrivateTextual</a>, <a class="el" href="Module_8h_source.html#l00206">clang::Module::HK_Textual</a>, <a class="el" href="ModuleMap_8h_source.html#l00131">NormalHeader</a>, <a class="el" href="ModuleMap_8h_source.html#l00134">PrivateHeader</a>, and <a class="el" href="ModuleMap_8h_source.html#l00138">TextualHeader</a>.</p>

</div>
</div>
<a id="a32c51efd0ee64aaadd73218544eeeb01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32c51efd0ee64aaadd73218544eeeb01">&#9670;&nbsp;</a></span>headerRoleToKind()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classclang_1_1Module.html#a359f634f3c9358d7c969744e25beb826">Module::HeaderKind</a> ModuleMap::headerRoleToKind </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1ModuleMap.html#ac7a2413d4d0a8f29d2dad359bcfd8dec">ModuleHeaderRole</a>&#160;</td>
          <td class="paramname"><em>Role</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert a header role to a kind. </p>

<p class="definition">Definition at line <a class="el" href="ModuleMap_8cpp_source.html#l00076">76</a> of file <a class="el" href="ModuleMap_8cpp_source.html">ModuleMap.cpp</a>.</p>

<p class="reference">References <a class="el" href="ModuleMap_8h_source.html#l00141">ExcludedHeader</a>, <a class="el" href="Module_8h_source.html#l00209">clang::Module::HK_Excluded</a>, <a class="el" href="Module_8h_source.html#l00205">clang::Module::HK_Normal</a>, <a class="el" href="Module_8h_source.html#l00207">clang::Module::HK_Private</a>, <a class="el" href="Module_8h_source.html#l00208">clang::Module::HK_PrivateTextual</a>, <a class="el" href="Module_8h_source.html#l00206">clang::Module::HK_Textual</a>, <a class="el" href="ModuleMap_8h_source.html#l00131">NormalHeader</a>, <a class="el" href="ModuleMap_8h_source.html#l00134">PrivateHeader</a>, and <a class="el" href="ModuleMap_8h_source.html#l00138">TextualHeader</a>.</p>

<p class="reference">Referenced by <a class="el" href="ModuleMap_8cpp_source.html#l01235">addHeader()</a>.</p>

</div>
</div>
<a id="ad78651ebbabbed8598a8b3d71c0712f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad78651ebbabbed8598a8b3d71c0712f6">&#9670;&nbsp;</a></span>inferFrameworkModule()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classclang_1_1Module.html">Module</a> * ModuleMap::inferFrameworkModule </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classclang_1_1DirectoryEntry.html">DirectoryEntry</a> *&#160;</td>
          <td class="paramname"><em>FrameworkDir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>IsSystem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classclang_1_1Module.html">Module</a> *&#160;</td>
          <td class="paramname"><em>Parent</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Infer the contents of a framework module map from the given framework directory. </p>

<p class="definition">Definition at line <a class="el" href="ModuleMap_8cpp_source.html#l00941">941</a> of file <a class="el" href="ModuleMap_8cpp_source.html">ModuleMap.cpp</a>.</p>

<p class="reference">References <a class="el" href="Module_8h_source.html#l00294">clang::Module::IsSystem</a>, and <a class="el" href="ASTDiff_8cpp_source.html#l00191">Parent</a>.</p>

</div>
</div>
<a id="a1e8ca3bc91f0e93e6c706b80f263e521"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e8ca3bc91f0e93e6c706b80f263e521">&#9670;&nbsp;</a></span>isBuiltinHeader() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a> ModuleMap::isBuiltinHeader </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classclang_1_1FileEntry.html">FileEntry</a> *&#160;</td>
          <td class="paramname"><em>File</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ModuleMap_8cpp_source.html#l00394">394</a> of file <a class="el" href="ModuleMap_8cpp_source.html">ModuleMap.cpp</a>.</p>

<p class="reference">References <a class="el" href="namespaceclang.html#a7379bdfd074341d981e1a31d6de2cff3a0b27918290ff5323bea1e3b78a9cf04e">clang::File</a>, and <a class="el" href="ModuleMap_8cpp_source.html#l00378">isBuiltinHeader()</a>.</p>

</div>
</div>
<a id="a40c825f7506d1abd0d9bc54eba6330e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40c825f7506d1abd0d9bc54eba6330e6">&#9670;&nbsp;</a></span>isBuiltinHeader() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a> ModuleMap::isBuiltinHeader </td>
          <td>(</td>
          <td class="paramtype">StringRef&#160;</td>
          <td class="paramname"><em>FileName</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Is this a compiler builtin header? </p>
<p>Determine whether the given file name is the name of a builtin header, supplied by Clang to replace, override, or augment existing system headers. </p>

<p class="definition">Definition at line <a class="el" href="ModuleMap_8cpp_source.html#l00378">378</a> of file <a class="el" href="ModuleMap_8cpp_source.html">ModuleMap.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="ModuleMap_8cpp_source.html#l00394">isBuiltinHeader()</a>, <a class="el" href="HeaderSearch_8cpp_source.html#l01403">clang::HeaderSearch::ShouldEnterIncludeFile()</a>, and <a class="el" href="HeaderSearch_8cpp_source.html#l01578">suggestModule()</a>.</p>

</div>
</div>
<a id="afc11dbc10f0658870b83753074c3c1d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc11dbc10f0658870b83753074c3c1d9">&#9670;&nbsp;</a></span>isHeaderInUnavailableModule()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a> ModuleMap::isHeaderInUnavailableModule </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classclang_1_1FileEntry.html">FileEntry</a> *&#160;</td>
          <td class="paramname"><em>Header</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine whether the given header is part of a module marked 'unavailable'. </p>

<p class="definition">Definition at line <a class="el" href="ModuleMap_8cpp_source.html#l00707">707</a> of file <a class="el" href="ModuleMap_8cpp_source.html">ModuleMap.cpp</a>.</p>

<p class="reference">References <a class="el" href="ModuleMap_8cpp_source.html#l00712">isHeaderUnavailableInModule()</a>.</p>

</div>
</div>
<a id="a890ef9bee13458036c9e4d5d7df58c8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a890ef9bee13458036c9e4d5d7df58c8f">&#9670;&nbsp;</a></span>isHeaderUnavailableInModule()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a> ModuleMap::isHeaderUnavailableInModule </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classclang_1_1FileEntry.html">FileEntry</a> *&#160;</td>
          <td class="paramname"><em>Header</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classclang_1_1Module.html">Module</a> *&#160;</td>
          <td class="paramname"><em>RequestingModule</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine whether the given header is unavailable as part of the specified module. </p>

<p class="definition">Definition at line <a class="el" href="ModuleMap_8cpp_source.html#l00712">712</a> of file <a class="el" href="ModuleMap_8cpp_source.html">ModuleMap.cpp</a>.</p>

<p class="reference">References <a class="el" href="ModuleMap_8h_source.html#l00141">ExcludedHeader</a>, <a class="el" href="FileEntry_8h_source.html#l00394">clang::FileEntry::getDir()</a>, <a class="el" href="DirectoryEntry_8h_source.html#l00049">clang::DirectoryEntry::getName()</a>, <a class="el" href="Module_8cpp_source.html#l00264">clang::Module::getUmbrellaDir()</a>, <a class="el" href="RecursiveASTVisitor_8h_source.html#l01081">clang::if()</a>, <a class="el" href="Module_8h_source.html#l00308">clang::Module::InferSubmodules</a>, <a class="el" href="Module_8h_source.html#l00477">clang::Module::isAvailable()</a>, <a class="el" href="Module_8cpp_source.html#l00193">clang::Module::isSubModuleOf()</a>, <a class="el" href="Module_8h_source.html#l00135">clang::Module::Parent</a>, <a class="el" href="ModuleMap_8cpp_source.html#l01200">resolveHeaderDirectives()</a>, and <a class="el" href="ModuleMap_8h_source.html#l00138">TextualHeader</a>.</p>

<p class="reference">Referenced by <a class="el" href="ModuleMap_8cpp_source.html#l00707">isHeaderInUnavailableModule()</a>.</p>

</div>
</div>
<a id="a5ddbcfb5014e3bd0bcf33a30b41cc511"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ddbcfb5014e3bd0bcf33a30b41cc511">&#9670;&nbsp;</a></span>isModular()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a> ModuleMap::isModular </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1ModuleMap.html#ac7a2413d4d0a8f29d2dad359bcfd8dec">ModuleHeaderRole</a>&#160;</td>
          <td class="paramname"><em>Role</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if the header with the given role is a modular one. </p>

<p class="definition">Definition at line <a class="el" href="ModuleMap_8cpp_source.html#l00109">109</a> of file <a class="el" href="ModuleMap_8cpp_source.html">ModuleMap.cpp</a>.</p>

<p class="reference">References <a class="el" href="ModuleMap_8h_source.html#l00141">ExcludedHeader</a>, and <a class="el" href="ModuleMap_8h_source.html#l00138">TextualHeader</a>.</p>

<p class="reference">Referenced by <a class="el" href="HeaderSearch_8cpp_source.html#l01384">clang::HeaderSearch::MarkFileModuleHeader()</a>, and <a class="el" href="ASTReader_8cpp_source.html#l01918">clang::serialization::reader::HeaderFileInfoTrait::ReadData()</a>.</p>

</div>
</div>
<a id="ac4bd056e3b16607ace724463606dd3d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4bd056e3b16607ace724463606dd3d5">&#9670;&nbsp;</a></span>lookupModuleQualified()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classclang_1_1Module.html">Module</a> * ModuleMap::lookupModuleQualified </td>
          <td>(</td>
          <td class="paramtype">StringRef&#160;</td>
          <td class="paramname"><em>Name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classclang_1_1Module.html">Module</a> *&#160;</td>
          <td class="paramname"><em>Context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve a module with the given name within the given context, using direct (qualified) name lookup. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Name</td><td>The name of the module to look up.</td></tr>
    <tr><td class="paramname">Context</td><td>The module for which we will look for a submodule. If null, we will look for a top-level module.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The named submodule, if known; otherwose, returns null. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ModuleMap_8cpp_source.html#l00827">827</a> of file <a class="el" href="ModuleMap_8cpp_source.html">ModuleMap.cpp</a>.</p>

</div>
</div>
<a id="a9682383d1483005eb8de8ab46275f5e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9682383d1483005eb8de8ab46275f5e5">&#9670;&nbsp;</a></span>lookupModuleUnqualified()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classclang_1_1Module.html">Module</a> * ModuleMap::lookupModuleUnqualified </td>
          <td>(</td>
          <td class="paramtype">StringRef&#160;</td>
          <td class="paramname"><em>Name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classclang_1_1Module.html">Module</a> *&#160;</td>
          <td class="paramname"><em>Context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve a module with the given name using lexical name lookup, starting at the given context. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Name</td><td>The name of the module to look up.</td></tr>
    <tr><td class="paramname">Context</td><td>The module context, from which we will perform lexical name lookup.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The named module, if known; otherwise, returns null. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ModuleMap_8cpp_source.html#l00817">817</a> of file <a class="el" href="ModuleMap_8cpp_source.html">ModuleMap.cpp</a>.</p>

</div>
</div>
<a id="a3df11cf9b74e240aa373f25c1a63b49f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3df11cf9b74e240aa373f25c1a63b49f">&#9670;&nbsp;</a></span>mayShadowNewModule()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a> clang::ModuleMap::mayShadowNewModule </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1Module.html">Module</a> *&#160;</td>
          <td class="paramname"><em>ExistingModule</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ModuleMap_8h_source.html#l00591">591</a> of file <a class="el" href="ModuleMap_8h_source.html">ModuleMap.h</a>.</p>

<p class="reference">References <a class="el" href="Module_8h_source.html#l00135">clang::Module::Parent</a>.</p>

</div>
</div>
<a id="a6ab65f1f0882fcff9a15da9cfbf0fd02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ab65f1f0882fcff9a15da9cfbf0fd02">&#9670;&nbsp;</a></span>module_begin()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classclang_1_1ModuleMap.html#a1b352087754574155a198a4cb0d6e197">module_iterator</a> clang::ModuleMap::module_begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ModuleMap_8h_source.html#l00724">724</a> of file <a class="el" href="ModuleMap_8h_source.html">ModuleMap.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="CompilerInstance_8cpp_source.html#l02201">clang::CompilerInstance::loadGlobalModuleIndex()</a>, and <a class="el" href="ModuleMap_8h_source.html#l00726">modules()</a>.</p>

</div>
</div>
<a id="a9d9e3147d81ec86cf00eea874d9ea95b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d9e3147d81ec86cf00eea874d9ea95b">&#9670;&nbsp;</a></span>module_end()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classclang_1_1ModuleMap.html#a1b352087754574155a198a4cb0d6e197">module_iterator</a> clang::ModuleMap::module_end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ModuleMap_8h_source.html#l00725">725</a> of file <a class="el" href="ModuleMap_8h_source.html">ModuleMap.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="CompilerInstance_8cpp_source.html#l02201">clang::CompilerInstance::loadGlobalModuleIndex()</a>, and <a class="el" href="ModuleMap_8h_source.html#l00726">modules()</a>.</p>

</div>
</div>
<a id="a9124c52cfa4df22a479eddbcc8e350d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9124c52cfa4df22a479eddbcc8e350d3">&#9670;&nbsp;</a></span>modules()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">llvm::iterator_range&lt;<a class="el" href="classclang_1_1ModuleMap.html#a1b352087754574155a198a4cb0d6e197">module_iterator</a>&gt; clang::ModuleMap::modules </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ModuleMap_8h_source.html#l00726">726</a> of file <a class="el" href="ModuleMap_8h_source.html">ModuleMap.h</a>.</p>

<p class="reference">References <a class="el" href="ModuleMap_8h_source.html#l00724">module_begin()</a>, and <a class="el" href="ModuleMap_8h_source.html#l00725">module_end()</a>.</p>

</div>
</div>
<a id="a516cfeb32bb3a464262cf6f369417eab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a516cfeb32bb3a464262cf6f369417eab">&#9670;&nbsp;</a></span>parseModuleMapFile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a> ModuleMap::parseModuleMapFile </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classclang_1_1FileEntry.html">FileEntry</a> *&#160;</td>
          <td class="paramname"><em>File</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>IsSystem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classclang_1_1DirectoryEntry.html">DirectoryEntry</a> *&#160;</td>
          <td class="paramname"><em>HomeDir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classclang_1_1FileID.html">FileID</a>&#160;</td>
          <td class="paramname"><em>ID</em> = <code><a class="el" href="classclang_1_1FileID.html">FileID</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a> *&#160;</td>
          <td class="paramname"><em>Offset</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classclang_1_1SourceLocation.html">SourceLocation</a>&#160;</td>
          <td class="paramname"><em>ExternModuleLoc</em> = <code><a class="el" href="classclang_1_1SourceLocation.html">SourceLocation</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parse the given module map file, and record any modules we encounter. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">File</td><td>The file to be parsed.</td></tr>
    <tr><td class="paramname">IsSystem</td><td>Whether this module map file is in a system header directory, and therefore should be considered a system module.</td></tr>
    <tr><td class="paramname">HomeDir</td><td>The directory in which relative paths within this module map file will be resolved.</td></tr>
    <tr><td class="paramname">ID</td><td>The <a class="el" href="classclang_1_1FileID.html" title="An opaque identifier used by SourceManager which refers to a source file (MemoryBuffer) along with it...">FileID</a> of the file to process, if we've already entered it.</td></tr>
    <tr><td class="paramname">Offset</td><td>[inout] On input the offset at which to start parsing. On output, the offset at which the module map terminated.</td></tr>
    <tr><td class="paramname">ExternModuleLoc</td><td>The location of the "extern module" declaration that caused us to load this module map file, if any.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if an error occurred, false otherwise. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ModuleMap_8cpp_source.html#l03053">3053</a> of file <a class="el" href="ModuleMap_8cpp_source.html">ModuleMap.cpp</a>.</p>

<p class="reference">References <a class="el" href="SourceManager_8h_source.html#l00085">clang::SrcMgr::C_System_ModuleMap</a>, <a class="el" href="SourceManager_8h_source.html#l00084">clang::SrcMgr::C_User_ModuleMap</a>, <a class="el" href="SourceManager_8cpp_source.html#l00533">clang::SourceManager::createFileID()</a>, <a class="el" href="namespaceclang.html#a7379bdfd074341d981e1a31d6de2cff3a0b27918290ff5323bea1e3b78a9cf04e">clang::File</a>, <a class="el" href="SourceManager_8h_source.html#l01027">clang::SourceManager::getBufferOrNone()</a>, <a class="el" href="SourceManager_8h_source.html#l01246">clang::SourceManager::getDecomposedLoc()</a>, <a class="el" href="SourceManager_8h_source.html#l01128">clang::SourceManager::getLocForStartOfFile()</a>, <a class="el" href="Lexer_8cpp_source.html#l01149">clang::Lexer::getSourceLocation()</a>, and <a class="el" href="Format_8cpp_source.html#l02775">Offset</a>.</p>

</div>
</div>
<a id="a635593eb7f27a7297eb22afacd08d104"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a635593eb7f27a7297eb22afacd08d104">&#9670;&nbsp;</a></span>resolveConflicts()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a> ModuleMap::resolveConflicts </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1Module.html">Module</a> *&#160;</td>
          <td class="paramname"><em>Mod</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>Complain</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resolve all of the unresolved conflicts in the given module. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Mod</td><td>The module whose conflicts should be resolved.</td></tr>
    <tr><td class="paramname">Complain</td><td>Whether to emit diagnostics for failures.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if any errors were encountered while resolving conflicts, false otherwise. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ModuleMap_8cpp_source.html#l01383">1383</a> of file <a class="el" href="ModuleMap_8cpp_source.html">ModuleMap.cpp</a>.</p>

<p class="reference">References <a class="el" href="Module_8h_source.html#l00445">clang::Module::Conflicts</a>, <a class="el" href="Module_8h_source.html#l00441">clang::Module::Conflict::Message</a>, <a class="el" href="Module_8h_source.html#l00438">clang::Module::Conflict::Other</a>, <a class="el" href="namespaceclang.html#addf89b16eec81ec256e98fa0cc9cdd65a4a3b76ab214699973b85cc072788ff7d">clang::Unresolved</a>, and <a class="el" href="Module_8h_source.html#l00433">clang::Module::UnresolvedConflicts</a>.</p>

<p class="reference">Referenced by <a class="el" href="PPLexerChange_8cpp_source.html#l00694">clang::Preprocessor::EnterSubmodule()</a>.</p>

</div>
</div>
<a id="a03d91ee91e3d302d32885c4d790b3915"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03d91ee91e3d302d32885c4d790b3915">&#9670;&nbsp;</a></span>resolveExports()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a> ModuleMap::resolveExports </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1Module.html">Module</a> *&#160;</td>
          <td class="paramname"><em>Mod</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>Complain</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resolve all of the unresolved exports in the given module. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Mod</td><td>The module whose exports should be resolved.</td></tr>
    <tr><td class="paramname">Complain</td><td>Whether to emit diagnostics for failures.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if any errors were encountered while resolving exports, false otherwise. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ModuleMap_8cpp_source.html#l01357">1357</a> of file <a class="el" href="ModuleMap_8cpp_source.html">ModuleMap.cpp</a>.</p>

<p class="reference">References <a class="el" href="Module_8h_source.html#l00363">clang::Module::Exports</a>, <a class="el" href="namespaceclang.html#addf89b16eec81ec256e98fa0cc9cdd65a4a3b76ab214699973b85cc072788ff7d">clang::Unresolved</a>, and <a class="el" href="Module_8h_source.html#l00381">clang::Module::UnresolvedExports</a>.</p>

<p class="reference">Referenced by <a class="el" href="PPLexerChange_8cpp_source.html#l00694">clang::Preprocessor::EnterSubmodule()</a>.</p>

</div>
</div>
<a id="a64ce2c7a23bcff10e7ae4bfcda637182"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64ce2c7a23bcff10e7ae4bfcda637182">&#9670;&nbsp;</a></span>resolveHeaderDirectives() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ModuleMap::resolveHeaderDirectives </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classclang_1_1FileEntry.html">FileEntry</a> *&#160;</td>
          <td class="paramname"><em>File</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resolve all lazy header directives for the specified file. </p>
<p>This ensures that the <a class="el" href="structclang_1_1HeaderFileInfo.html" title="The preprocessor keeps track of this information for each file that is #included.">HeaderFileInfo</a> on <a class="el" href="classclang_1_1HeaderSearch.html" title="Encapsulates the information needed to find the file referenced by a #include or #include_next,...">HeaderSearch</a> is up to date. This is effectively internal, but is exposed so <a class="el" href="classclang_1_1HeaderSearch.html" title="Encapsulates the information needed to find the file referenced by a #include or #include_next,...">HeaderSearch</a> can call it. </p>

<p class="definition">Definition at line <a class="el" href="ModuleMap_8cpp_source.html#l01200">1200</a> of file <a class="el" href="ModuleMap_8cpp_source.html">ModuleMap.cpp</a>.</p>

<p class="reference">References <a class="el" href="namespaceclang.html#a7379bdfd074341d981e1a31d6de2cff3a0b27918290ff5323bea1e3b78a9cf04e">clang::File</a>.</p>

<p class="reference">Referenced by <a class="el" href="ModuleMap_8cpp_source.html#l00474">diagnoseHeaderInclusion()</a>, <a class="el" href="ModuleMap_8cpp_source.html#l00698">findResolvedModulesForHeader()</a>, <a class="el" href="ModuleMap_8cpp_source.html#l00712">isHeaderUnavailableInModule()</a>, and <a class="el" href="HeaderSearch_8cpp_source.html#l01403">clang::HeaderSearch::ShouldEnterIncludeFile()</a>.</p>

</div>
</div>
<a id="a41dcd87105f5059bc55a3f3db230e9bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41dcd87105f5059bc55a3f3db230e9bb">&#9670;&nbsp;</a></span>resolveHeaderDirectives() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ModuleMap::resolveHeaderDirectives </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1Module.html">Module</a> *&#160;</td>
          <td class="paramname"><em>Mod</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::optional&lt; const <a class="el" href="classclang_1_1FileEntry.html">FileEntry</a> * &gt;&#160;</td>
          <td class="paramname"><em>File</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resolve lazy header directives for the specified module. </p>
<p>If File is provided, only headers with same size and modtime are resolved. If File is not set, all headers are resolved. </p>

<p class="definition">Definition at line <a class="el" href="ModuleMap_8cpp_source.html#l01216">1216</a> of file <a class="el" href="ModuleMap_8cpp_source.html">ModuleMap.cpp</a>.</p>

<p class="reference">References <a class="el" href="namespaceclang.html#a7379bdfd074341d981e1a31d6de2cff3a0b27918290ff5323bea1e3b78a9cf04e">clang::File</a>, <a class="el" href="Module_8h_source.html#l00245">clang::Module::UnresolvedHeaderDirective::ModTime</a>, <a class="el" href="Module_8h_source.html#l00244">clang::Module::UnresolvedHeaderDirective::Size</a>, and <a class="el" href="Module_8h_source.html#l00250">clang::Module::UnresolvedHeaders</a>.</p>

</div>
</div>
<a id="ac588ee8d4c631303982ed1c68002f49d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac588ee8d4c631303982ed1c68002f49d">&#9670;&nbsp;</a></span>resolveLinkAsDependencies()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ModuleMap::resolveLinkAsDependencies </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1Module.html">Module</a> *&#160;</td>
          <td class="paramname"><em>Mod</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Use PendingLinkAsModule information to mark top level link names that are going to be replaced by export_as aliases. </p>

<p class="definition">Definition at line <a class="el" href="ModuleMap_8cpp_source.html#l00058">58</a> of file <a class="el" href="ModuleMap_8cpp_source.html">ModuleMap.cpp</a>.</p>

<p class="reference">References <a class="el" href="Module_8h_source.html#l00101">clang::Module::Name</a>.</p>

</div>
</div>
<a id="aff262a15ac7933edd463953d969e4f6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff262a15ac7933edd463953d969e4f6b">&#9670;&nbsp;</a></span>resolveUses()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a> ModuleMap::resolveUses </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1Module.html">Module</a> *&#160;</td>
          <td class="paramname"><em>Mod</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>Complain</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resolve all of the unresolved uses in the given module. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Mod</td><td>The module whose uses should be resolved.</td></tr>
    <tr><td class="paramname">Complain</td><td>Whether to emit diagnostics for failures.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if any errors were encountered while resolving uses, false otherwise. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ModuleMap_8cpp_source.html#l01370">1370</a> of file <a class="el" href="ModuleMap_8cpp_source.html">ModuleMap.cpp</a>.</p>

<p class="reference">References <a class="el" href="Module_8h_source.html#l00384">clang::Module::DirectUses</a>, <a class="el" href="namespaceclang.html#addf89b16eec81ec256e98fa0cc9cdd65a4a3b76ab214699973b85cc072788ff7d">clang::Unresolved</a>, and <a class="el" href="Module_8h_source.html#l00387">clang::Module::UnresolvedDirectUses</a>.</p>

<p class="reference">Referenced by <a class="el" href="ModuleMap_8cpp_source.html#l00474">diagnoseHeaderInclusion()</a>, <a class="el" href="PPLexerChange_8cpp_source.html#l00694">clang::Preprocessor::EnterSubmodule()</a>, and <a class="el" href="HeaderSearch_8cpp_source.html#l01578">suggestModule()</a>.</p>

</div>
</div>
<a id="a6c624a7392febb43c7bb1a19e835ab34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c624a7392febb43c7bb1a19e835ab34">&#9670;&nbsp;</a></span>setBuiltinIncludeDir()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void clang::ModuleMap::setBuiltinIncludeDir </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classclang_1_1DirectoryEntry.html">DirectoryEntry</a> *&#160;</td>
          <td class="paramname"><em>Dir</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the directory that contains Clang-supplied include files, such as our <a class="el" href="stdarg_8h.html">stdarg.h</a> or <a class="el" href="tgmath_8h.html">tgmath.h</a>. </p>

<p class="definition">Definition at line <a class="el" href="ModuleMap_8h_source.html#l00410">410</a> of file <a class="el" href="ModuleMap_8h_source.html">ModuleMap.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="InitHeaderSearch_8cpp_source.html#l00629">clang::ApplyHeaderSearchOptions()</a>.</p>

</div>
</div>
<a id="a64cf116b47bb6201a8154feab288cc65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64cf116b47bb6201a8154feab288cc65">&#9670;&nbsp;</a></span>setInferredModuleAllowedBy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ModuleMap::setInferredModuleAllowedBy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1Module.html">Module</a> *&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classclang_1_1FileEntry.html">FileEntry</a> *&#160;</td>
          <td class="paramname"><em>ModMap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ModuleMap_8cpp_source.html#l01282">1282</a> of file <a class="el" href="ModuleMap_8cpp_source.html">ModuleMap.cpp</a>.</p>

<p class="reference">References <a class="el" href="Module_8h_source.html#l00302">clang::Module::IsInferred</a>.</p>

<p class="reference">Referenced by <a class="el" href="FrontendAction_8cpp_source.html#l00483">prepareToBuildModule()</a>.</p>

</div>
</div>
<a id="abc441df169e00dbd5ab3a5db003d454f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc441df169e00dbd5ab3a5db003d454f">&#9670;&nbsp;</a></span>setTarget()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ModuleMap::setTarget </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classclang_1_1TargetInfo.html">TargetInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>Target</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the target information. </p>

<p class="definition">Definition at line <a class="el" href="ModuleMap_8cpp_source.html#l00332">332</a> of file <a class="el" href="ModuleMap_8cpp_source.html">ModuleMap.cpp</a>.</p>

<p class="reference">References <a class="el" href="namespaceclang.html#acdf88ec6c845aa781824469fcb0af66cac41a31890959544c6523af684561abe5">clang::Target</a>.</p>

<p class="reference">Referenced by <a class="el" href="HeaderSearch_8cpp_source.html#l00744">clang::HeaderSearch::setTarget()</a>.</p>

</div>
</div>
<a id="a4c5148fa4f93b67492291bee915c9e27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c5148fa4f93b67492291bee915c9e27">&#9670;&nbsp;</a></span>setUmbrellaDir()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ModuleMap::setUmbrellaDir </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1Module.html">Module</a> *&#160;</td>
          <td class="paramname"><em>Mod</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classclang_1_1DirectoryEntry.html">DirectoryEntry</a> *&#160;</td>
          <td class="paramname"><em>UmbrellaDir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Twine &amp;&#160;</td>
          <td class="paramname"><em>NameAsWritten</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Twine &amp;&#160;</td>
          <td class="paramname"><em>PathRelativeToRootModuleDirectory</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the umbrella directory of the given module to the given directory. </p>

<p class="definition">Definition at line <a class="el" href="ModuleMap_8cpp_source.html#l01154">1154</a> of file <a class="el" href="ModuleMap_8cpp_source.html">ModuleMap.cpp</a>.</p>

<p class="reference">References <a class="el" href="Module_8h_source.html#l00148">clang::Module::Umbrella</a>, <a class="el" href="Module_8h_source.html#l00154">clang::Module::UmbrellaAsWritten</a>, and <a class="el" href="Module_8h_source.html#l00157">clang::Module::UmbrellaRelativeToRootModuleDirectory</a>.</p>

</div>
</div>
<a id="a0557c399446ad6ecf42bc7eaa4eb86d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0557c399446ad6ecf42bc7eaa4eb86d0">&#9670;&nbsp;</a></span>setUmbrellaHeader()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ModuleMap::setUmbrellaHeader </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1Module.html">Module</a> *&#160;</td>
          <td class="paramname"><em>Mod</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classclang_1_1FileEntryRef.html">FileEntryRef</a>&#160;</td>
          <td class="paramname"><em>UmbrellaHeader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Twine &amp;&#160;</td>
          <td class="paramname"><em>NameAsWritten</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Twine &amp;&#160;</td>
          <td class="paramname"><em>PathRelativeToRootModuleDirectory</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the umbrella header of the given module to the given header. </p>

<p class="definition">Definition at line <a class="el" href="ModuleMap_8cpp_source.html#l01139">1139</a> of file <a class="el" href="ModuleMap_8cpp_source.html">ModuleMap.cpp</a>.</p>

<p class="reference">References <a class="el" href="FileEntry_8h_source.html#l00073">clang::FileEntryRef::getDir()</a>, <a class="el" href="SourceManager_8h_source.html#l00818">clang::SourceManager::getFileManager()</a>, <a class="el" href="FileEntry_8h_source.html#l00161">clang::FileEntryRef::getMapEntry()</a>, <a class="el" href="ModuleMap_8h_source.html#l00131">NormalHeader</a>, <a class="el" href="Module_8h_source.html#l00148">clang::Module::Umbrella</a>, <a class="el" href="Module_8h_source.html#l00154">clang::Module::UmbrellaAsWritten</a>, and <a class="el" href="Module_8h_source.html#l00157">clang::Module::UmbrellaRelativeToRootModuleDirectory</a>.</p>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="a69fccb440615f32e24516ed4e718457d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69fccb440615f32e24516ed4e718457d">&#9670;&nbsp;</a></span>ModuleMapParser</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="classclang_1_1ModuleMapParser.html">ModuleMapParser</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ModuleMap_8h_source.html#l00202">202</a> of file <a class="el" href="ModuleMap_8h_source.html">ModuleMap.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>include/clang/Lex/<a class="el" href="ModuleMap_8h_source.html">ModuleMap.h</a></li>
<li>lib/Lex/<a class="el" href="ModuleMap_8cpp_source.html">ModuleMap.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Aug 7 2023 13:47:52 for clang by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
